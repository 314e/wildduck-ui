/* tslint:disable */
/* eslint-disable */
/**
 * WildDuck API
 * WildDuck API docs
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Action to take with a matching message
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * If true then mark matching messages as Seen
     * @type {boolean}
     * @memberof Action
     */
    seen?: boolean;
    /**
     * If true then mark matching messages as Flagged
     * @type {boolean}
     * @memberof Action
     */
    flag?: boolean;
    /**
     * If true then do not store matching messages
     * @type {boolean}
     * @memberof Action
     */
    _delete?: boolean;
    /**
     * If true then store matching messags to Junk Mail folder
     * @type {boolean}
     * @memberof Action
     */
    spam?: boolean;
    /**
     * Mailbox ID to store matching messages to
     * @type {string}
     * @memberof Action
     */
    mailbox?: string;
    /**
     * An array of forwarding targets. The value could either be an email address or a relay url to next MX server (\"smtp://mx2.zone.eu:25\") or an URL where mail contents are POSTed to
     * @type {Array<string>}
     * @memberof Action
     */
    targets?: Array<string>;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Name of the sender/recipient
     * @type {string}
     * @memberof Address
     */
    name: string;
    /**
     * Address of the sender/recipient
     * @type {string}
     * @memberof Address
     */
    address: string;
}
/**
 * Account limits and usage
 * @export
 * @interface AddressLimits
 */
export interface AddressLimits {
    /**
     * 
     * @type {Forwards}
     * @memberof AddressLimits
     */
    forwards: Forwards;
}
/**
 * 
 * @export
 * @interface AddressOptionalName
 */
export interface AddressOptionalName {
    /**
     * Name of the sender
     * @type {string}
     * @memberof AddressOptionalName
     */
    name?: string;
    /**
     * Address of the sender
     * @type {string}
     * @memberof AddressOptionalName
     */
    address: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AspScopes {
    Imap = 'imap',
    Pop3 = 'pop3',
    Smtp = 'smtp',
    Star = '*'
}

/**
 * List of attachments for this message
 * @export
 * @interface Attachments
 */
export interface Attachments {
    /**
     * Attachment ID
     * @type {string}
     * @memberof Attachments
     */
    id: string;
    /**
     * SHA-256 hash of the contents of the attachment
     * @type {string}
     * @memberof Attachments
     */
    hash?: string;
    /**
     * Filename of the attachment
     * @type {string}
     * @memberof Attachments
     */
    filename: string;
    /**
     * MIME type
     * @type {string}
     * @memberof Attachments
     */
    contentType: string;
    /**
     * Attachment disposition
     * @type {string}
     * @memberof Attachments
     */
    disposition: string;
    /**
     * Which transfer encoding was used (actual content when fetching attachments is not encoded)
     * @type {string}
     * @memberof Attachments
     */
    transferEncoding: string;
    /**
     * Was this attachment found from a multipart/related node. This usually means that this is an embedded image
     * @type {boolean}
     * @memberof Attachments
     */
    related: boolean;
    /**
     * Approximate size of the attachment in kilobytes
     * @type {number}
     * @memberof Attachments
     */
    sizeKb: number;
}
/**
 * 
 * @export
 * @interface AttachmentsUpload
 */
export interface AttachmentsUpload {
    /**
     * Base64 encoded attachment content
     * @type {string}
     * @memberof AttachmentsUpload
     */
    content: string;
    /**
     * Attachment filename
     * @type {string}
     * @memberof AttachmentsUpload
     */
    filename?: string;
    /**
     * MIME type for the attachment file
     * @type {string}
     * @memberof AttachmentsUpload
     */
    contentType?: string;
    /**
     * Content-ID value if you want to reference to this attachment from HTML formatted message
     * @type {string}
     * @memberof AttachmentsUpload
     */
    cid?: string;
}
/**
 * 
 * @export
 * @interface AuthenticateRequest
 */
export interface AuthenticateRequest {
    /**
     * Username or E-mail address
     * @type {string}
     * @memberof AuthenticateRequest
     */
    username: string;
    /**
     * Password
     * @type {string}
     * @memberof AuthenticateRequest
     */
    password: string;
    /**
     * Application identifier for security logs
     * @type {string}
     * @memberof AuthenticateRequest
     */
    protocol?: string;
    /**
     * Required scope. One of master, imap, smtp, pop3
     * @type {string}
     * @memberof AuthenticateRequest
     */
    scope?: string;
    /**
     * If true then generates a temporary access token that is valid for this user. Only available if scope is \"master\". When using user tokens then you can replace user ID in URLs with \"me\".
     * @type {boolean}
     * @memberof AuthenticateRequest
     */
    token?: boolean;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof AuthenticateRequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof AuthenticateRequest
     */
    ip?: string;
}
/**
 * 
 * @export
 * @interface AuthenticateResponse
 */
export interface AuthenticateResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof AuthenticateResponse
     */
    success: boolean;
    /**
     * ID of authenticated User
     * @type {string}
     * @memberof AuthenticateResponse
     */
    id: string;
    /**
     * Username of authenticated User
     * @type {string}
     * @memberof AuthenticateResponse
     */
    username: string;
    /**
     * The scope this authentication is valid for
     * @type {string}
     * @memberof AuthenticateResponse
     */
    scope: string;
    /**
     * List of enabled 2FA mechanisms
     * @type {Array<string>}
     * @memberof AuthenticateResponse
     */
    require2fa: Array<string>;
    /**
     * Indicates if account hassword has been reset and should be replaced
     * @type {boolean}
     * @memberof AuthenticateResponse
     */
    requirePasswordChange: boolean;
    /**
     * If access token was requested then this is the value to use as access token when making API requests on behalf of logged in user.
     * @type {string}
     * @memberof AuthenticateResponse
     */
    token?: string;
}
/**
 * Autoreply information
 * @export
 * @interface Autoreply
 */
export interface Autoreply {
    /**
     * If true, then autoreply is enabled for this address
     * @type {boolean}
     * @memberof Autoreply
     */
    status?: boolean;
    /**
     * Either a date string or boolean false to disable start time checks
     * @type {string}
     * @memberof Autoreply
     */
    start?: string;
    /**
     * Either a date string or boolean false to disable end time checks
     * @type {string}
     * @memberof Autoreply
     */
    end?: string;
    /**
     * Name that is used for the From: header in autoreply message
     * @type {string}
     * @memberof Autoreply
     */
    name?: string;
    /**
     * Autoreply subject line
     * @type {string}
     * @memberof Autoreply
     */
    subject?: string;
    /**
     * Autoreply plaintext content
     * @type {string}
     * @memberof Autoreply
     */
    text?: string;
    /**
     * Autoreply HTML content
     * @type {string}
     * @memberof Autoreply
     */
    html?: string;
}
/**
 * Autoreply information
 * @export
 * @interface AutoreplyInfo
 */
export interface AutoreplyInfo {
    /**
     * If true, then autoreply is enabled for this address
     * @type {boolean}
     * @memberof AutoreplyInfo
     */
    status: boolean;
    /**
     * Name that is used for the From: header in autoreply message
     * @type {string}
     * @memberof AutoreplyInfo
     */
    name: string;
    /**
     * Autoreply subject line
     * @type {string}
     * @memberof AutoreplyInfo
     */
    subject: string;
    /**
     * Autoreply plaintext content
     * @type {string}
     * @memberof AutoreplyInfo
     */
    text: string;
    /**
     * Autoreply HTML content
     * @type {string}
     * @memberof AutoreplyInfo
     */
    html: string;
}
/**
 * 
 * @export
 * @interface CheckTotp2FARequest
 */
export interface CheckTotp2FARequest {
    /**
     * 6-digit number
     * @type {string}
     * @memberof CheckTotp2FARequest
     */
    token: string;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof CheckTotp2FARequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof CheckTotp2FARequest
     */
    ip?: string;
}
/**
 * Parsed Content-Type header. Usually needed to identify encrypted messages and such
 * @export
 * @interface ContentType
 */
export interface ContentType {
    /**
     * MIME type of the message, eg. \"multipart/mixed\"
     * @type {string}
     * @memberof ContentType
     */
    value: string;
    /**
     * An object with Content-Type params as key-value pairs
     * @type {object}
     * @memberof ContentType
     */
    params: object;
}
/**
 * 
 * @export
 * @interface CreateASPRequest
 */
export interface CreateASPRequest {
    /**
     * Description
     * @type {string}
     * @memberof CreateASPRequest
     */
    description: string;
    /**
     * List of scopes this Password applies to. Special scope \"*\" indicates that this password can be used for any scope except \"master\"
     * @type {Array<AspScopes>}
     * @memberof CreateASPRequest
     */
    scopes: Array<AspScopes>;
    /**
     * If true then result contains a mobileconfig formatted file with account config
     * @type {boolean}
     * @memberof CreateASPRequest
     */
    generateMobileconfig?: boolean;
    /**
     * E-mail address to be used as the account address in mobileconfig file. Must be one of the listed identity addresses of the user. Defaults to the main address of the user
     * @type {string}
     * @memberof CreateASPRequest
     */
    address?: string;
    /**
     * Optional pregenerated password. Must be 16 characters, latin letters only.
     * @type {string}
     * @memberof CreateASPRequest
     */
    password?: string;
    /**
     * TTL in seconds for this password. Every time password is used, TTL is reset to this value
     * @type {number}
     * @memberof CreateASPRequest
     */
    ttl?: number;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof CreateASPRequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof CreateASPRequest
     */
    ip?: string;
}
/**
 * 
 * @export
 * @interface CreateASPResponse
 */
export interface CreateASPResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof CreateASPResponse
     */
    success: boolean;
    /**
     * ID of the Application Password
     * @type {string}
     * @memberof CreateASPResponse
     */
    id: string;
    /**
     * Application Specific Password. Generated password is whitespace agnostic, so it could be displayed to the client as \"abcd efgh ijkl mnop\" instead of \"abcdefghijklmnop\"
     * @type {string}
     * @memberof CreateASPResponse
     */
    password: string;
    /**
     * Base64 encoded mobileconfig file. Generated profile file should be sent to the client with Content-Type value of application/x-apple-aspen-config.
     * @type {string}
     * @memberof CreateASPResponse
     */
    mobileconfig: string;
}
/**
 * 
 * @export
 * @interface CreateAllowedDomainRequest
 */
export interface CreateAllowedDomainRequest {
    /**
     * Domain name to allowlist for users/addresses that include this tag
     * @type {string}
     * @memberof CreateAllowedDomainRequest
     */
    domain: string;
}
/**
 * 
 * @export
 * @interface CreateAllowedDomainResponse
 */
export interface CreateAllowedDomainResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof CreateAllowedDomainResponse
     */
    success: boolean;
    /**
     * ID for the created record
     * @type {string}
     * @memberof CreateAllowedDomainResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface CreateAuditRequest
 */
export interface CreateAuditRequest {
    /**
     * Users unique ID.
     * @type {string}
     * @memberof CreateAuditRequest
     */
    user: string;
    /**
     * Start time as ISO date
     * @type {string}
     * @memberof CreateAuditRequest
     */
    start?: string;
    /**
     * End time as ISO date
     * @type {string}
     * @memberof CreateAuditRequest
     */
    end?: string;
    /**
     * Expiration date. Audit data is deleted after this date
     * @type {string}
     * @memberof CreateAuditRequest
     */
    expires: string;
}
/**
 * 
 * @export
 * @interface CreateAuditResponse
 */
export interface CreateAuditResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof CreateAuditResponse
     */
    success: boolean;
    /**
     * ID for the created Audit
     * @type {string}
     * @memberof CreateAuditResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface CreateBlockedDomainRequest
 */
export interface CreateBlockedDomainRequest {
    /**
     * Domain name to blocklist for users/addresses that include this tag
     * @type {string}
     * @memberof CreateBlockedDomainRequest
     */
    domain: string;
}
/**
 * 
 * @export
 * @interface CreateBlockedDomainResponse
 */
export interface CreateBlockedDomainResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof CreateBlockedDomainResponse
     */
    success: boolean;
    /**
     * ID for the created record
     * @type {string}
     * @memberof CreateBlockedDomainResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface CreateDomainAliasRequest
 */
export interface CreateDomainAliasRequest {
    /**
     * Domain Alias
     * @type {string}
     * @memberof CreateDomainAliasRequest
     */
    alias: string;
    /**
     * Domain name this Alias applies to
     * @type {string}
     * @memberof CreateDomainAliasRequest
     */
    domain: string;
}
/**
 * 
 * @export
 * @interface CreateDomainAliasResponse
 */
export interface CreateDomainAliasResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof CreateDomainAliasResponse
     */
    success: boolean;
    /**
     * ID of the Domain Alias
     * @type {string}
     * @memberof CreateDomainAliasResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface CreateFilterRequest
 */
export interface CreateFilterRequest {
    /**
     * Name of the Filter
     * @type {string}
     * @memberof CreateFilterRequest
     */
    name?: string;
    /**
     * 
     * @type {Query}
     * @memberof CreateFilterRequest
     */
    query: Query;
    /**
     * 
     * @type {Action}
     * @memberof CreateFilterRequest
     */
    action: Action;
    /**
     * If true then this filter is ignored
     * @type {boolean}
     * @memberof CreateFilterRequest
     */
    disabled?: boolean;
    /**
     * Optional metadata, must be an object or JSON formatted string
     * @type {object | string}
     * @memberof CreateFilterRequest
     */
    metaData?: object | string;
}
/**
 * 
 * @export
 * @interface CreateForwardedAddressRequest
 */
export interface CreateForwardedAddressRequest {
    /**
     * E-mail Address
     * @type {string}
     * @memberof CreateForwardedAddressRequest
     */
    address: string;
    /**
     * Identity name
     * @type {string}
     * @memberof CreateForwardedAddressRequest
     */
    name?: string;
    /**
     * An array of forwarding targets. The value could either be an email address or a relay url to next MX server (\"smtp://mx2.zone.eu:25\") or an URL where mail contents are POSTed to
     * @type {Array<string>}
     * @memberof CreateForwardedAddressRequest
     */
    targets?: Array<string>;
    /**
     * Daily allowed forwarding count for this address
     * @type {number}
     * @memberof CreateForwardedAddressRequest
     */
    forwards?: number;
    /**
     * If true then address value can be in the form of `*@example.com`, otherwise using * is not allowed
     * @type {boolean}
     * @memberof CreateForwardedAddressRequest
     */
    allowWildcard?: boolean;
    /**
     * A list of tags associated with this address
     * @type {Array<string>}
     * @memberof CreateForwardedAddressRequest
     */
    tags?: Array<string>;
    /**
     * Optional metadata, must be an object or JSON formatted string
     * @type {object | string}
     * @memberof CreateForwardedAddressRequest
     */
    metaData?: object | string;
    /**
     * Optional metadata for internal use, must be an object or JSON formatted string of an object. Not available for user-role tokens
     * @type {object | string}
     * @memberof CreateForwardedAddressRequest
     */
    internalData?: object | string;
    /**
     * 
     * @type {Autoreply}
     * @memberof CreateForwardedAddressRequest
     */
    autoreply?: Autoreply;
}
/**
 * 
 * @export
 * @interface CreateForwardedAddressResponse
 */
export interface CreateForwardedAddressResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof CreateForwardedAddressResponse
     */
    success: boolean;
    /**
     * ID of the Address
     * @type {string}
     * @memberof CreateForwardedAddressResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface CreateMailboxRequest
 */
export interface CreateMailboxRequest {
    /**
     * Full path of the mailbox, folders are separated by slashes, ends with the mailbox name (unicode string)
     * @type {string}
     * @memberof CreateMailboxRequest
     */
    path: string;
    /**
     * Is the folder hidden or not. Hidden folders can not be opened in IMAP.
     * @type {boolean}
     * @memberof CreateMailboxRequest
     */
    hidden?: boolean;
    /**
     * Retention policy for the created Mailbox. Milliseconds after a message added to mailbox expires. Set to 0 to disable.
     * @type {number}
     * @memberof CreateMailboxRequest
     */
    retention?: number;
}
/**
 * 
 * @export
 * @interface CreateMailboxResponse
 */
export interface CreateMailboxResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof CreateMailboxResponse
     */
    success: boolean;
    /**
     * Mailbox ID
     * @type {string}
     * @memberof CreateMailboxResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface CreateSettingRequest
 */
export interface CreateSettingRequest {
    /**
     * Setting value
     * @type {string | number}
     * @memberof CreateSettingRequest
     */
    value: string | number;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof CreateSettingRequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof CreateSettingRequest
     */
    ip?: string;
}
/**
 * 
 * @export
 * @interface CreateSettingResponse
 */
export interface CreateSettingResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof CreateSettingResponse
     */
    success: boolean;
    /**
     * Key of the Setting
     * @type {string}
     * @memberof CreateSettingResponse
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface CreateUserAddressRequest
 */
export interface CreateUserAddressRequest {
    /**
     * E-mail Address
     * @type {string}
     * @memberof CreateUserAddressRequest
     */
    address: string;
    /**
     * Identity name
     * @type {string}
     * @memberof CreateUserAddressRequest
     */
    name?: string;
    /**
     * A list of tags associated with this address
     * @type {Array<string>}
     * @memberof CreateUserAddressRequest
     */
    tags?: Array<string>;
    /**
     * Indicates if this is the default address for the User
     * @type {boolean}
     * @memberof CreateUserAddressRequest
     */
    main?: boolean;
    /**
     * If true then address value can be in the form of `*@example.com`, `*suffix@example.com` and `username@*`, otherwise using * is not allowed. Static suffix can be up to 32 characters long.
     * @type {boolean}
     * @memberof CreateUserAddressRequest
     */
    allowWildcard?: boolean;
    /**
     * Optional metadata, must be an object or JSON formatted string
     * @type {object | string}
     * @memberof CreateUserAddressRequest
     */
    metaData?: object | string;
    /**
     * Optional metadata for internal use, must be an object or JSON formatted string of an object. Not available for user-role tokens
     * @type {object | string}
     * @memberof CreateUserAddressRequest
     */
    internalData?: object | string;
}
/**
 * 
 * @export
 * @interface CreateUserAddressResponse
 */
export interface CreateUserAddressResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof CreateUserAddressResponse
     */
    success: boolean;
    /**
     * ID of the Address
     * @type {string}
     * @memberof CreateUserAddressResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * Username of the User. Dots are allowed but informational only (\"user.name\" is the same as \"username\").
     * @type {string}
     * @memberof CreateUserRequest
     */
    username: string;
    /**
     * Name of the User
     * @type {string}
     * @memberof CreateUserRequest
     */
    name?: string;
    /**
     * Password for the account. Set to boolean false to disable password usage for the master scope, Application Specific Passwords would still be allowed
     * @type {string}
     * @memberof CreateUserRequest
     */
    password: string;
    /**
     * If true then password is already hashed, so store as is. Supported hashes: pbkdf2, bcrypt ($2a, $2y, $2b), md5 ($1), sha512 ($6), sha256 ($5), argon2 ($argon2d, $argon2i, $argon2id). Stored hashes are rehashed to pbkdf2 on first successful password check.
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    hashedPassword?: boolean;
    /**
     * If false then validates provided passwords against Have I Been Pwned API. Experimental, so validation is disabled by default but will be enabled automatically in some future version of WildDuck.
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    allowUnsafe?: boolean;
    /**
     * Default email address for the User (autogenerated if not set)
     * @type {string}
     * @memberof CreateUserRequest
     */
    address?: string;
    /**
     * If true then do not autogenerate missing email address for the User. Only needed if you want to create a user account that does not have any email address associated
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    emptyAddress?: boolean;
    /**
     * If true then requires the user to change password, useful if password for the account was autogenerated
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    requirePasswordChange?: boolean;
    /**
     * A list of tags associated with this user
     * @type {Array<string>}
     * @memberof CreateUserRequest
     */
    tags?: Array<string>;
    /**
     * If true then autogenerated address gets the same tags as the user
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    addTagsToAddress?: boolean;
    /**
     * Default retention time (in ms). Set to 0 to disable
     * @type {number}
     * @memberof CreateUserRequest
     */
    retention?: number;
    /**
     * If true then all messages sent through MSA are also uploaded to the Sent Mail folder. Might cause duplicates with some email clients, so disabled by default.
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    uploadSentMessages?: boolean;
    /**
     * If true then received messages are encrypted
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    encryptMessages?: boolean;
    /**
     * If true then forwarded messages are encrypted
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    encryptForwarded?: boolean;
    /**
     * Public PGP key for the User that is used for encryption. Use empty string to remove the key
     * @type {string}
     * @memberof CreateUserRequest
     */
    pubKey?: string;
    /**
     * Optional metadata, must be an object or JSON formatted string
     * @type {object | string}
     * @memberof CreateUserRequest
     */
    metaData?: object | string;
    /**
     * Optional metadata for internal use, must be an object or JSON formatted string of an object. Not available for user-role tokens
     * @type {object | string}
     * @memberof CreateUserRequest
     */
    internalData?: object | string;
    /**
     * Language code for the User
     * @type {string}
     * @memberof CreateUserRequest
     */
    language?: string;
    /**
     * An array of forwarding targets. The value could either be an email address or a relay url to next MX server (\"smtp://mx2.zone.eu:25\") or an URL where mail contents are POSTed to
     * @type {Array<string>}
     * @memberof CreateUserRequest
     */
    targets?: Array<string>;
    /**
     * Relative scale for detecting spam. 0 means that everything is spam, 100 means that nothing is spam
     * @type {number}
     * @memberof CreateUserRequest
     */
    spamLevel?: number;
    /**
     * Allowed quota of the user in bytes
     * @type {number}
     * @memberof CreateUserRequest
     */
    quota?: number;
    /**
     * How many messages per 24 hour can be sent
     * @type {number}
     * @memberof CreateUserRequest
     */
    recipients?: number;
    /**
     * How many messages per 24 hour can be forwarded
     * @type {number}
     * @memberof CreateUserRequest
     */
    forwards?: number;
    /**
     * How many filters are allowed for this account
     * @type {number}
     * @memberof CreateUserRequest
     */
    filters?: number;
    /**
     * How many bytes can be uploaded via IMAP during 24 hour
     * @type {number}
     * @memberof CreateUserRequest
     */
    imapMaxUpload?: number;
    /**
     * How many bytes can be downloaded via IMAP during 24 hour
     * @type {number}
     * @memberof CreateUserRequest
     */
    imapMaxDownload?: number;
    /**
     * How many bytes can be downloaded via POP3 during 24 hour
     * @type {number}
     * @memberof CreateUserRequest
     */
    pop3MaxDownload?: number;
    /**
     * How many latest messages to list in POP3 session
     * @type {number}
     * @memberof CreateUserRequest
     */
    pop3MaxMessages?: number;
    /**
     * How many parallel IMAP connections are alowed
     * @type {number}
     * @memberof CreateUserRequest
     */
    imapMaxConnections?: number;
    /**
     * How many messages can be received from MX during 60 seconds
     * @type {number}
     * @memberof CreateUserRequest
     */
    receivedMax?: number;
    /**
     * 
     * @type {Mailboxes}
     * @memberof CreateUserRequest
     */
    mailboxes?: Mailboxes;
    /**
     * List of scopes that are disabled for this user (\"imap\", \"pop3\", \"smtp\")
     * @type {Array<DisabledScopes>}
     * @memberof CreateUserRequest
     */
    disabledScopes?: Array<DisabledScopes>;
    /**
     * A list of additional email addresses this user can send mail from. Wildcard is allowed.
     * @type {Array<string>}
     * @memberof CreateUserRequest
     */
    fromWhitelist?: Array<string>;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof CreateUserRequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof CreateUserRequest
     */
    ip?: string;
}
/**
 * 
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof CreateUserResponse
     */
    success: boolean;
    /**
     * ID for the created User
     * @type {string}
     * @memberof CreateUserResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface CreateWebhookRequest
 */
export interface CreateWebhookRequest {
    /**
     * An array of event types to match. For prefix match use \".*\" at the end (eg. \"user.*\") or \"*\" for all types
     * @type {Array<string>}
     * @memberof CreateWebhookRequest
     */
    type: Array<string>;
    /**
     * User ID to match (only makes sense for user specific resources)
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    user?: string;
    /**
     * URL to POST data to
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    url: string;
}
/**
 * 
 * @export
 * @interface CreateWebhookResponse
 */
export interface CreateWebhookResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof CreateWebhookResponse
     */
    success: boolean;
    /**
     * ID of the Webhook
     * @type {string}
     * @memberof CreateWebhookResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface DeleteMessagesInMailboxResponse
 */
export interface DeleteMessagesInMailboxResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof DeleteMessagesInMailboxResponse
     */
    success: boolean;
    /**
     * Indicates count of deleted messages
     * @type {number}
     * @memberof DeleteMessagesInMailboxResponse
     */
    deleted: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DisabledScopes {
    Imap = 'imap',
    Pop3 = 'pop3',
    Smtp = 'smtp'
}

/**
 * Value for DNS TXT entry
 * @export
 * @interface DnsTxt
 */
export interface DnsTxt {
    /**
     * Is the domain name of TXT
     * @type {string}
     * @memberof DnsTxt
     */
    name: string;
    /**
     * Is the value of TXT
     * @type {string}
     * @memberof DnsTxt
     */
    value: string;
}
/**
 * 
 * @export
 * @interface EnableCustom2FARequest
 */
export interface EnableCustom2FARequest {
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof EnableCustom2FARequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof EnableCustom2FARequest
     */
    ip?: string;
}
/**
 * 
 * @export
 * @interface EnableTotp2FARequest
 */
export interface EnableTotp2FARequest {
    /**
     * 6-digit number that matches seed value from 2fa/totp/setup
     * @type {string}
     * @memberof EnableTotp2FARequest
     */
    token: string;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof EnableTotp2FARequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof EnableTotp2FARequest
     */
    ip?: string;
}
/**
 * SMTP envelope (if available)
 * @export
 * @interface Envelope
 */
export interface Envelope {
    /**
     * Address from MAIL FROM
     * @type {string}
     * @memberof Envelope
     */
    from: string;
    /**
     * 
     * @type {Rcpt}
     * @memberof Envelope
     */
    rcpt: Rcpt;
}
/**
 * SMTP envelope. If not provided then resolved either from message headers or from referenced message
 * @export
 * @interface EnvelopeUpload
 */
export interface EnvelopeUpload {
    /**
     * 
     * @type {AddressOptionalName}
     * @memberof EnvelopeUpload
     */
    from?: AddressOptionalName;
    /**
     * Recipients information
     * @type {Array<AddressOptionalName>}
     * @memberof EnvelopeUpload
     */
    to?: Array<AddressOptionalName>;
}
/**
 * List of files added to this message as attachments. Applies to Drafts, normal messages do not have this property. Needed to prevent uploading the same attachment every time a draft is updated
 * @export
 * @interface Files
 */
export interface Files {
    /**
     * File ID
     * @type {string}
     * @memberof Files
     */
    id: string;
    /**
     * Filename of the attached file
     * @type {string}
     * @memberof Files
     */
    filename: string;
    /**
     * MIME type
     * @type {string}
     * @memberof Files
     */
    contentType: string;
    /**
     * MIME type
     * @type {number}
     * @memberof Files
     */
    size: number;
}
/**
 * Sending quota
 * @export
 * @interface Filters
 */
export interface Filters {
    /**
     * How many filters are allowed
     * @type {number}
     * @memberof Filters
     */
    allowed: number;
    /**
     * How many filters have been created
     * @type {number}
     * @memberof Filters
     */
    used: number;
}
/**
 * 
 * @export
 * @interface ForwardStoredMessageRequest
 */
export interface ForwardStoredMessageRequest {
    /**
     * Number of original forwarding target
     * @type {number}
     * @memberof ForwardStoredMessageRequest
     */
    target?: number;
    /**
     * An array of additional forward targets
     * @type {Array<string>}
     * @memberof ForwardStoredMessageRequest
     */
    addresses?: Array<string>;
}
/**
 * 
 * @export
 * @interface ForwardStoredMessageResponse
 */
export interface ForwardStoredMessageResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof ForwardStoredMessageResponse
     */
    success: boolean;
    /**
     * Message ID in outbound queue
     * @type {string}
     * @memberof ForwardStoredMessageResponse
     */
    queueId: string;
    /**
     * Information about forwarding targets
     * @type {Array<Forwarded>}
     * @memberof ForwardStoredMessageResponse
     */
    forwarded: Array<Forwarded>;
}
/**
 * 
 * @export
 * @interface Forwarded
 */
export interface Forwarded {
    /**
     * Sequence ID
     * @type {string}
     * @memberof Forwarded
     */
    seq: string;
    /**
     * Target type
     * @type {string}
     * @memberof Forwarded
     */
    type: string;
    /**
     * Target address
     * @type {string}
     * @memberof Forwarded
     */
    value: string;
}
/**
 * Forwarding quota
 * @export
 * @interface Forwards
 */
export interface Forwards {
    /**
     * How many messages per 24 hours can be forwarded
     * @type {number}
     * @memberof Forwards
     */
    allowed: number;
    /**
     * How many messages are forwarded during current 24 hour period
     * @type {number}
     * @memberof Forwards
     */
    used: number;
    /**
     * Time until the end of current 24 hour period
     * @type {number}
     * @memberof Forwards
     */
    ttl: number;
}
/**
 * 
 * @export
 * @interface GetASPResponse
 */
export interface GetASPResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetASPResponse
     */
    success: boolean;
    /**
     * ID of the Application Password
     * @type {string}
     * @memberof GetASPResponse
     */
    id: string;
    /**
     * Description
     * @type {string}
     * @memberof GetASPResponse
     */
    description: string;
    /**
     * Allowed scopes for the Application Password
     * @type {Array<AspScopes>}
     * @memberof GetASPResponse
     */
    scopes: Array<AspScopes>;
    /**
     * 
     * @type {LastUse}
     * @memberof GetASPResponse
     */
    lastUse: LastUse;
    /**
     * Datestring
     * @type {string}
     * @memberof GetASPResponse
     */
    created: string;
}
/**
 * 
 * @export
 * @interface GetASPsResponse
 */
export interface GetASPsResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetASPsResponse
     */
    success: boolean;
    /**
     * Event listing
     * @type {Array<GetASPsResult>}
     * @memberof GetASPsResponse
     */
    results: Array<GetASPsResult>;
}
/**
 * 
 * @export
 * @interface GetASPsResult
 */
export interface GetASPsResult {
    /**
     * ID of the Application Password
     * @type {string}
     * @memberof GetASPsResult
     */
    id: string;
    /**
     * Description
     * @type {string}
     * @memberof GetASPsResult
     */
    description: string;
    /**
     * Allowed scopes for the Application Password
     * @type {Array<AspScopes>}
     * @memberof GetASPsResult
     */
    scopes: Array<AspScopes>;
    /**
     * 
     * @type {LastUse}
     * @memberof GetASPsResult
     */
    lastUse: LastUse;
    /**
     * Datestring
     * @type {string}
     * @memberof GetASPsResult
     */
    created: string;
}
/**
 * 
 * @export
 * @interface GetAddressesResponse
 */
export interface GetAddressesResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetAddressesResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof GetAddressesResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof GetAddressesResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof GetAddressesResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof GetAddressesResponse
     */
    nextCursor: string;
    /**
     * Address listing
     * @type {Array<GetAddressesResult>}
     * @memberof GetAddressesResponse
     */
    results: Array<GetAddressesResult>;
}
/**
 * 
 * @export
 * @interface GetAddressesResult
 */
export interface GetAddressesResult {
    /**
     * ID of the Address
     * @type {string}
     * @memberof GetAddressesResult
     */
    id: string;
    /**
     * Identity name
     * @type {string}
     * @memberof GetAddressesResult
     */
    name: string;
    /**
     * E-mail address string
     * @type {string}
     * @memberof GetAddressesResult
     */
    address: string;
    /**
     * User ID this address belongs to if this is a User address
     * @type {string}
     * @memberof GetAddressesResult
     */
    user: string;
    /**
     * If true then it is a forwarded address
     * @type {boolean}
     * @memberof GetAddressesResult
     */
    forwarded: boolean;
    /**
     * If true then the forwarded address is disabled
     * @type {boolean}
     * @memberof GetAddressesResult
     */
    forwardedDisabled: boolean;
    /**
     * List of forwarding targets
     * @type {Array<string>}
     * @memberof GetAddressesResult
     */
    target?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetAllFiltersResponse
 */
export interface GetAllFiltersResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetAllFiltersResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof GetAllFiltersResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof GetAllFiltersResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof GetAllFiltersResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof GetAllFiltersResponse
     */
    nextCursor: string;
    /**
     * Address listing
     * @type {Array<GetAllFiltersResult>}
     * @memberof GetAllFiltersResponse
     */
    results: Array<GetAllFiltersResult>;
}
/**
 * 
 * @export
 * @interface GetAllFiltersResult
 */
export interface GetAllFiltersResult {
    /**
     * Filter ID
     * @type {string}
     * @memberof GetAllFiltersResult
     */
    id: string;
    /**
     * User ID
     * @type {string}
     * @memberof GetAllFiltersResult
     */
    user: string;
    /**
     * Name for the filter
     * @type {string}
     * @memberof GetAllFiltersResult
     */
    name: string;
    /**
     * Datestring of the time the filter was created
     * @type {string}
     * @memberof GetAllFiltersResult
     */
    created: string;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof GetAllFiltersResult
     */
    query: Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof GetAllFiltersResult
     */
    action: Array<Array<string>>;
    /**
     * If true, then this filter is ignored
     * @type {boolean}
     * @memberof GetAllFiltersResult
     */
    disabled: boolean;
    /**
     * Custom metadata value. Included if metaData query argument was true
     * @type {object}
     * @memberof GetAllFiltersResult
     */
    metaData?: object;
    /**
     * List of forwarding targets
     * @type {Array<string>}
     * @memberof GetAllFiltersResult
     */
    targets?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetAllowedDomainResponse
 */
export interface GetAllowedDomainResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetAllowedDomainResponse
     */
    success: boolean;
    /**
     * Domain list
     * @type {Array<GetAllowedDomainResult>}
     * @memberof GetAllowedDomainResponse
     */
    results: Array<GetAllowedDomainResult>;
}
/**
 * 
 * @export
 * @interface GetAllowedDomainResult
 */
export interface GetAllowedDomainResult {
    /**
     * Entry ID
     * @type {string}
     * @memberof GetAllowedDomainResult
     */
    id: string;
    /**
     * allowlisted domain name
     * @type {string}
     * @memberof GetAllowedDomainResult
     */
    domain: string;
}
/**
 * 
 * @export
 * @interface GetArchivedMessagesResponse
 */
export interface GetArchivedMessagesResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetArchivedMessagesResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof GetArchivedMessagesResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof GetArchivedMessagesResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof GetArchivedMessagesResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof GetArchivedMessagesResponse
     */
    nextCursor: string;
    /**
     * Message listing
     * @type {Array<GetArchivedMessagesResult>}
     * @memberof GetArchivedMessagesResponse
     */
    results: Array<GetArchivedMessagesResult>;
}
/**
 * 
 * @export
 * @interface GetArchivedMessagesResult
 */
export interface GetArchivedMessagesResult {
    /**
     * ID of the Message (24 byte hex)
     * @type {string}
     * @memberof GetArchivedMessagesResult
     */
    id: string;
    /**
     * ID of the Mailbox
     * @type {string}
     * @memberof GetArchivedMessagesResult
     */
    mailbox: string;
    /**
     * ID of the Thread
     * @type {string}
     * @memberof GetArchivedMessagesResult
     */
    thread: string;
    /**
     * 
     * @type {Address}
     * @memberof GetArchivedMessagesResult
     */
    from: Address;
    /**
     * Recipients in To: field
     * @type {Array<Address>}
     * @memberof GetArchivedMessagesResult
     */
    to: Array<Address>;
    /**
     * Recipients in Cc: field
     * @type {Array<Address>}
     * @memberof GetArchivedMessagesResult
     */
    cc: Array<Address>;
    /**
     * Recipients in Bcc: field. Usually only available for drafts
     * @type {Array<Address>}
     * @memberof GetArchivedMessagesResult
     */
    bcc: Array<Address>;
    /**
     * Message subject
     * @type {string}
     * @memberof GetArchivedMessagesResult
     */
    subject: string;
    /**
     * Date string from header
     * @type {string}
     * @memberof GetArchivedMessagesResult
     */
    date: string;
    /**
     * Date string of receive time
     * @type {string}
     * @memberof GetArchivedMessagesResult
     */
    idate?: string;
    /**
     * First 128 bytes of the message
     * @type {string}
     * @memberof GetArchivedMessagesResult
     */
    intro: string;
    /**
     * Does the message have attachments
     * @type {boolean}
     * @memberof GetArchivedMessagesResult
     */
    attachments: boolean;
    /**
     * Is this message alread seen or not
     * @type {boolean}
     * @memberof GetArchivedMessagesResult
     */
    seen: boolean;
    /**
     * Does this message have a \\Deleted flag (should not have as messages are automatically deleted once this flag is set)
     * @type {boolean}
     * @memberof GetArchivedMessagesResult
     */
    deleted: boolean;
    /**
     * Does this message have a \\Flagged flag
     * @type {boolean}
     * @memberof GetArchivedMessagesResult
     */
    flagged: boolean;
    /**
     * 
     * @type {ContentType}
     * @memberof GetArchivedMessagesResult
     */
    contentType: ContentType;
}
/**
 * 
 * @export
 * @interface GetAuditResponse
 */
export interface GetAuditResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetAuditResponse
     */
    success: boolean;
    /**
     * Users unique ID.
     * @type {string}
     * @memberof GetAuditResponse
     */
    user: string;
    /**
     * Start time as ISO date
     * @type {string}
     * @memberof GetAuditResponse
     */
    start?: string;
    /**
     * End time as ISO date
     * @type {string}
     * @memberof GetAuditResponse
     */
    end?: string;
    /**
     * Expiration date. Audit data is deleted after this date
     * @type {string}
     * @memberof GetAuditResponse
     */
    expires: string;
}
/**
 * 
 * @export
 * @interface GetAuthlogEventResponse
 */
export interface GetAuthlogEventResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetAuthlogEventResponse
     */
    success: boolean;
    /**
     * ID of the Event
     * @type {string}
     * @memberof GetAuthlogEventResponse
     */
    id: string;
    /**
     * Action identifier
     * @type {string}
     * @memberof GetAuthlogEventResponse
     */
    action: string;
    /**
     * Did the action succeed
     * @type {string}
     * @memberof GetAuthlogEventResponse
     */
    result: string;
    /**
     * Session identifier
     * @type {string}
     * @memberof GetAuthlogEventResponse
     */
    sess?: string;
    /**
     * IP address of the Event
     * @type {string}
     * @memberof GetAuthlogEventResponse
     */
    ip?: string;
    /**
     * Datestring of the Event time
     * @type {string}
     * @memberof GetAuthlogEventResponse
     */
    created: string;
}
/**
 * 
 * @export
 * @interface GetAuthlogResponse
 */
export interface GetAuthlogResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetAuthlogResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof GetAuthlogResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof GetAuthlogResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof GetAuthlogResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof GetAuthlogResponse
     */
    nextCursor: string;
    /**
     * Event listing
     * @type {Array<GetAuthlogResult>}
     * @memberof GetAuthlogResponse
     */
    results: Array<GetAuthlogResult>;
}
/**
 * 
 * @export
 * @interface GetAuthlogResult
 */
export interface GetAuthlogResult {
    /**
     * ID of the Event
     * @type {string}
     * @memberof GetAuthlogResult
     */
    id: string;
    /**
     * Action identifier
     * @type {string}
     * @memberof GetAuthlogResult
     */
    action: string;
    /**
     * Did the action succeed
     * @type {string}
     * @memberof GetAuthlogResult
     */
    result: string;
    /**
     * Session identifier
     * @type {string}
     * @memberof GetAuthlogResult
     */
    sess?: string;
    /**
     * IP address of the Event
     * @type {string}
     * @memberof GetAuthlogResult
     */
    ip?: string;
    /**
     * Datestring of the Event time
     * @type {string}
     * @memberof GetAuthlogResult
     */
    created: string;
}
/**
 * 
 * @export
 * @interface GetAutoreplyResponse
 */
export interface GetAutoreplyResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetAutoreplyResponse
     */
    success: boolean;
    /**
     * Is the autoreply enabled (true) or not (false)
     * @type {boolean}
     * @memberof GetAutoreplyResponse
     */
    status: boolean;
    /**
     * Name that is used for the From: header in autoreply message
     * @type {string}
     * @memberof GetAutoreplyResponse
     */
    name: string;
    /**
     * Subject line for the autoreply. If empty then uses subject of the original message
     * @type {string}
     * @memberof GetAutoreplyResponse
     */
    subject: string;
    /**
     * HTML formatted content of the autoreply message
     * @type {string}
     * @memberof GetAutoreplyResponse
     */
    html: string;
    /**
     * Plaintext formatted content of the autoreply message
     * @type {string}
     * @memberof GetAutoreplyResponse
     */
    text: string;
    /**
     * Datestring of the start of the autoreply
     * @type {string}
     * @memberof GetAutoreplyResponse
     */
    start: string;
    /**
     * Datestring of the end of the autoreply
     * @type {string}
     * @memberof GetAutoreplyResponse
     */
    end: string;
}
/**
 * 
 * @export
 * @interface GetBlockedDomainResponse
 */
export interface GetBlockedDomainResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetBlockedDomainResponse
     */
    success: boolean;
    /**
     * Domain list
     * @type {Array<GetBlockedDomainResult>}
     * @memberof GetBlockedDomainResponse
     */
    results: Array<GetBlockedDomainResult>;
}
/**
 * 
 * @export
 * @interface GetBlockedDomainResult
 */
export interface GetBlockedDomainResult {
    /**
     * Entry ID
     * @type {string}
     * @memberof GetBlockedDomainResult
     */
    id: string;
    /**
     * blocklisted domain name
     * @type {string}
     * @memberof GetBlockedDomainResult
     */
    domain: string;
}
/**
 * 
 * @export
 * @interface GetDkimKeyResponse
 */
export interface GetDkimKeyResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetDkimKeyResponse
     */
    success: boolean;
    /**
     * ID of the DKIM
     * @type {string}
     * @memberof GetDkimKeyResponse
     */
    id: string;
    /**
     * The domain this DKIM key applies to
     * @type {string}
     * @memberof GetDkimKeyResponse
     */
    domain: string;
    /**
     * DKIM selector
     * @type {string}
     * @memberof GetDkimKeyResponse
     */
    selector: string;
    /**
     * Key description
     * @type {string}
     * @memberof GetDkimKeyResponse
     */
    description: string;
    /**
     * Key fingerprint (SHA1)
     * @type {string}
     * @memberof GetDkimKeyResponse
     */
    fingerprint: string;
    /**
     * Public key in DNS format (no prefix/suffix, single line)
     * @type {string}
     * @memberof GetDkimKeyResponse
     */
    publicKey: string;
    /**
     * 
     * @type {DnsTxt}
     * @memberof GetDkimKeyResponse
     */
    dnsTxt: DnsTxt;
    /**
     * Datestring
     * @type {string}
     * @memberof GetDkimKeyResponse
     */
    created: string;
}
/**
 * 
 * @export
 * @interface GetDkimKeysResponse
 */
export interface GetDkimKeysResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetDkimKeysResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof GetDkimKeysResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof GetDkimKeysResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof GetDkimKeysResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof GetDkimKeysResponse
     */
    nextCursor: string;
    /**
     * DKIM listing
     * @type {Array<GetDkimKeysResult>}
     * @memberof GetDkimKeysResponse
     */
    results: Array<GetDkimKeysResult>;
}
/**
 * 
 * @export
 * @interface GetDkimKeysResult
 */
export interface GetDkimKeysResult {
    /**
     * ID of the DKIM
     * @type {string}
     * @memberof GetDkimKeysResult
     */
    id: string;
    /**
     * The domain this DKIM key applies to
     * @type {string}
     * @memberof GetDkimKeysResult
     */
    domain: string;
    /**
     * DKIM selector
     * @type {string}
     * @memberof GetDkimKeysResult
     */
    selector: string;
    /**
     * Key description
     * @type {string}
     * @memberof GetDkimKeysResult
     */
    description: string;
    /**
     * Key fingerprint (SHA1)
     * @type {string}
     * @memberof GetDkimKeysResult
     */
    fingerprint: string;
    /**
     * Datestring
     * @type {string}
     * @memberof GetDkimKeysResult
     */
    created: string;
}
/**
 * 
 * @export
 * @interface GetDomainAliasResponse
 */
export interface GetDomainAliasResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetDomainAliasResponse
     */
    success: boolean;
    /**
     * ID of the Alias
     * @type {string}
     * @memberof GetDomainAliasResponse
     */
    id: string;
    /**
     * Alias domain
     * @type {string}
     * @memberof GetDomainAliasResponse
     */
    alias: string;
    /**
     * Alias target
     * @type {string}
     * @memberof GetDomainAliasResponse
     */
    domain: string;
    /**
     * Datestring of the time the alias was created
     * @type {string}
     * @memberof GetDomainAliasResponse
     */
    created: string;
}
/**
 * 
 * @export
 * @interface GetDomainAliasesResponse
 */
export interface GetDomainAliasesResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetDomainAliasesResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof GetDomainAliasesResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof GetDomainAliasesResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof GetDomainAliasesResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof GetDomainAliasesResponse
     */
    nextCursor: string;
    /**
     * Aliases listing
     * @type {Array<GetDomainAliasesResult>}
     * @memberof GetDomainAliasesResponse
     */
    results: Array<GetDomainAliasesResult>;
}
/**
 * 
 * @export
 * @interface GetDomainAliasesResult
 */
export interface GetDomainAliasesResult {
    /**
     * ID of the Domain Alias
     * @type {string}
     * @memberof GetDomainAliasesResult
     */
    id: string;
    /**
     * Domain Alias
     * @type {string}
     * @memberof GetDomainAliasesResult
     */
    alias: string;
    /**
     * The domain this alias applies to
     * @type {string}
     * @memberof GetDomainAliasesResult
     */
    domain: string;
}
/**
 * 
 * @export
 * @interface GetFilesResponse
 */
export interface GetFilesResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetFilesResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof GetFilesResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof GetFilesResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof GetFilesResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof GetFilesResponse
     */
    nextCursor: string;
    /**
     * File listing
     * @type {Array<GetFilesResult>}
     * @memberof GetFilesResponse
     */
    results: Array<GetFilesResult>;
}
/**
 * 
 * @export
 * @interface GetFilesResult
 */
export interface GetFilesResult {
    /**
     * ID of the File
     * @type {string}
     * @memberof GetFilesResult
     */
    id: string;
    /**
     * Filename
     * @type {string}
     * @memberof GetFilesResult
     */
    filename: string;
    /**
     * Content-Type of the file
     * @type {string}
     * @memberof GetFilesResult
     */
    contentType: string;
    /**
     * File size
     * @type {number}
     * @memberof GetFilesResult
     */
    size: number;
}
/**
 * 
 * @export
 * @interface GetFilterResponse
 */
export interface GetFilterResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetFilterResponse
     */
    success: boolean;
    /**
     * ID for the Filter
     * @type {string}
     * @memberof GetFilterResponse
     */
    id: string;
    /**
     * Name of the Filter
     * @type {string}
     * @memberof GetFilterResponse
     */
    name: string;
    /**
     * 
     * @type {Query}
     * @memberof GetFilterResponse
     */
    query: Query;
    /**
     * 
     * @type {Action}
     * @memberof GetFilterResponse
     */
    action: Action;
    /**
     * If true, then this filter is ignored
     * @type {boolean}
     * @memberof GetFilterResponse
     */
    disabled: boolean;
    /**
     * Custom metadata value
     * @type {object}
     * @memberof GetFilterResponse
     */
    metaData?: object;
}
/**
 * 
 * @export
 * @interface GetFiltersResponse
 */
export interface GetFiltersResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetFiltersResponse
     */
    success: boolean;
    /**
     * 
     * @type {GetFiltersResponseLimits}
     * @memberof GetFiltersResponse
     */
    limits: GetFiltersResponseLimits;
    /**
     * Filter description
     * @type {Array<GetFiltersResult>}
     * @memberof GetFiltersResponse
     */
    results: Array<GetFiltersResult>;
}
/**
 * Filter usage limits for the user account
 * @export
 * @interface GetFiltersResponseLimits
 */
export interface GetFiltersResponseLimits {
    /**
     * How many filters are allowed
     * @type {number}
     * @memberof GetFiltersResponseLimits
     */
    allowed?: number;
    /**
     * How many filters have been created
     * @type {number}
     * @memberof GetFiltersResponseLimits
     */
    used?: number;
}
/**
 * 
 * @export
 * @interface GetFiltersResult
 */
export interface GetFiltersResult {
    /**
     * Filter ID
     * @type {string}
     * @memberof GetFiltersResult
     */
    id: string;
    /**
     * Name for the filter
     * @type {string}
     * @memberof GetFiltersResult
     */
    name: string;
    /**
     * Datestring of the time the filter was created
     * @type {string}
     * @memberof GetFiltersResult
     */
    created: string;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof GetFiltersResult
     */
    query: Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof GetFiltersResult
     */
    action: Array<Array<string>>;
    /**
     * Custom metadata value. Included if metaData query argument was true
     * @type {object}
     * @memberof GetFiltersResult
     */
    metaData?: object;
    /**
     * If true, then this filter is ignored
     * @type {boolean}
     * @memberof GetFiltersResult
     */
    disabled: boolean;
}
/**
 * 
 * @export
 * @interface GetForwardedAddressResponse
 */
export interface GetForwardedAddressResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetForwardedAddressResponse
     */
    success: boolean;
    /**
     * ID of the Address
     * @type {string}
     * @memberof GetForwardedAddressResponse
     */
    id: string;
    /**
     * E-mail address string
     * @type {string}
     * @memberof GetForwardedAddressResponse
     */
    address: string;
    /**
     * Identity name
     * @type {string}
     * @memberof GetForwardedAddressResponse
     */
    name: string;
    /**
     * List of forwarding targets
     * @type {Array<string>}
     * @memberof GetForwardedAddressResponse
     */
    targets: Array<string>;
    /**
     * 
     * @type {AddressLimits}
     * @memberof GetForwardedAddressResponse
     */
    limits: AddressLimits;
    /**
     * 
     * @type {AutoreplyInfo}
     * @memberof GetForwardedAddressResponse
     */
    autoreply: AutoreplyInfo;
    /**
     * Datestring of the time the address was created
     * @type {string}
     * @memberof GetForwardedAddressResponse
     */
    created: string;
    /**
     * List of tags associated with the Address
     * @type {Array<string>}
     * @memberof GetForwardedAddressResponse
     */
    tags: Array<string>;
    /**
     * If true then the forwarded address is disabled
     * @type {boolean}
     * @memberof GetForwardedAddressResponse
     */
    forwardedDisabled: boolean;
}
/**
 * 
 * @export
 * @interface GetMailboxResponse
 */
export interface GetMailboxResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetMailboxResponse
     */
    success: boolean;
    /**
     * Mailbox ID
     * @type {string}
     * @memberof GetMailboxResponse
     */
    id: string;
    /**
     * Name for the mailbox (unicode string)
     * @type {string}
     * @memberof GetMailboxResponse
     */
    name: string;
    /**
     * Full path of the mailbox, folders are separated by slashes, ends with the mailbox name (unicode string)
     * @type {string}
     * @memberof GetMailboxResponse
     */
    path: string;
    /**
     * 
     * @type {SpecialUse}
     * @memberof GetMailboxResponse
     */
    specialUse: SpecialUse;
    /**
     * Modification sequence number. Incremented on every change in the mailbox.
     * @type {number}
     * @memberof GetMailboxResponse
     */
    modifyIndex: number;
    /**
     * Mailbox subscription status. IMAP clients may unsubscribe from a folder.
     * @type {boolean}
     * @memberof GetMailboxResponse
     */
    subscribed: boolean;
    /**
     * Is the folder hidden or not
     * @type {boolean}
     * @memberof GetMailboxResponse
     */
    hidden: boolean;
    /**
     * How many messages are stored in this mailbox
     * @type {number}
     * @memberof GetMailboxResponse
     */
    total: number;
    /**
     * How many unseen messages are stored in this mailbox
     * @type {number}
     * @memberof GetMailboxResponse
     */
    unseen: number;
}
/**
 * 
 * @export
 * @interface GetMailboxesResponse
 */
export interface GetMailboxesResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetMailboxesResponse
     */
    success: boolean;
    /**
     * List of user mailboxes
     * @type {Array<GetMailboxesResult>}
     * @memberof GetMailboxesResponse
     */
    results: Array<GetMailboxesResult>;
}
/**
 * 
 * @export
 * @interface GetMailboxesResult
 */
export interface GetMailboxesResult {
    /**
     * Mailbox ID
     * @type {string}
     * @memberof GetMailboxesResult
     */
    id: string;
    /**
     * Name for the mailbox (unicode string)
     * @type {string}
     * @memberof GetMailboxesResult
     */
    name: string;
    /**
     * Full path of the mailbox, folders are separated by slashes, ends with the mailbox name (unicode string)
     * @type {string}
     * @memberof GetMailboxesResult
     */
    path: string;
    /**
     * Either special use identifier or null. One of \\Drafts, \\Junk, \\Sent or \\Trash
     * @type {string}
     * @memberof GetMailboxesResult
     */
    specialUse: string;
    /**
     * Modification sequence number. Incremented on every change in the mailbox.
     * @type {number}
     * @memberof GetMailboxesResult
     */
    modifyIndex: number;
    /**
     * Mailbox subscription status. IMAP clients may unsubscribe from a folder.
     * @type {boolean}
     * @memberof GetMailboxesResult
     */
    subscribed: boolean;
    /**
     * Default retention policy for this mailbox (in ms). If set then messages added to this maibox will be automatically deleted after retention time.
     * @type {number}
     * @memberof GetMailboxesResult
     */
    retention?: number;
    /**
     * Is the folder hidden or not
     * @type {boolean}
     * @memberof GetMailboxesResult
     */
    hidden: boolean;
    /**
     * How many messages are stored in this mailbox
     * @type {number}
     * @memberof GetMailboxesResult
     */
    total: number;
    /**
     * How many unseen messages are stored in this mailbox
     * @type {number}
     * @memberof GetMailboxesResult
     */
    unseen: number;
}
/**
 * 
 * @export
 * @interface GetMessageResponse
 */
export interface GetMessageResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetMessageResponse
     */
    success: boolean;
    /**
     * ID of the Message
     * @type {number}
     * @memberof GetMessageResponse
     */
    id: number;
    /**
     * ID of the Mailbox
     * @type {string}
     * @memberof GetMessageResponse
     */
    mailbox: string;
    /**
     * ID of the User
     * @type {string}
     * @memberof GetMessageResponse
     */
    user: string;
    /**
     * 
     * @type {Envelope}
     * @memberof GetMessageResponse
     */
    envelope: Envelope;
    /**
     * ID of the Thread
     * @type {string}
     * @memberof GetMessageResponse
     */
    thread: string;
    /**
     * 
     * @type {Address}
     * @memberof GetMessageResponse
     */
    from: Address;
    /**
     * 
     * @type {Address}
     * @memberof GetMessageResponse
     */
    to?: Address;
    /**
     * 
     * @type {Address}
     * @memberof GetMessageResponse
     */
    cc?: Address;
    /**
     * 
     * @type {Address}
     * @memberof GetMessageResponse
     */
    bcc?: Address;
    /**
     * Message subject
     * @type {string}
     * @memberof GetMessageResponse
     */
    subject: string;
    /**
     * Message-ID header
     * @type {string}
     * @memberof GetMessageResponse
     */
    messageId: string;
    /**
     * Date string from header
     * @type {string}
     * @memberof GetMessageResponse
     */
    date: string;
    /**
     * Date string of receive time
     * @type {string}
     * @memberof GetMessageResponse
     */
    idate?: string;
    /**
     * 
     * @type {List}
     * @memberof GetMessageResponse
     */
    list?: List;
    /**
     * Datestring, if set then indicates the time after this message is automatically deleted
     * @type {string}
     * @memberof GetMessageResponse
     */
    expires?: string;
    /**
     * Does this message have a \\Seen flag
     * @type {boolean}
     * @memberof GetMessageResponse
     */
    seen: boolean;
    /**
     * Does this message have a \\Deleted flag
     * @type {boolean}
     * @memberof GetMessageResponse
     */
    deleted: boolean;
    /**
     * Does this message have a \\Flagged flag
     * @type {boolean}
     * @memberof GetMessageResponse
     */
    flagged: boolean;
    /**
     * Does this message have a \\Draft flag
     * @type {boolean}
     * @memberof GetMessageResponse
     */
    draft: boolean;
    /**
     * An array of HTML string. Every array element is from a separate mime node, usually you would just join these to a single string
     * @type {Array<string>}
     * @memberof GetMessageResponse
     */
    html?: Array<string>;
    /**
     * Plaintext content of the message
     * @type {string}
     * @memberof GetMessageResponse
     */
    text?: string;
    /**
     * Attachments for the message
     * @type {Array<Attachments>}
     * @memberof GetMessageResponse
     */
    attachments?: Array<Attachments>;
    /**
     * 
     * @type {VerificationResults}
     * @memberof GetMessageResponse
     */
    verificationResults?: VerificationResults;
    /**
     * 
     * @type {GetMessageResponseBimi}
     * @memberof GetMessageResponse
     */
    bimi?: GetMessageResponseBimi;
    /**
     * 
     * @type {ContentType}
     * @memberof GetMessageResponse
     */
    contentType: ContentType;
    /**
     * Custom metadata object set for this message
     * @type {object}
     * @memberof GetMessageResponse
     */
    metaData?: object;
    /**
     * Referenced message info
     * @type {object}
     * @memberof GetMessageResponse
     */
    reference?: object;
    /**
     * 
     * @type {Files}
     * @memberof GetMessageResponse
     */
    files?: Files;
    /**
     * Outbound queue entries
     * @type {Array<Outbound>}
     * @memberof GetMessageResponse
     */
    outbound?: Array<Outbound>;
}
/**
 * BIMI logo info. If logo validation failed in any way, then this property is not set
 * @export
 * @interface GetMessageResponseBimi
 */
export interface GetMessageResponseBimi {
    /**
     * If true, then this logo is from a VMC file
     * @type {boolean}
     * @memberof GetMessageResponseBimi
     */
    certified?: boolean;
    /**
     * URL of the resource the logo was retrieved from
     * @type {string}
     * @memberof GetMessageResponseBimi
     */
    url?: string;
    /**
     * Data URL for the SVG image
     * @type {string}
     * @memberof GetMessageResponseBimi
     */
    image?: string;
}
/**
 * 
 * @export
 * @interface GetMessagesResponse
 */
export interface GetMessagesResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetMessagesResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof GetMessagesResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof GetMessagesResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof GetMessagesResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof GetMessagesResponse
     */
    nextCursor: string;
    /**
     * Message listing
     * @type {Array<GetMessagesResult>}
     * @memberof GetMessagesResponse
     */
    results: Array<GetMessagesResult>;
}
/**
 * 
 * @export
 * @interface GetMessagesResult
 */
export interface GetMessagesResult {
    /**
     * ID of the Message
     * @type {number}
     * @memberof GetMessagesResult
     */
    id: number;
    /**
     * ID of the Mailbox
     * @type {string}
     * @memberof GetMessagesResult
     */
    mailbox: string;
    /**
     * ID of the Thread
     * @type {string}
     * @memberof GetMessagesResult
     */
    thread: string;
    /**
     * Amount of messages in the Thread. Included if threadCounters query argument was true
     * @type {number}
     * @memberof GetMessagesResult
     */
    threadMessageCount?: number;
    /**
     * 
     * @type {Address}
     * @memberof GetMessagesResult
     */
    from: Address;
    /**
     * Recipients in To: field
     * @type {Array<Address>}
     * @memberof GetMessagesResult
     */
    to: Array<Address>;
    /**
     * Recipients in Cc: field
     * @type {Array<Address>}
     * @memberof GetMessagesResult
     */
    cc: Array<Address>;
    /**
     * Recipients in Bcc: field. Usually only available for drafts
     * @type {Array<Address>}
     * @memberof GetMessagesResult
     */
    bcc: Array<Address>;
    /**
     * Message subject
     * @type {string}
     * @memberof GetMessagesResult
     */
    subject: string;
    /**
     * Date string from header
     * @type {string}
     * @memberof GetMessagesResult
     */
    date: string;
    /**
     * Date string of receive time
     * @type {string}
     * @memberof GetMessagesResult
     */
    idate?: string;
    /**
     * Message size in bytes
     * @type {number}
     * @memberof GetMessagesResult
     */
    size: number;
    /**
     * First 128 bytes of the message
     * @type {string}
     * @memberof GetMessagesResult
     */
    intro: string;
    /**
     * Does the message have attachments
     * @type {boolean}
     * @memberof GetMessagesResult
     */
    attachments: boolean;
    /**
     * Is this message alread seen or not
     * @type {boolean}
     * @memberof GetMessagesResult
     */
    seen: boolean;
    /**
     * Does this message have a \\Deleted flag (should not have as messages are automatically deleted once this flag is set)
     * @type {boolean}
     * @memberof GetMessagesResult
     */
    deleted: boolean;
    /**
     * Does this message have a \\Flagged flag
     * @type {boolean}
     * @memberof GetMessagesResult
     */
    flagged: boolean;
    /**
     * Does this message have a \\Answered flag
     * @type {boolean}
     * @memberof GetMessagesResult
     */
    answered: boolean;
    /**
     * Does this message have a $Forwarded flag
     * @type {boolean}
     * @memberof GetMessagesResult
     */
    forwarded: boolean;
    /**
     * 
     * @type {ContentType}
     * @memberof GetMessagesResult
     */
    contentType: ContentType;
    /**
     * Custom metadata value. Included if metaData query argument was true
     * @type {object}
     * @memberof GetMessagesResult
     */
    metaData?: object;
    /**
     * Header object keys requested with the includeHeaders argument
     * @type {object}
     * @memberof GetMessagesResult
     */
    headers?: object;
}
/**
 * 
 * @export
 * @interface GetSettingResponse
 */
export interface GetSettingResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetSettingResponse
     */
    success: boolean;
    /**
     * Key of the Setting
     * @type {string}
     * @memberof GetSettingResponse
     */
    key?: string;
    /**
     * Setting value
     * @type {string | number}
     * @memberof GetSettingResponse
     */
    value?: string | number;
}
/**
 * 
 * @export
 * @interface GetSettingsResponse
 */
export interface GetSettingsResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetSettingsResponse
     */
    success: boolean;
    /**
     * Partial match if requested
     * @type {string}
     * @memberof GetSettingsResponse
     */
    filter?: string;
    /**
     * Setting listing
     * @type {Array<GetSettingsResult>}
     * @memberof GetSettingsResponse
     */
    settings: Array<GetSettingsResult>;
}
/**
 * 
 * @export
 * @interface GetSettingsResult
 */
export interface GetSettingsResult {
    /**
     * Setting key
     * @type {string}
     * @memberof GetSettingsResult
     */
    key: string;
    /**
     * Setting value
     * @type {string | number}
     * @memberof GetSettingsResult
     */
    value?: string | number;
    /**
     * Setting name
     * @type {string}
     * @memberof GetSettingsResult
     */
    name?: string;
    /**
     * Setting description
     * @type {string}
     * @memberof GetSettingsResult
     */
    description?: string;
    /**
     * Default value for this key
     * @type {string | number}
     * @memberof GetSettingsResult
     */
    _default?: string | number;
    /**
     * Value subtype
     * @type {string}
     * @memberof GetSettingsResult
     */
    type?: string;
    /**
     * If true then the value is set
     * @type {boolean}
     * @memberof GetSettingsResult
     */
    custom?: boolean;
}
/**
 * 
 * @export
 * @interface GetTLSCertResult
 */
export interface GetTLSCertResult {
    /**
     * ID of the certificate
     * @type {string}
     * @memberof GetTLSCertResult
     */
    id: string;
    /**
     * The server name this certificate applies to
     * @type {string}
     * @memberof GetTLSCertResult
     */
    servername: string;
    /**
     * If true then private key and certificate are managed automatically by ACME
     * @type {boolean}
     * @memberof GetTLSCertResult
     */
    acme?: boolean;
    /**
     * Key description
     * @type {string}
     * @memberof GetTLSCertResult
     */
    description: string;
    /**
     * Key fingerprint (SHA1)
     * @type {string}
     * @memberof GetTLSCertResult
     */
    fingerprint: string;
    /**
     * Datestring
     * @type {string}
     * @memberof GetTLSCertResult
     */
    created: string;
    /**
     * Certificate expiration time
     * @type {string}
     * @memberof GetTLSCertResult
     */
    expires?: string;
    /**
     * SAN servernames listed in the certificate
     * @type {Array<string>}
     * @memberof GetTLSCertResult
     */
    altNames?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetTLSCertsResponse
 */
export interface GetTLSCertsResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetTLSCertsResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof GetTLSCertsResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof GetTLSCertsResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof GetTLSCertsResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof GetTLSCertsResponse
     */
    nextCursor: string;
    /**
     * Certificate listing
     * @type {Array<GetTLSCertResult>}
     * @memberof GetTLSCertsResponse
     */
    results: Array<GetTLSCertResult>;
}
/**
 * 
 * @export
 * @interface GetUserAddressResponse
 */
export interface GetUserAddressResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetUserAddressResponse
     */
    success: boolean;
    /**
     * ID of the Address
     * @type {string}
     * @memberof GetUserAddressResponse
     */
    id: string;
    /**
     * Identity name
     * @type {string}
     * @memberof GetUserAddressResponse
     */
    name: string;
    /**
     * E-mail address string
     * @type {string}
     * @memberof GetUserAddressResponse
     */
    address: string;
    /**
     * List of tags associated with the Address
     * @type {Array<string>}
     * @memberof GetUserAddressResponse
     */
    tags: Array<string>;
    /**
     * Metadata object (if available)
     * @type {object}
     * @memberof GetUserAddressResponse
     */
    metaData?: object;
    /**
     * Internal metadata object (if available), not included for user-role requests
     * @type {object}
     * @memberof GetUserAddressResponse
     */
    internalData?: object;
    /**
     * Indicates if this is the default address for the User
     * @type {boolean}
     * @memberof GetUserAddressResponse
     */
    main: boolean;
    /**
     * Datestring of the time the address was created
     * @type {string}
     * @memberof GetUserAddressResponse
     */
    created: string;
}
/**
 * 
 * @export
 * @interface GetUserAddressesResponse
 */
export interface GetUserAddressesResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetUserAddressesResponse
     */
    success: boolean;
    /**
     * Address listing
     * @type {Array<GetUserAddressesResult>}
     * @memberof GetUserAddressesResponse
     */
    results: Array<GetUserAddressesResult>;
}
/**
 * 
 * @export
 * @interface GetUserAddressesResult
 */
export interface GetUserAddressesResult {
    /**
     * ID of the Address
     * @type {string}
     * @memberof GetUserAddressesResult
     */
    id: string;
    /**
     * Identity name
     * @type {string}
     * @memberof GetUserAddressesResult
     */
    name: string;
    /**
     * E-mail address string
     * @type {string}
     * @memberof GetUserAddressesResult
     */
    address: string;
    /**
     * Indicates if this is the default address for the User
     * @type {boolean}
     * @memberof GetUserAddressesResult
     */
    main: boolean;
    /**
     * Datestring of the time the address was created
     * @type {string}
     * @memberof GetUserAddressesResult
     */
    created: string;
    /**
     * List of tags associated with the Address
     * @type {Array<string>}
     * @memberof GetUserAddressesResult
     */
    tags: Array<string>;
    /**
     * Metadata object (if available)
     * @type {object}
     * @memberof GetUserAddressesResult
     */
    metaData?: object;
    /**
     * Internal metadata object (if available), not included for user-role requests
     * @type {object}
     * @memberof GetUserAddressesResult
     */
    internalData?: object;
}
/**
 * 
 * @export
 * @interface GetUserAddressesregisterResponse
 */
export interface GetUserAddressesregisterResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetUserAddressesregisterResponse
     */
    success: boolean;
    /**
     * Address listing
     * @type {Array<GetUserAddressesregisterResult>}
     * @memberof GetUserAddressesregisterResponse
     */
    results: Array<GetUserAddressesregisterResult>;
}
/**
 * 
 * @export
 * @interface GetUserAddressesregisterResult
 */
export interface GetUserAddressesregisterResult {
    /**
     * ID of the Address
     * @type {string}
     * @memberof GetUserAddressesregisterResult
     */
    id: string;
    /**
     * Name from address header
     * @type {string}
     * @memberof GetUserAddressesregisterResult
     */
    name?: string;
    /**
     * E-mail address string
     * @type {string}
     * @memberof GetUserAddressesregisterResult
     */
    address: string;
}
/**
 * 
 * @export
 * @interface GetUserResponse
 */
export interface GetUserResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetUserResponse
     */
    success: boolean;
    /**
     * Users unique ID (24 byte hex)
     * @type {string}
     * @memberof GetUserResponse
     */
    id: string;
    /**
     * Username of the User
     * @type {string}
     * @memberof GetUserResponse
     */
    username: string;
    /**
     * Name of the User
     * @type {string}
     * @memberof GetUserResponse
     */
    name: string;
    /**
     * Main email address of the User
     * @type {string}
     * @memberof GetUserResponse
     */
    address: string;
    /**
     * Default retention time (in ms). false if not enabled
     * @type {number}
     * @memberof GetUserResponse
     */
    retention: number;
    /**
     * List of enabled 2FA methods
     * @type {Array<string>}
     * @memberof GetUserResponse
     */
    enabled2fa: Array<string>;
    /**
     * Is autoreply enabled or not (start time may still be in the future or end time in the past)
     * @type {boolean}
     * @memberof GetUserResponse
     */
    autoreply: boolean;
    /**
     * If true then received messages are encrypted
     * @type {boolean}
     * @memberof GetUserResponse
     */
    encryptMessages: boolean;
    /**
     * If true then forwarded messages are encrypted
     * @type {boolean}
     * @memberof GetUserResponse
     */
    encryptForwarded: boolean;
    /**
     * Public PGP key for the User that is used for encryption
     * @type {string}
     * @memberof GetUserResponse
     */
    pubKey: string;
    /**
     * 
     * @type {KeyInfo}
     * @memberof GetUserResponse
     */
    keyInfo: KeyInfo;
    /**
     * Custom metadata object set for this user
     * @type {object}
     * @memberof GetUserResponse
     */
    metaData: object;
    /**
     * Custom interna metadata object set for this user. Not available for user-role tokens
     * @type {object}
     * @memberof GetUserResponse
     */
    internalData: object;
    /**
     * List of forwarding targets
     * @type {Array<string>}
     * @memberof GetUserResponse
     */
    targets: Array<string>;
    /**
     * Relative scale for detecting spam. 0 means that everything is spam, 100 means that nothing is spam
     * @type {number}
     * @memberof GetUserResponse
     */
    spamLevel: number;
    /**
     * 
     * @type {UserLimits}
     * @memberof GetUserResponse
     */
    limits: UserLimits;
    /**
     * List of tags associated with the User
     * @type {Array<string>}
     * @memberof GetUserResponse
     */
    tags: Array<string>;
    /**
     * A list of additional email addresses this user can send mail from. Wildcard is allowed.
     * @type {Array<string>}
     * @memberof GetUserResponse
     */
    fromWhitelist?: Array<string>;
    /**
     * Disabled scopes for this user
     * @type {Array<DisabledScopes>}
     * @memberof GetUserResponse
     */
    disabledScopes: Array<DisabledScopes>;
    /**
     * If true then the User has a password set and can authenticate
     * @type {boolean}
     * @memberof GetUserResponse
     */
    hasPasswordSet: boolean;
    /**
     * Is the account activated
     * @type {boolean}
     * @memberof GetUserResponse
     */
    activated: boolean;
    /**
     * If true then the user can not authenticate or receive any new mail
     * @type {boolean}
     * @memberof GetUserResponse
     */
    disabled: boolean;
    /**
     * If true then the user can not authenticate
     * @type {boolean}
     * @memberof GetUserResponse
     */
    suspended: boolean;
}
/**
 * 
 * @export
 * @interface GetUsersResponse
 */
export interface GetUsersResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetUsersResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof GetUsersResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof GetUsersResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof GetUsersResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof GetUsersResponse
     */
    nextCursor: string;
    /**
     * User listing
     * @type {Array<GetUsersResult>}
     * @memberof GetUsersResponse
     */
    results: Array<GetUsersResult>;
}
/**
 * 
 * @export
 * @interface GetUsersResult
 */
export interface GetUsersResult {
    /**
     * Users unique ID (24 byte hex)
     * @type {string}
     * @memberof GetUsersResult
     */
    id: string;
    /**
     * Username of the User
     * @type {string}
     * @memberof GetUsersResult
     */
    username: string;
    /**
     * Name of the User
     * @type {string}
     * @memberof GetUsersResult
     */
    name: string;
    /**
     * Main email address of the User
     * @type {string}
     * @memberof GetUsersResult
     */
    address: string;
    /**
     * List of tags associated with the User\'
     * @type {Array<string>}
     * @memberof GetUsersResult
     */
    tags: Array<string>;
    /**
     * List of forwarding targets
     * @type {Array<string>}
     * @memberof GetUsersResult
     */
    targets: Array<string>;
    /**
     * List of enabled 2FA methods
     * @type {Array<string>}
     * @memberof GetUsersResult
     */
    enabled2fa: Array<string>;
    /**
     * Is autoreply enabled or not (start time may still be in the future or end time in the past)
     * @type {boolean}
     * @memberof GetUsersResult
     */
    autoreply: boolean;
    /**
     * If true then received messages are encrypted
     * @type {boolean}
     * @memberof GetUsersResult
     */
    encryptMessages: boolean;
    /**
     * If true then forwarded messages are encrypted
     * @type {boolean}
     * @memberof GetUsersResult
     */
    encryptForwarded: boolean;
    /**
     * 
     * @type {Quota}
     * @memberof GetUsersResult
     */
    quota: Quota;
    /**
     * Custom metadata value. Included if metaData query argument was true
     * @type {object}
     * @memberof GetUsersResult
     */
    metaData?: object;
    /**
     * Custom metadata value for internal use. Included if internalData query argument was true and request was not made using user-role token
     * @type {object}
     * @memberof GetUsersResult
     */
    internalData?: object;
    /**
     * If true then the User has a password set and can authenticate
     * @type {boolean}
     * @memberof GetUsersResult
     */
    hasPasswordSet: boolean;
    /**
     * Is the account activated
     * @type {boolean}
     * @memberof GetUsersResult
     */
    activated: boolean;
    /**
     * If true then the user can not authenticate or receive any new mail
     * @type {boolean}
     * @memberof GetUsersResult
     */
    disabled: boolean;
    /**
     * If true then the user can not authenticate
     * @type {boolean}
     * @memberof GetUsersResult
     */
    suspended: boolean;
}
/**
 * 
 * @export
 * @interface GetWebhooksResponse
 */
export interface GetWebhooksResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof GetWebhooksResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof GetWebhooksResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof GetWebhooksResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof GetWebhooksResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof GetWebhooksResponse
     */
    nextCursor: string;
    /**
     * Webhook listing
     * @type {Array<GetWebhooksResult>}
     * @memberof GetWebhooksResponse
     */
    results: Array<GetWebhooksResult>;
}
/**
 * 
 * @export
 * @interface GetWebhooksResult
 */
export interface GetWebhooksResult {
    /**
     * Webhooks unique ID (24 byte hex)
     * @type {string}
     * @memberof GetWebhooksResult
     */
    id: string;
    /**
     * An array of event types this webhook matches
     * @type {Array<string>}
     * @memberof GetWebhooksResult
     */
    type: Array<string>;
    /**
     * User ID or null
     * @type {string}
     * @memberof GetWebhooksResult
     */
    user: string;
    /**
     * Webhook URL
     * @type {string}
     * @memberof GetWebhooksResult
     */
    url: string;
}
/**
 * 
 * @export
 * @interface Header
 */
export interface Header {
    /**
     * Header key (\'X-Mailer\')
     * @type {string}
     * @memberof Header
     */
    key: string;
    /**
     * Header value (\'My Awesome Mailing Service\')
     * @type {string}
     * @memberof Header
     */
    value: string;
}
/**
 * IMAP download quota
 * @export
 * @interface ImapDownload
 */
export interface ImapDownload {
    /**
     * How many bytes per 24 hours can be downloaded via IMAP. Only message contents are counted, not protocol overhead.
     * @type {number}
     * @memberof ImapDownload
     */
    allowed: number;
    /**
     * How many bytes are downloaded during current 24 hour period
     * @type {number}
     * @memberof ImapDownload
     */
    used: number;
    /**
     * Time until the end of current 24 hour period
     * @type {number}
     * @memberof ImapDownload
     */
    ttl: number;
}
/**
 * 
 * @export
 * @interface ImapMaxConnections
 */
export interface ImapMaxConnections {
    /**
     * How many parallel IMAP connections are permitted
     * @type {number}
     * @memberof ImapMaxConnections
     */
    allowed: number;
    /**
     * How many parallel IMAP connections are currenlty in use
     * @type {number}
     * @memberof ImapMaxConnections
     */
    used: number;
}
/**
 * IMAP upload quota
 * @export
 * @interface ImapUpload
 */
export interface ImapUpload {
    /**
     * How many bytes per 24 hours can be uploaded via IMAP. Only message contents are counted, not protocol overhead.
     * @type {number}
     * @memberof ImapUpload
     */
    allowed: number;
    /**
     * How many bytes are uploaded during current 24 hour period
     * @type {number}
     * @memberof ImapUpload
     */
    used: number;
    /**
     * Time until the end of current 24 hour period
     * @type {number}
     * @memberof ImapUpload
     */
    ttl: number;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Username or E-mail address
     * @type {string}
     * @memberof InlineObject
     */
    username: string;
    /**
     * Required scope. One of master, imap, smtp, pop3
     * @type {string}
     * @memberof InlineObject
     */
    scope?: string;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof InlineObject
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof InlineObject
     */
    ip?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * An array of User ID values to export
     * @type {Array<string>}
     * @memberof InlineObject1
     */
    users?: Array<string>;
    /**
     * An array of user tags to export. If set then at least one tag must exist on an user.
     * @type {Array<string>}
     * @memberof InlineObject1
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * ID of the Mailbox
     * @type {string}
     * @memberof InlineObject2
     */
    mailbox?: string;
    /**
     * Thread ID
     * @type {string}
     * @memberof InlineObject2
     */
    thread?: string;
    /**
     * Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
     * @type {string}
     * @memberof InlineObject2
     */
    query?: string;
    /**
     * Datestring for the earliest message storing time
     * @type {string}
     * @memberof InlineObject2
     */
    datestart?: string;
    /**
     * Datestring for the latest message storing time
     * @type {string}
     * @memberof InlineObject2
     */
    dateend?: string;
    /**
     * Partial match for the From: header line
     * @type {string}
     * @memberof InlineObject2
     */
    from?: string;
    /**
     * Partial match for the To: and Cc: header lines
     * @type {string}
     * @memberof InlineObject2
     */
    to?: string;
    /**
     * Partial match for the Subject: header line
     * @type {string}
     * @memberof InlineObject2
     */
    subject?: string;
    /**
     * If true, then matches only messages with attachments
     * @type {boolean}
     * @memberof InlineObject2
     */
    attachments?: boolean;
    /**
     * If true, then matches only messages with \\Flagged flags
     * @type {boolean}
     * @memberof InlineObject2
     */
    flagged?: boolean;
    /**
     * If true, then matches only messages without \\Seen flags
     * @type {boolean}
     * @memberof InlineObject2
     */
    unseen?: boolean;
    /**
     * If true, then matches messages not in Junk or Trash
     * @type {boolean}
     * @memberof InlineObject2
     */
    searchable?: boolean;
    /**
     * 
     * @type {UsersUserSearchOr}
     * @memberof InlineObject2
     */
    or?: UsersUserSearchOr;
    /**
     * Minimal message size in bytes
     * @type {number}
     * @memberof InlineObject2
     */
    minSize?: number;
    /**
     * Maximal message size in bytes
     * @type {number}
     * @memberof InlineObject2
     */
    maxSize?: number;
    /**
     * 
     * @type {UsersUserSearchAction}
     * @memberof InlineObject2
     */
    action?: UsersUserSearchAction;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof InlineResponse200
     */
    success: boolean;
    /**
     * ID of authenticated User
     * @type {string}
     * @memberof InlineResponse200
     */
    id: string;
    /**
     * Username of authenticated User
     * @type {string}
     * @memberof InlineResponse200
     */
    username: string;
    /**
     * The scope this authentication is valid for
     * @type {string}
     * @memberof InlineResponse200
     */
    scope: string;
    /**
     * List of enabled 2FA mechanisms
     * @type {Array<string>}
     * @memberof InlineResponse200
     */
    require2fa: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * How many database entries were found from the export file
     * @type {number}
     * @memberof InlineResponse2001
     */
    entries?: number;
    /**
     * How many database entries were imported from the export file
     * @type {number}
     * @memberof InlineResponse2001
     */
    imported?: number;
    /**
     * How many database entries were not imported due to some error
     * @type {number}
     * @memberof InlineResponse2001
     */
    failed?: number;
    /**
     * How many database existing entries were not imported
     * @type {number}
     * @memberof InlineResponse2001
     */
    existing?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * Indicates if the action succeeded or not
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    success?: boolean;
    /**
     * ID of the scheduled operation
     * @type {string}
     * @memberof InlineResponse2002
     */
    scheduled?: string;
}
/**
 * Information about public key or false if key is not available
 * @export
 * @interface KeyInfo
 */
export interface KeyInfo {
    /**
     * Name listed in public key
     * @type {string}
     * @memberof KeyInfo
     */
    name: string;
    /**
     * E-mail address listed in public key
     * @type {string}
     * @memberof KeyInfo
     */
    address: string;
    /**
     * Fingerprint of the public key
     * @type {string}
     * @memberof KeyInfo
     */
    fingerprint: string;
}
/**
 * Information about last use
 * @export
 * @interface LastUse
 */
export interface LastUse {
    /**
     * Datestring of last use or false if password has not been used
     * @type {string}
     * @memberof LastUse
     */
    time: string;
    /**
     * Event ID of the security log for the last authentication
     * @type {string}
     * @memberof LastUse
     */
    event: string;
}
/**
 * If set then this message is from a mailing list
 * @export
 * @interface List
 */
export interface List {
    /**
     * Value from List-ID header
     * @type {string}
     * @memberof List
     */
    id: string;
    /**
     * Value from List-Unsubscribe header
     * @type {string}
     * @memberof List
     */
    unsubscribe: string;
}
/**
 * 
 * @export
 * @interface LogoutUserRequest
 */
export interface LogoutUserRequest {
    /**
     * Message to be shown to connected IMAP client
     * @type {string}
     * @memberof LogoutUserRequest
     */
    reason?: string;
}
/**
 * Optional names for special mailboxes
 * @export
 * @interface Mailboxes
 */
export interface Mailboxes {
    /**
     * Path of Sent Mail folder
     * @type {string}
     * @memberof Mailboxes
     */
    sent?: string;
    /**
     * Path of spam folder
     * @type {string}
     * @memberof Mailboxes
     */
    junk?: string;
    /**
     * Path of drafts folder
     * @type {string}
     * @memberof Mailboxes
     */
    drafts?: string;
    /**
     * Path of trash folder
     * @type {string}
     * @memberof Mailboxes
     */
    trash?: string;
}
/**
 * Message information
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * Message ID in mailbox
     * @type {number}
     * @memberof Message
     */
    id: number;
    /**
     * Mailbox ID the message was stored into
     * @type {string}
     * @memberof Message
     */
    mailbox: string;
    /**
     * Size of the RFC822 formatted email
     * @type {number}
     * @memberof Message
     */
    size?: number;
}
/**
 * Information about submitted Message
 * @export
 * @interface MessageWithQueueId
 */
export interface MessageWithQueueId {
    /**
     * Mailbox ID the message was stored to
     * @type {string}
     * @memberof MessageWithQueueId
     */
    mailbox: string;
    /**
     * Message ID in Mailbox
     * @type {number}
     * @memberof MessageWithQueueId
     */
    id: number;
    /**
     * Queue ID in MTA
     * @type {string}
     * @memberof MessageWithQueueId
     */
    queueId: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Order {
    Asc = 'asc',
    Desc = 'desc'
}

/**
 * 
 * @export
 * @interface Outbound
 */
export interface Outbound {
    /**
     * Queue ID
     * @type {string}
     * @memberof Outbound
     */
    queueId: string;
    /**
     * Queued recipients
     * @type {Array<OutboundQueueEntry>}
     * @memberof Outbound
     */
    entries: Array<OutboundQueueEntry>;
}
/**
 * 
 * @export
 * @interface OutboundQueueEntry
 */
export interface OutboundQueueEntry {
    /**
     * Queue target ID
     * @type {string}
     * @memberof OutboundQueueEntry
     */
    seq: string;
    /**
     * Target recipient
     * @type {string}
     * @memberof OutboundQueueEntry
     */
    recipient: string;
    /**
     * Zone ID in ZoneMTA
     * @type {string}
     * @memberof OutboundQueueEntry
     */
    sendingZone?: string;
    /**
     * ISO Date of the expected delivery time
     * @type {string}
     * @memberof OutboundQueueEntry
     */
    queued?: string;
}
/**
 * POP3 download quota
 * @export
 * @interface Pop3Download
 */
export interface Pop3Download {
    /**
     * How many bytes per 24 hours can be downloaded via POP3. Only message contents are counted, not protocol overhead.
     * @type {number}
     * @memberof Pop3Download
     */
    allowed: number;
    /**
     * How many bytes are downloaded during current 24 hour period
     * @type {number}
     * @memberof Pop3Download
     */
    used: number;
    /**
     * Time until the end of current 24 hour period
     * @type {number}
     * @memberof Pop3Download
     */
    ttl: number;
}
/**
 * Rules that a message must match
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * Partial match for the From: header (case insensitive)
     * @type {string}
     * @memberof Query
     */
    from?: string;
    /**
     * Partial match for the To:/Cc: headers (case insensitive)
     * @type {string}
     * @memberof Query
     */
    to?: string;
    /**
     * Partial match for the Subject: header (case insensitive)
     * @type {string}
     * @memberof Query
     */
    subject?: string;
    /**
     * Partial match for the List-ID: header (case insensitive)
     * @type {string}
     * @memberof Query
     */
    listId?: string;
    /**
     * Fulltext search against message text
     * @type {string}
     * @memberof Query
     */
    text?: string;
    /**
     * Does a message have to have an attachment or not
     * @type {boolean}
     * @memberof Query
     */
    ha?: boolean;
    /**
     * Message size in bytes. If the value is a positive number then message needs to be larger, if negative then message needs to be smaller than abs(size) value
     * @type {number}
     * @memberof Query
     */
    size?: number;
}
/**
 * Quota usage limits
 * @export
 * @interface Quota
 */
export interface Quota {
    /**
     * Allowed quota of the user in bytes
     * @type {number}
     * @memberof Quota
     */
    allowed: number;
    /**
     * Space used in bytes
     * @type {number}
     * @memberof Quota
     */
    used: number;
}
/**
 * Array of addresses from RCPT TO (should have just one normally)
 * @export
 * @interface Rcpt
 */
export interface Rcpt {
    /**
     * RCPT TO address as provided by SMTP client
     * @type {string}
     * @memberof Rcpt
     */
    value: string;
    /**
     * Normalized RCPT address
     * @type {string}
     * @memberof Rcpt
     */
    formatted: string;
}
/**
 * 
 * @export
 * @interface RecalculateQuotaResponse
 */
export interface RecalculateQuotaResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof RecalculateQuotaResponse
     */
    success: boolean;
    /**
     * Calculated quota usage for the user
     * @type {number}
     * @memberof RecalculateQuotaResponse
     */
    storageUsed: number;
}
/**
 * Receiving quota
 * @export
 * @interface Received
 */
export interface Received {
    /**
     * How many messages per 1 hour can be received
     * @type {number}
     * @memberof Received
     */
    allowed: number;
    /**
     * How many messages are received during current 1 hour period
     * @type {number}
     * @memberof Received
     */
    used: number;
    /**
     * Time until the end of current 1 hour period
     * @type {number}
     * @memberof Received
     */
    ttl: number;
}
/**
 * Sending quota
 * @export
 * @interface Recipients
 */
export interface Recipients {
    /**
     * How many messages per 24 hours can be sent
     * @type {number}
     * @memberof Recipients
     */
    allowed: number;
    /**
     * How many messages are sent during current 24 hour period
     * @type {number}
     * @memberof Recipients
     */
    used: number;
    /**
     * Time until the end of current 24 hour period
     * @type {number}
     * @memberof Recipients
     */
    ttl: number;
}
/**
 * 
 * @export
 * @interface RecoverInfoResponse
 */
export interface RecoverInfoResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof RecoverInfoResponse
     */
    success: boolean;
    /**
     * ID of the deleted User
     * @type {string}
     * @memberof RecoverInfoResponse
     */
    user: string;
    /**
     * Username of the User
     * @type {string}
     * @memberof RecoverInfoResponse
     */
    username: string;
    /**
     * Calculated quota usage for the user
     * @type {number}
     * @memberof RecoverInfoResponse
     */
    storageUsed: number;
    /**
     * List of tags associated with the User
     * @type {Array<string>}
     * @memberof RecoverInfoResponse
     */
    tags: Array<string>;
    /**
     * Datestring of the time the user was deleted
     * @type {string}
     * @memberof RecoverInfoResponse
     */
    deleted: string;
    /**
     * List of email addresses that can be restored
     * @type {Array<string>}
     * @memberof RecoverInfoResponse
     */
    recoverableAddresses: Array<string>;
}
/**
 * Optional referenced email. If submitted message is a reply and relevant fields are not provided then these are resolved from the message to be replied to
 * @export
 * @interface Reference
 */
export interface Reference {
    /**
     * Mailbox ID
     * @type {string}
     * @memberof Reference
     */
    mailbox: string;
    /**
     * Message ID in Mailbox
     * @type {number}
     * @memberof Reference
     */
    id: number;
    /**
     * Either reply, replyAll or forward
     * @type {string}
     * @memberof Reference
     */
    action: string;
}
/**
 * Optional referenced email. If uploaded message is a reply draft and relevant fields are not provided then these are resolved from the message to be replied to
 * @export
 * @interface ReferenceWithAttachments
 */
export interface ReferenceWithAttachments {
    /**
     * Mailbox ID
     * @type {string}
     * @memberof ReferenceWithAttachments
     */
    mailbox: string;
    /**
     * Message ID in Mailbox
     * @type {number}
     * @memberof ReferenceWithAttachments
     */
    id: number;
    /**
     * Either reply, replyAll or forward
     * @type {string}
     * @memberof ReferenceWithAttachments
     */
    action: string;
    /**
     * If true, then includes all attachments from the original message. If it is an array of attachment ID\'s includes attachments from the list
     * @type {Array<string>}
     * @memberof ReferenceWithAttachments
     */
    attachments: Array<string>;
}
/**
 * 
 * @export
 * @interface RenameDomainRequest
 */
export interface RenameDomainRequest {
    /**
     * Old Domain Name
     * @type {string}
     * @memberof RenameDomainRequest
     */
    oldDomain: string;
    /**
     * New Domain Name
     * @type {string}
     * @memberof RenameDomainRequest
     */
    newDomain: string;
}
/**
 * 
 * @export
 * @interface ResetUserPasswordRequest
 */
export interface ResetUserPasswordRequest {
    /**
     * Allow using the generated password not earlier than provided time
     * @type {string}
     * @memberof ResetUserPasswordRequest
     */
    validAfter?: string;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof ResetUserPasswordRequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof ResetUserPasswordRequest
     */
    ip?: string;
}
/**
 * 
 * @export
 * @interface ResetUserPasswordResponse
 */
export interface ResetUserPasswordResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof ResetUserPasswordResponse
     */
    success: boolean;
    /**
     * Temporary password
     * @type {string}
     * @memberof ResetUserPasswordResponse
     */
    password: string;
}
/**
 * 
 * @export
 * @interface ResolveAddressResponse
 */
export interface ResolveAddressResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof ResolveAddressResponse
     */
    success: boolean;
    /**
     * ID of the Address
     * @type {string}
     * @memberof ResolveAddressResponse
     */
    id: string;
    /**
     * E-mail address string
     * @type {string}
     * @memberof ResolveAddressResponse
     */
    address: string;
    /**
     * Identity name
     * @type {string}
     * @memberof ResolveAddressResponse
     */
    name: string;
    /**
     * ID of the user if the address belongs to a User
     * @type {string}
     * @memberof ResolveAddressResponse
     */
    user: string;
    /**
     * List of forwarding targets if this is a Forwarded address
     * @type {Array<string>}
     * @memberof ResolveAddressResponse
     */
    targets: Array<string>;
    /**
     * 
     * @type {AddressLimits}
     * @memberof ResolveAddressResponse
     */
    limits: AddressLimits;
    /**
     * 
     * @type {AutoreplyInfo}
     * @memberof ResolveAddressResponse
     */
    autoreply: AutoreplyInfo;
    /**
     * List of tags associated with the Address
     * @type {Array<string>}
     * @memberof ResolveAddressResponse
     */
    tags: Array<string>;
    /**
     * Datestring of the time the address was created
     * @type {string}
     * @memberof ResolveAddressResponse
     */
    created: string;
}
/**
 * 
 * @export
 * @interface ResolveIdResponse
 */
export interface ResolveIdResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof ResolveIdResponse
     */
    success: boolean;
    /**
     * Unique ID (24 byte hex)
     * @type {string}
     * @memberof ResolveIdResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface RestoreMessageRequest
 */
export interface RestoreMessageRequest {
    /**
     * ID of the target Mailbox. If not set then original mailbox is used.
     * @type {string}
     * @memberof RestoreMessageRequest
     */
    mailbox?: string;
}
/**
 * 
 * @export
 * @interface RestoreMessageResponse
 */
export interface RestoreMessageResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof RestoreMessageResponse
     */
    success: boolean;
    /**
     * Maibox ID the message was moved to
     * @type {string}
     * @memberof RestoreMessageResponse
     */
    mailbox: string;
    /**
     * New ID for the Message
     * @type {number}
     * @memberof RestoreMessageResponse
     */
    id: number;
}
/**
 * 
 * @export
 * @interface RestoreMessagesRequest
 */
export interface RestoreMessagesRequest {
    /**
     * Datestring
     * @type {string}
     * @memberof RestoreMessagesRequest
     */
    start: string;
    /**
     * Datestring
     * @type {string}
     * @memberof RestoreMessagesRequest
     */
    end: string;
}
/**
 * 
 * @export
 * @interface SearchMessagesResponse
 */
export interface SearchMessagesResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof SearchMessagesResponse
     */
    success: boolean;
    /**
     * How many results were found
     * @type {number}
     * @memberof SearchMessagesResponse
     */
    total: number;
    /**
     * Current page number. Derived from page query argument
     * @type {number}
     * @memberof SearchMessagesResponse
     */
    page: number;
    /**
     * Either a cursor string or false if there are not any previous results
     * @type {string}
     * @memberof SearchMessagesResponse
     */
    previousCursor: string;
    /**
     * Either a cursor string or false if there are not any next results
     * @type {string}
     * @memberof SearchMessagesResponse
     */
    nextCursor: string;
    /**
     * Message listing
     * @type {Array<GetMessagesResult>}
     * @memberof SearchMessagesResponse
     */
    results: Array<GetMessagesResult>;
}
/**
 * 
 * @export
 * @interface SetupTotp2FARequest
 */
export interface SetupTotp2FARequest {
    /**
     * Label text for QR code (defaults to username)
     * @type {string}
     * @memberof SetupTotp2FARequest
     */
    label?: string;
    /**
     * Description text for QR code (defaults to \"WildDuck\")
     * @type {string}
     * @memberof SetupTotp2FARequest
     */
    issuer?: string;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof SetupTotp2FARequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof SetupTotp2FARequest
     */
    ip?: string;
}
/**
 * 
 * @export
 * @interface SetupTotp2FAResponse
 */
export interface SetupTotp2FAResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof SetupTotp2FAResponse
     */
    success: boolean;
    /**
     * Generated TOTP seed value
     * @type {string}
     * @memberof SetupTotp2FAResponse
     */
    seed: string;
    /**
     * Base64 encoded QR code
     * @type {string}
     * @memberof SetupTotp2FAResponse
     */
    qrcode: string;
}
/**
 * Either special use identifier or null. One of \\Drafts, \\Junk, \\Sent or \\Trash
 * @export
 * @enum {string}
 */
export enum SpecialUse {
    Drafts = '\\Drafts',
    Junk = '\\Junk',
    Sent = '\\Sent',
    Trash = '\\Trash'
}

/**
 * 
 * @export
 * @interface SubmitMessageRequest
 */
export interface SubmitMessageRequest {
    /**
     * 
     * @type {Reference}
     * @memberof SubmitMessageRequest
     */
    reference?: Reference;
    /**
     * Mailbox ID where to upload the message. If not set then message is uploaded to Sent Mail folder.
     * @type {string}
     * @memberof SubmitMessageRequest
     */
    mailbox?: string;
    /**
     * If true then generated message is not added to the sending queue
     * @type {boolean}
     * @memberof SubmitMessageRequest
     */
    uploadOnly?: boolean;
    /**
     * If true then treats this message as draft (should be used with uploadOnly=true)
     * @type {boolean}
     * @memberof SubmitMessageRequest
     */
    isDraft?: boolean;
    /**
     * Datestring for delivery if message should be sent some later time
     * @type {string}
     * @memberof SubmitMessageRequest
     */
    sendTime?: string;
    /**
     * 
     * @type {EnvelopeUpload}
     * @memberof SubmitMessageRequest
     */
    envelope?: EnvelopeUpload;
    /**
     * 
     * @type {Address}
     * @memberof SubmitMessageRequest
     */
    from?: Address;
    /**
     * Addresses for the To: header
     * @type {Array<AddressOptionalName>}
     * @memberof SubmitMessageRequest
     */
    to?: Array<AddressOptionalName>;
    /**
     * Addresses for the Cc: header
     * @type {Array<AddressOptionalName>}
     * @memberof SubmitMessageRequest
     */
    cc?: Array<AddressOptionalName>;
    /**
     * Addresses for the Bcc: header
     * @type {Array<AddressOptionalName>}
     * @memberof SubmitMessageRequest
     */
    bcc?: Array<AddressOptionalName>;
    /**
     * Message subject. If not then resolved from Reference message
     * @type {string}
     * @memberof SubmitMessageRequest
     */
    subject: string;
    /**
     * Plaintext message
     * @type {string}
     * @memberof SubmitMessageRequest
     */
    text: string;
    /**
     * HTML formatted message
     * @type {string}
     * @memberof SubmitMessageRequest
     */
    html: string;
    /**
     * Custom headers for the message. If reference message is set then In-Reply-To and References headers are set automatically
     * @type {Array<Header>}
     * @memberof SubmitMessageRequest
     */
    headers?: Array<Header>;
    /**
     * Attachments for the message
     * @type {Array<AttachmentsUpload>}
     * @memberof SubmitMessageRequest
     */
    attachments?: Array<AttachmentsUpload>;
    /**
     * Custom metainfo for the message
     * @type {object}
     * @memberof SubmitMessageRequest
     */
    meta?: object;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof SubmitMessageRequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof SubmitMessageRequest
     */
    ip?: string;
}
/**
 * 
 * @export
 * @interface SubmitMessageResponse
 */
export interface SubmitMessageResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof SubmitMessageResponse
     */
    success: boolean;
    /**
     * 
     * @type {MessageWithQueueId}
     * @memberof SubmitMessageResponse
     */
    message: MessageWithQueueId;
}
/**
 * 
 * @export
 * @interface SubmitStoredMessageRequest
 */
export interface SubmitStoredMessageRequest {
    /**
     * If true then deletes attachment files listed in metaData.files array
     * @type {boolean}
     * @memberof SubmitStoredMessageRequest
     */
    deleteFiles?: boolean;
    /**
     * Datestring for delivery if message should be sent some later time
     * @type {string}
     * @memberof SubmitStoredMessageRequest
     */
    sendTime?: string;
}
/**
 * 
 * @export
 * @interface SubmitStoredMessageResponse
 */
export interface SubmitStoredMessageResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof SubmitStoredMessageResponse
     */
    success: boolean;
    /**
     * Message ID in outbound queue
     * @type {string}
     * @memberof SubmitStoredMessageResponse
     */
    queueId: string;
    /**
     * 
     * @type {Message}
     * @memberof SubmitStoredMessageResponse
     */
    message?: Message;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof SuccessResponse
     */
    success: boolean;
}
/**
 * TLS information. Value is false if TLS was not used
 * @export
 * @interface Tls
 */
export interface Tls {
    /**
     * Cipher name, eg \"ECDHE-RSA-AES128-GCM-SHA256\"
     * @type {object}
     * @memberof Tls
     */
    name: object;
    /**
     * TLS version, eg \"TLSv1/SSLv3\"
     * @type {object}
     * @memberof Tls
     */
    version: object;
}
/**
 * 
 * @export
 * @interface UpdateAutoreplyRequest
 */
export interface UpdateAutoreplyRequest {
    /**
     * Is the autoreply enabled (true) or not (false)
     * @type {boolean}
     * @memberof UpdateAutoreplyRequest
     */
    status?: boolean;
    /**
     * Name that is used for the From: header in autoreply message
     * @type {string}
     * @memberof UpdateAutoreplyRequest
     */
    name?: string;
    /**
     * Subject line for the autoreply. If empty then uses subject of the original message
     * @type {string}
     * @memberof UpdateAutoreplyRequest
     */
    subject?: string;
    /**
     * HTML formatted content of the autoreply message
     * @type {string}
     * @memberof UpdateAutoreplyRequest
     */
    html?: string;
    /**
     * Plaintext formatted content of the autoreply message
     * @type {string}
     * @memberof UpdateAutoreplyRequest
     */
    text?: string;
    /**
     * Datestring of the start of the autoreply or boolean false to disable start checks
     * @type {string}
     * @memberof UpdateAutoreplyRequest
     */
    start?: string;
    /**
     * Datestring of the end of the autoreply or boolean false to disable end checks
     * @type {string}
     * @memberof UpdateAutoreplyRequest
     */
    end?: string;
}
/**
 * 
 * @export
 * @interface UpdateDkimKeyRequest
 */
export interface UpdateDkimKeyRequest {
    /**
     * Domain name this DKIM key applies to. Use \"*\" as a special value that will be used for domains that do not have their own DKIM key set
     * @type {string}
     * @memberof UpdateDkimKeyRequest
     */
    domain: string;
    /**
     * Selector for the key
     * @type {string}
     * @memberof UpdateDkimKeyRequest
     */
    selector: string;
    /**
     * Key description
     * @type {string}
     * @memberof UpdateDkimKeyRequest
     */
    description?: string;
    /**
     * Pem formatted DKIM private key. If not set then a new 2048 bit RSA key is generated, beware though that it can take several seconds to complete.
     * @type {string}
     * @memberof UpdateDkimKeyRequest
     */
    privateKey?: string;
}
/**
 * 
 * @export
 * @interface UpdateDkimKeyResponse
 */
export interface UpdateDkimKeyResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof UpdateDkimKeyResponse
     */
    success: boolean;
    /**
     * ID of the DKIM
     * @type {string}
     * @memberof UpdateDkimKeyResponse
     */
    id: string;
    /**
     * The domain this DKIM key applies to
     * @type {string}
     * @memberof UpdateDkimKeyResponse
     */
    domain: string;
    /**
     * DKIM selector
     * @type {string}
     * @memberof UpdateDkimKeyResponse
     */
    selector: string;
    /**
     * Key description
     * @type {string}
     * @memberof UpdateDkimKeyResponse
     */
    description: string;
    /**
     * Key fingerprint (SHA1)
     * @type {string}
     * @memberof UpdateDkimKeyResponse
     */
    fingerprint: string;
    /**
     * Public key in DNS format (no prefix/suffix, single line)
     * @type {string}
     * @memberof UpdateDkimKeyResponse
     */
    publicKey: string;
    /**
     * 
     * @type {DnsTxt}
     * @memberof UpdateDkimKeyResponse
     */
    dnsTxt: DnsTxt;
}
/**
 * 
 * @export
 * @interface UpdateFilterRequest
 */
export interface UpdateFilterRequest {
    /**
     * Name of the Filter
     * @type {string}
     * @memberof UpdateFilterRequest
     */
    name?: string;
    /**
     * 
     * @type {Query}
     * @memberof UpdateFilterRequest
     */
    query?: Query;
    /**
     * 
     * @type {Action}
     * @memberof UpdateFilterRequest
     */
    action?: Action;
    /**
     * If true then this filter is ignored
     * @type {boolean}
     * @memberof UpdateFilterRequest
     */
    disabled?: boolean;
    /**
     * Optional metadata, must be an object or JSON formatted string
     * @type {object | string}
     * @memberof UpdateFilterRequest
     */
    metaData?: object | string;
}
/**
 * 
 * @export
 * @interface UpdateFilterResponse
 */
export interface UpdateFilterResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof UpdateFilterResponse
     */
    success: boolean;
    /**
     * ID for the created Filter
     * @type {string}
     * @memberof UpdateFilterResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface UpdateForwardedAddressRequest
 */
export interface UpdateForwardedAddressRequest {
    /**
     * New address. Only affects normal addresses, special addresses that include * can not be changed
     * @type {string}
     * @memberof UpdateForwardedAddressRequest
     */
    address?: string;
    /**
     * Identity name
     * @type {string}
     * @memberof UpdateForwardedAddressRequest
     */
    name?: string;
    /**
     * An array of forwarding targets. The value could either be an email address or a relay url to next MX server (\"smtp://mx2.zone.eu:25\") or an URL where mail contents are POSTed to. If set then overwrites previous targets array
     * @type {Array<string>}
     * @memberof UpdateForwardedAddressRequest
     */
    targets?: Array<string>;
    /**
     * Daily allowed forwarding count for this address
     * @type {number}
     * @memberof UpdateForwardedAddressRequest
     */
    forwards?: number;
    /**
     * A list of tags associated with this address
     * @type {Array<string>}
     * @memberof UpdateForwardedAddressRequest
     */
    tags?: Array<string>;
    /**
     * Optional metadata, must be an object or JSON formatted string
     * @type {object | string}
     * @memberof UpdateForwardedAddressRequest
     */
    metaData?: object | string;
    /**
     * Optional metadata for internal use, must be an object or JSON formatted string of an object. Not available for user-role tokens
     * @type {object | string}
     * @memberof UpdateForwardedAddressRequest
     */
    internalData?: object | string;
    /**
     * If true then disables forwarded address (stops forwarding messages)
     * @type {boolean}
     * @memberof UpdateForwardedAddressRequest
     */
    forwardedDisabled?: boolean;
    /**
     * 
     * @type {Autoreply}
     * @memberof UpdateForwardedAddressRequest
     */
    autoreply?: Autoreply;
}
/**
 * 
 * @export
 * @interface UpdateMailboxRequest
 */
export interface UpdateMailboxRequest {
    /**
     * Full path of the mailbox, use this to rename an existing Mailbox
     * @type {string}
     * @memberof UpdateMailboxRequest
     */
    path?: string;
    /**
     * Is the folder hidden or not. Hidden folders can not be opened in IMAP.
     * @type {boolean}
     * @memberof UpdateMailboxRequest
     */
    hidden?: boolean;
    /**
     * Retention policy for the Mailbox (in ms). Changing retention value only affects messages added to this folder after the change
     * @type {number}
     * @memberof UpdateMailboxRequest
     */
    retention?: number;
    /**
     * Change Mailbox subscription state
     * @type {boolean}
     * @memberof UpdateMailboxRequest
     */
    subscribed?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateMessageRequest
 */
export interface UpdateMessageRequest {
    /**
     * Message ID values. Either comma separated numbers (1,2,3) or colon separated range (3:15), or a range from UID to end (3:*)
     * @type {string}
     * @memberof UpdateMessageRequest
     */
    message?: string;
    /**
     * ID of the target Mailbox if you want to move messages
     * @type {string}
     * @memberof UpdateMessageRequest
     */
    moveTo?: string;
    /**
     * State of the \\Seen flag
     * @type {boolean}
     * @memberof UpdateMessageRequest
     */
    seen?: boolean;
    /**
     * State of the \\Flagged flag
     * @type {boolean}
     * @memberof UpdateMessageRequest
     */
    flagged?: boolean;
    /**
     * State of the \\Draft flag
     * @type {boolean}
     * @memberof UpdateMessageRequest
     */
    draft?: boolean;
    /**
     * Either expiration date or false to turn of autoexpiration
     * @type {string}
     * @memberof UpdateMessageRequest
     */
    expires?: string;
    /**
     * Optional metadata, must be an object or JSON formatted string
     * @type {object | string}
     * @memberof UpdateMessageRequest
     */
    metaData?: object | string;
}
/**
 * 
 * @export
 * @interface UpdateMessageResponse
 */
export interface UpdateMessageResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof UpdateMessageResponse
     */
    success: boolean;
    /**
     * If messages were moved then lists new ID values. Array entry is an array with first element pointing to old ID and second to new ID
     * @type {Array<object>}
     * @memberof UpdateMessageResponse
     */
    id: Array<object>;
    /**
     * If messages were not moved, then indicates the number of updated messages
     * @type {number}
     * @memberof UpdateMessageResponse
     */
    updated: number;
}
/**
 * 
 * @export
 * @interface UpdateTLSCertRequest
 */
export interface UpdateTLSCertRequest {
    /**
     * Server name this TLS certificate applies to
     * @type {string}
     * @memberof UpdateTLSCertRequest
     */
    servername: string;
    /**
     * If true then private key and certificate are managed automatically by ACME
     * @type {boolean}
     * @memberof UpdateTLSCertRequest
     */
    acme?: boolean;
    /**
     * PEM formatted TLS private key. Optional if certificate is managed by ACME
     * @type {string}
     * @memberof UpdateTLSCertRequest
     */
    privateKey?: string;
    /**
     * PEM formatted TLS certificate or a certificate bundle with concatenated certificate and CA chain. Optional if certificate is managed by ACME
     * @type {string}
     * @memberof UpdateTLSCertRequest
     */
    cert?: string;
    /**
     * CA chain certificates. Not needed if `cert` value is a bundle
     * @type {Array<string>}
     * @memberof UpdateTLSCertRequest
     */
    ca?: Array<string>;
    /**
     * Certificate description
     * @type {string}
     * @memberof UpdateTLSCertRequest
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface UpdateTLSCertResponse
 */
export interface UpdateTLSCertResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof UpdateTLSCertResponse
     */
    success: boolean;
    /**
     * ID of the certificate
     * @type {string}
     * @memberof UpdateTLSCertResponse
     */
    id: string;
    /**
     * The server name this certificate applies to
     * @type {string}
     * @memberof UpdateTLSCertResponse
     */
    servername: string;
    /**
     * Key description
     * @type {string}
     * @memberof UpdateTLSCertResponse
     */
    description?: string;
    /**
     * Key fingerprint (SHA1)
     * @type {string}
     * @memberof UpdateTLSCertResponse
     */
    fingerprint: string;
    /**
     * Certificate expiration time
     * @type {string}
     * @memberof UpdateTLSCertResponse
     */
    expires?: string;
    /**
     * SAN servernames listed in the certificate
     * @type {Array<string>}
     * @memberof UpdateTLSCertResponse
     */
    altNames?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserAddressRequest
 */
export interface UpdateUserAddressRequest {
    /**
     * Identity name
     * @type {string}
     * @memberof UpdateUserAddressRequest
     */
    name?: string;
    /**
     * New address if you want to rename existing address. Only affects normal addresses, special addresses that include * can not be changed
     * @type {string}
     * @memberof UpdateUserAddressRequest
     */
    address?: string;
    /**
     * Indicates if this is the default address for the User
     * @type {boolean}
     * @memberof UpdateUserAddressRequest
     */
    main: boolean;
    /**
     * Optional metadata, must be an object or JSON formatted string
     * @type {object | string}
     * @memberof UpdateUserAddressRequest
     */
    metaData?: object | string;
    /**
     * Optional metadata for internal use, must be an object or JSON formatted string of an object. Not available for user-role tokens
     * @type {object | string}
     * @memberof UpdateUserAddressRequest
     */
    internalData?: object | string;
    /**
     * A list of tags associated with this address
     * @type {Array<string>}
     * @memberof UpdateUserAddressRequest
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * Name of the User
     * @type {string}
     * @memberof UpdateUserRequest
     */
    name?: string;
    /**
     * If provided then validates against account password before applying any changes
     * @type {string}
     * @memberof UpdateUserRequest
     */
    existingPassword?: string;
    /**
     * New password for the account. Set to boolean false to disable password usage for the master scope, Application Specific Passwords would still be allowed
     * @type {string}
     * @memberof UpdateUserRequest
     */
    password?: string;
    /**
     * If true then password is already hashed, so store as is. Supported hashes: pbkdf2, bcrypt ($2a, $2y, $2b), md5 ($1), sha512 ($6), sha256 ($5), argon2 ($argon2d, $argon2i, $argon2id). Stored hashes are rehashed to pbkdf2 on first successful password check.
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    hashedPassword?: boolean;
    /**
     * If false then validates provided passwords against Have I Been Pwned API. Experimental, so validation is disabled by default but will be enabled automatically in some future version of WildDuck.
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    allowUnsafe?: boolean;
    /**
     * A list of tags associated with this user
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    tags?: Array<string>;
    /**
     * Default retention time (in ms). Set to 0 to disable
     * @type {number}
     * @memberof UpdateUserRequest
     */
    retention?: number;
    /**
     * If true then all messages sent through MSA are also uploaded to the Sent Mail folder. Might cause duplicates with some email clients, so disabled by default.
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    uploadSentMessages?: boolean;
    /**
     * If true then received messages are encrypted
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    encryptMessages?: boolean;
    /**
     * If true then forwarded messages are encrypted
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    encryptForwarded?: boolean;
    /**
     * Public PGP key for the User that is used for encryption. Use empty string to remove the key
     * @type {string}
     * @memberof UpdateUserRequest
     */
    pubKey?: string;
    /**
     * Optional metadata, must be an object or JSON formatted string
     * @type {object | string}
     * @memberof UpdateUserRequest
     */
    metaData?: object | string;
    /**
     * Optional internal metadata, must be an object or JSON formatted string of an object. Not available for user-role tokens
     * @type {object}
     * @memberof UpdateUserRequest
     */
    internalData?: object;
    /**
     * Language code for the User
     * @type {string}
     * @memberof UpdateUserRequest
     */
    language?: string;
    /**
     * An array of forwarding targets. The value could either be an email address or a relay url to next MX server (\"smtp://mx2.zone.eu:25\") or an URL where mail contents are POSTed to
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    targets?: Array<string>;
    /**
     * Relative scale for detecting spam. 0 means that everything is spam, 100 means that nothing is spam
     * @type {number}
     * @memberof UpdateUserRequest
     */
    spamLevel?: number;
    /**
     * Allowed quota of the user in bytes
     * @type {number}
     * @memberof UpdateUserRequest
     */
    quota?: number;
    /**
     * How many messages per 24 hour can be sent
     * @type {number}
     * @memberof UpdateUserRequest
     */
    recipients?: number;
    /**
     * How many messages per 24 hour can be forwarded
     * @type {number}
     * @memberof UpdateUserRequest
     */
    forwards?: number;
    /**
     * How many filters are allowed for this account
     * @type {number}
     * @memberof UpdateUserRequest
     */
    filters?: number;
    /**
     * How many bytes can be uploaded via IMAP during 24 hour
     * @type {number}
     * @memberof UpdateUserRequest
     */
    imapMaxUpload?: number;
    /**
     * How many bytes can be downloaded via IMAP during 24 hour
     * @type {number}
     * @memberof UpdateUserRequest
     */
    imapMaxDownload?: number;
    /**
     * How many bytes can be downloaded via POP3 during 24 hour
     * @type {number}
     * @memberof UpdateUserRequest
     */
    pop3MaxDownload?: number;
    /**
     * How many latest messages to list in POP3 session
     * @type {number}
     * @memberof UpdateUserRequest
     */
    pop3MaxMessages?: number;
    /**
     * How many parallel IMAP connections are alowed
     * @type {number}
     * @memberof UpdateUserRequest
     */
    imapMaxConnections?: number;
    /**
     * How many messages can be received from MX during 60 seconds
     * @type {number}
     * @memberof UpdateUserRequest
     */
    receivedMax?: number;
    /**
     * If true, then disables 2FA for this user
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    disable2fa?: boolean;
    /**
     * List of scopes that are disabled for this user (\"imap\", \"pop3\", \"smtp\")
     * @type {Array<DisabledScopes>}
     * @memberof UpdateUserRequest
     */
    disabledScopes?: Array<DisabledScopes>;
    /**
     * If true then disables user account (can not login, can not receive messages)
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    disabled?: boolean;
    /**
     * A list of additional email addresses this user can send mail from. Wildcard is allowed.
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    fromWhitelist?: Array<string>;
    /**
     * If true then disables authentication
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    suspended?: boolean;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof UpdateUserRequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof UpdateUserRequest
     */
    ip?: string;
}
/**
 * 
 * @export
 * @interface UploadFileResponse
 */
export interface UploadFileResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof UploadFileResponse
     */
    success: boolean;
    /**
     * File ID
     * @type {object}
     * @memberof UploadFileResponse
     */
    id: object;
}
/**
 * 
 * @export
 * @interface UploadMessageRequest
 */
export interface UploadMessageRequest {
    /**
     * Is the message unseen or not
     * @type {boolean}
     * @memberof UploadMessageRequest
     */
    unseen?: boolean;
    /**
     * Is the message a draft or not
     * @type {boolean}
     * @memberof UploadMessageRequest
     */
    draft?: boolean;
    /**
     * Is the message flagged or not
     * @type {boolean}
     * @memberof UploadMessageRequest
     */
    flagged?: boolean;
    /**
     * base64 encoded message source. Alternatively, you can provide this value as POST body by using message/rfc822 MIME type. If raw message is provided then it overrides any other mail configuration
     * @type {string}
     * @memberof UploadMessageRequest
     */
    raw?: string;
    /**
     * 
     * @type {Address}
     * @memberof UploadMessageRequest
     */
    from?: Address;
    /**
     * Addresses for the To: header
     * @type {Array<AddressOptionalName>}
     * @memberof UploadMessageRequest
     */
    to?: Array<AddressOptionalName>;
    /**
     * Addresses for the Cc: header
     * @type {Array<AddressOptionalName>}
     * @memberof UploadMessageRequest
     */
    cc?: Array<AddressOptionalName>;
    /**
     * Addresses for the Bcc: header
     * @type {Array<AddressOptionalName>}
     * @memberof UploadMessageRequest
     */
    bcc?: Array<AddressOptionalName>;
    /**
     * Message subject. If not then resolved from Reference message
     * @type {string}
     * @memberof UploadMessageRequest
     */
    subject?: string;
    /**
     * Plaintext message
     * @type {string}
     * @memberof UploadMessageRequest
     */
    text?: string;
    /**
     * HTML formatted message
     * @type {string}
     * @memberof UploadMessageRequest
     */
    html?: string;
    /**
     * Custom headers for the message. If reference message is set then In-Reply-To and References headers are set  automaticall y
     * @type {Array<Header>}
     * @memberof UploadMessageRequest
     */
    headers?: Array<Header>;
    /**
     * Attachments as storage file IDs. NB! When retrieving message info then an array of objects is returned. When uploading a message then an array of IDs is used.
     * @type {Array<string>}
     * @memberof UploadMessageRequest
     */
    files?: Array<string>;
    /**
     * Attachments for the message
     * @type {Array<AttachmentsUpload>}
     * @memberof UploadMessageRequest
     */
    attachments?: Array<AttachmentsUpload>;
    /**
     * Optional metadata, must be an object or JSON formatted string
     * @type {object | string}
     * @memberof UploadMessageRequest
     */
    metaData?: object | string;
    /**
     * 
     * @type {ReferenceWithAttachments}
     * @memberof UploadMessageRequest
     */
    reference?: ReferenceWithAttachments;
    /**
     * 
     * @type {UploadMessageRequestBimi}
     * @memberof UploadMessageRequest
     */
    bimi?: UploadMessageRequestBimi;
    /**
     * 
     * @type {UploadMessageRequestReplacePrevious}
     * @memberof UploadMessageRequest
     */
    replacePrevious?: UploadMessageRequestReplacePrevious;
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof UploadMessageRequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof UploadMessageRequest
     */
    ip?: string;
}
/**
 * Marks BIMI verification as passed for a domain. NB! BIMI record and logo files for the domain must be valid.
 * @export
 * @interface UploadMessageRequestBimi
 */
export interface UploadMessageRequestBimi {
    /**
     * Domain name for the BIMI record. It does not have to be the same as the From address.
     * @type {string}
     * @memberof UploadMessageRequestBimi
     */
    domain: string;
    /**
     * Optional BIMI selector
     * @type {string}
     * @memberof UploadMessageRequestBimi
     */
    selector?: string;
}
/**
 * If set, then deletes a previous message when storing the new one. Useful when uploading a new Draft message.
 * @export
 * @interface UploadMessageRequestReplacePrevious
 */
export interface UploadMessageRequestReplacePrevious {
    /**
     * Mailbox ID. Defaults to the mailbox of the uploaded message.
     * @type {string}
     * @memberof UploadMessageRequestReplacePrevious
     */
    mailbox?: string;
    /**
     * Message ID in Mailbox
     * @type {number}
     * @memberof UploadMessageRequestReplacePrevious
     */
    id: number;
}
/**
 * 
 * @export
 * @interface UploadMessageResponse
 */
export interface UploadMessageResponse {
    /**
     * Indicates successful response
     * @type {boolean}
     * @memberof UploadMessageResponse
     */
    success: boolean;
    /**
     * 
     * @type {Message}
     * @memberof UploadMessageResponse
     */
    message: Message;
    /**
     * Set if replacing a previous message was requested
     * @type {boolean}
     * @memberof UploadMessageResponse
     */
    previousDeleted?: boolean;
}
/**
 * Account limits and usage
 * @export
 * @interface UserLimits
 */
export interface UserLimits {
    /**
     * 
     * @type {Quota}
     * @memberof UserLimits
     */
    quota: Quota;
    /**
     * 
     * @type {Recipients}
     * @memberof UserLimits
     */
    recipients: Recipients;
    /**
     * 
     * @type {Filters}
     * @memberof UserLimits
     */
    filters?: Filters;
    /**
     * 
     * @type {Forwards}
     * @memberof UserLimits
     */
    forwards: Forwards;
    /**
     * 
     * @type {Received}
     * @memberof UserLimits
     */
    received: Received;
    /**
     * 
     * @type {ImapUpload}
     * @memberof UserLimits
     */
    imapUpload: ImapUpload;
    /**
     * 
     * @type {ImapDownload}
     * @memberof UserLimits
     */
    imapDownload: ImapDownload;
    /**
     * 
     * @type {Pop3Download}
     * @memberof UserLimits
     */
    pop3Download: Pop3Download;
    /**
     * 
     * @type {ImapMaxConnections}
     * @memberof UserLimits
     */
    imapMaxConnections?: ImapMaxConnections;
}
/**
 * 
 * @export
 * @interface UserRestoreRequest
 */
export interface UserRestoreRequest {
    /**
     * Session identifier for the logs
     * @type {string}
     * @memberof UserRestoreRequest
     */
    sess?: string;
    /**
     * IP address for the logs
     * @type {string}
     * @memberof UserRestoreRequest
     */
    ip?: string;
}
/**
 * Define actions to take with matching messages
 * @export
 * @interface UsersUserSearchAction
 */
export interface UsersUserSearchAction {
    /**
     * ID of the target Mailbox if you want to move messages
     * @type {string}
     * @memberof UsersUserSearchAction
     */
    moveTo?: string;
    /**
     * State of the \\Seen flag
     * @type {boolean}
     * @memberof UsersUserSearchAction
     */
    seen?: boolean;
    /**
     * State of the \\Flagged flag
     * @type {boolean}
     * @memberof UsersUserSearchAction
     */
    flagged?: boolean;
}
/**
 * At least onOne of the included terms must match
 * @export
 * @interface UsersUserSearchOr
 */
export interface UsersUserSearchOr {
    /**
     * Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
     * @type {string}
     * @memberof UsersUserSearchOr
     */
    query?: string;
    /**
     * Partial match for the From: header line
     * @type {string}
     * @memberof UsersUserSearchOr
     */
    from?: string;
    /**
     * Partial match for the To: and Cc: header lines
     * @type {string}
     * @memberof UsersUserSearchOr
     */
    to?: string;
    /**
     * Partial match for the Subject: header line
     * @type {string}
     * @memberof UsersUserSearchOr
     */
    subject?: string;
}
/**
 * Security verification info if message was received from MX. If this property is missing then do not automatically assume invalid TLS, SPF or DKIM.
 * @export
 * @interface VerificationResults
 */
export interface VerificationResults {
    /**
     * 
     * @type {Tls}
     * @memberof VerificationResults
     */
    tls: Tls;
    /**
     * Domain name (either MFROM or HELO) of verified SPF or false if no SPF match was found
     * @type {object}
     * @memberof VerificationResults
     */
    spf: object;
    /**
     * Domain name of verified DKIM signature or false if no valid signature was found
     * @type {object}
     * @memberof VerificationResults
     */
    dkim: object;
}

/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new forwarded email address. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both \"firstlast@example.com\" and \"first.last@example.com\" Special addresses `*@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument)
         * @summary Create new forwarded Address
         * @param {CreateForwardedAddressRequest} createForwardedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForwardedAddress: async (createForwardedAddressRequest: CreateForwardedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createForwardedAddressRequest' is not null or undefined
            assertParamExists('createForwardedAddress', 'createForwardedAddressRequest', createForwardedAddressRequest)
            const localVarPath = `/addresses/forwarded`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createForwardedAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new email address for a User. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both \"firstlast@example.com\" and \"first.last@example.com\" Special addresses `*@example.com`, `*suffix@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument)
         * @summary Create new Address
         * @param {string} user ID of the User
         * @param {CreateUserAddressRequest} createUserAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAddress: async (user: string, createUserAddressRequest: CreateUserAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUserAddress', 'user', user)
            // verify required parameter 'createUserAddressRequest' is not null or undefined
            assertParamExists('createUserAddress', 'createUserAddressRequest', createUserAddressRequest)
            const localVarPath = `/users/{user}/addresses`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a forwarded Address
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteForwardedAddress: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('deleteForwardedAddress', 'address', address)
            const localVarPath = `/addresses/forwarded/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an Address
         * @param {string} user ID of the User
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAddress: async (user: string, address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('deleteUserAddress', 'user', user)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('deleteUserAddress', 'address', address)
            const localVarPath = `/users/{user}/addresses/{address}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List registered Addresses
         * @param {string} [query] Partial match of an address
         * @param {string} [forward] Partial match of a forward email address or URL
         * @param {string} [tags] Comma separated list of tags. The Address must have at least one to be set
         * @param {string} [requiredTags] Comma separated list of tags. The Address must have all listed tags to be set
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddresses: async (query?: string, forward?: string, tags?: string, requiredTags?: string, metaData?: boolean, internalData?: boolean, limit?: number, page?: number, next?: string, previous?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (forward !== undefined) {
                localVarQueryParameter['forward'] = forward;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (requiredTags !== undefined) {
                localVarQueryParameter['requiredTags'] = requiredTags;
            }

            if (metaData !== undefined) {
                localVarQueryParameter['metaData'] = metaData;
            }

            if (internalData !== undefined) {
                localVarQueryParameter['internalData'] = internalData;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request forwarded Addresses information
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForwardedAddress: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getForwardedAddress', 'address', address)
            const localVarPath = `/addresses/forwarded/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Addresses information
         * @param {string} user ID of the User
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddress: async (user: string, address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUserAddress', 'user', user)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getUserAddress', 'address', address)
            const localVarPath = `/users/{user}/addresses/{address}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List registered Addresses for a User
         * @param {string} user ID of the User
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddresses: async (user: string, metaData?: boolean, internalData?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUserAddresses', 'user', user)
            const localVarPath = `/users/{user}/addresses`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (metaData !== undefined) {
                localVarQueryParameter['metaData'] = metaData;
            }

            if (internalData !== undefined) {
                localVarQueryParameter['internalData'] = internalData;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists addresses from email headers. Includes addresses both from sent and received messages. Sorted by last usage.
         * @summary List addresses from communication register
         * @param {string} user ID of the User
         * @param {string} query Prefix of an address or a name
         * @param {number} [limit] How many records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddressregister: async (user: string, query: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUserAddressregister', 'user', user)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getUserAddressregister', 'query', query)
            const localVarPath = `/users/{user}/addressregister`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Renames domain names for addresses, DKIM keys and Domain Aliases
         * @summary Rename domain in addresses
         * @param {RenameDomainRequest} renameDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameDomain: async (renameDomainRequest: RenameDomainRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'renameDomainRequest' is not null or undefined
            assertParamExists('renameDomain', 'renameDomainRequest', renameDomainRequest)
            const localVarPath = `/addresses/renameDomain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Address info
         * @param {string} address ID of the Address or e-mail address string
         * @param {boolean} [allowWildcard] If true then resolves also wildcard addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAddress: async (address: string, allowWildcard?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('resolveAddress', 'address', address)
            const localVarPath = `/addresses/resolve/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (allowWildcard !== undefined) {
                localVarQueryParameter['allowWildcard'] = allowWildcard;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update forwarded Address information
         * @param {string} address ID of the Address
         * @param {UpdateForwardedAddressRequest} updateForwardedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForwardedAddress: async (address: string, updateForwardedAddressRequest: UpdateForwardedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateForwardedAddress', 'address', address)
            // verify required parameter 'updateForwardedAddressRequest' is not null or undefined
            assertParamExists('updateForwardedAddress', 'updateForwardedAddressRequest', updateForwardedAddressRequest)
            const localVarPath = `/addresses/forwarded/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateForwardedAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Address information
         * @param {string} user ID of the User
         * @param {string} address ID of the Address
         * @param {UpdateUserAddressRequest} updateUserAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAddress: async (user: string, address: string, updateUserAddressRequest: UpdateUserAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUserAddress', 'user', user)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateUserAddress', 'address', address)
            // verify required parameter 'updateUserAddressRequest' is not null or undefined
            assertParamExists('updateUserAddress', 'updateUserAddressRequest', updateUserAddressRequest)
            const localVarPath = `/users/{user}/addresses/{address}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new forwarded email address. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both \"firstlast@example.com\" and \"first.last@example.com\" Special addresses `*@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument)
         * @summary Create new forwarded Address
         * @param {CreateForwardedAddressRequest} createForwardedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForwardedAddress(createForwardedAddressRequest: CreateForwardedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateForwardedAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createForwardedAddress(createForwardedAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new email address for a User. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both \"firstlast@example.com\" and \"first.last@example.com\" Special addresses `*@example.com`, `*suffix@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument)
         * @summary Create new Address
         * @param {string} user ID of the User
         * @param {CreateUserAddressRequest} createUserAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAddress(user: string, createUserAddressRequest: CreateUserAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAddress(user, createUserAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a forwarded Address
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteForwardedAddress(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteForwardedAddress(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an Address
         * @param {string} user ID of the User
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserAddress(user: string, address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAddress(user, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List registered Addresses
         * @param {string} [query] Partial match of an address
         * @param {string} [forward] Partial match of a forward email address or URL
         * @param {string} [tags] Comma separated list of tags. The Address must have at least one to be set
         * @param {string} [requiredTags] Comma separated list of tags. The Address must have all listed tags to be set
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddresses(query?: string, forward?: string, tags?: string, requiredTags?: string, metaData?: boolean, internalData?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddresses(query, forward, tags, requiredTags, metaData, internalData, limit, page, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request forwarded Addresses information
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForwardedAddress(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetForwardedAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForwardedAddress(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Addresses information
         * @param {string} user ID of the User
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAddress(user: string, address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAddress(user, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List registered Addresses for a User
         * @param {string} user ID of the User
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAddresses(user: string, metaData?: boolean, internalData?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserAddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAddresses(user, metaData, internalData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists addresses from email headers. Includes addresses both from sent and received messages. Sorted by last usage.
         * @summary List addresses from communication register
         * @param {string} user ID of the User
         * @param {string} query Prefix of an address or a name
         * @param {number} [limit] How many records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAddressregister(user: string, query: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserAddressesregisterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAddressregister(user, query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Renames domain names for addresses, DKIM keys and Domain Aliases
         * @summary Rename domain in addresses
         * @param {RenameDomainRequest} renameDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameDomain(renameDomainRequest: RenameDomainRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameDomain(renameDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Address info
         * @param {string} address ID of the Address or e-mail address string
         * @param {boolean} [allowWildcard] If true then resolves also wildcard addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveAddress(address: string, allowWildcard?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolveAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveAddress(address, allowWildcard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update forwarded Address information
         * @param {string} address ID of the Address
         * @param {UpdateForwardedAddressRequest} updateForwardedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateForwardedAddress(address: string, updateForwardedAddressRequest: UpdateForwardedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateForwardedAddress(address, updateForwardedAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Address information
         * @param {string} user ID of the User
         * @param {string} address ID of the Address
         * @param {UpdateUserAddressRequest} updateUserAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserAddress(user: string, address: string, updateUserAddressRequest: UpdateUserAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserAddress(user, address, updateUserAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Add a new forwarded email address. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both \"firstlast@example.com\" and \"first.last@example.com\" Special addresses `*@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument)
         * @summary Create new forwarded Address
         * @param {CreateForwardedAddressRequest} createForwardedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForwardedAddress(createForwardedAddressRequest: CreateForwardedAddressRequest, options?: any): AxiosPromise<CreateForwardedAddressResponse> {
            return localVarFp.createForwardedAddress(createForwardedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new email address for a User. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both \"firstlast@example.com\" and \"first.last@example.com\" Special addresses `*@example.com`, `*suffix@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument)
         * @summary Create new Address
         * @param {string} user ID of the User
         * @param {CreateUserAddressRequest} createUserAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAddress(user: string, createUserAddressRequest: CreateUserAddressRequest, options?: any): AxiosPromise<CreateUserAddressResponse> {
            return localVarFp.createUserAddress(user, createUserAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a forwarded Address
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteForwardedAddress(address: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteForwardedAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an Address
         * @param {string} user ID of the User
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAddress(user: string, address: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteUserAddress(user, address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List registered Addresses
         * @param {string} [query] Partial match of an address
         * @param {string} [forward] Partial match of a forward email address or URL
         * @param {string} [tags] Comma separated list of tags. The Address must have at least one to be set
         * @param {string} [requiredTags] Comma separated list of tags. The Address must have all listed tags to be set
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddresses(query?: string, forward?: string, tags?: string, requiredTags?: string, metaData?: boolean, internalData?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetAddressesResponse> {
            return localVarFp.getAddresses(query, forward, tags, requiredTags, metaData, internalData, limit, page, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request forwarded Addresses information
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForwardedAddress(address: string, options?: any): AxiosPromise<GetForwardedAddressResponse> {
            return localVarFp.getForwardedAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Addresses information
         * @param {string} user ID of the User
         * @param {string} address ID of the Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddress(user: string, address: string, options?: any): AxiosPromise<GetUserAddressResponse> {
            return localVarFp.getUserAddress(user, address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List registered Addresses for a User
         * @param {string} user ID of the User
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddresses(user: string, metaData?: boolean, internalData?: boolean, options?: any): AxiosPromise<GetUserAddressesResponse> {
            return localVarFp.getUserAddresses(user, metaData, internalData, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists addresses from email headers. Includes addresses both from sent and received messages. Sorted by last usage.
         * @summary List addresses from communication register
         * @param {string} user ID of the User
         * @param {string} query Prefix of an address or a name
         * @param {number} [limit] How many records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddressregister(user: string, query: string, limit?: number, options?: any): AxiosPromise<GetUserAddressesregisterResponse> {
            return localVarFp.getUserAddressregister(user, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Renames domain names for addresses, DKIM keys and Domain Aliases
         * @summary Rename domain in addresses
         * @param {RenameDomainRequest} renameDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameDomain(renameDomainRequest: RenameDomainRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.renameDomain(renameDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Address info
         * @param {string} address ID of the Address or e-mail address string
         * @param {boolean} [allowWildcard] If true then resolves also wildcard addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAddress(address: string, allowWildcard?: boolean, options?: any): AxiosPromise<ResolveAddressResponse> {
            return localVarFp.resolveAddress(address, allowWildcard, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update forwarded Address information
         * @param {string} address ID of the Address
         * @param {UpdateForwardedAddressRequest} updateForwardedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForwardedAddress(address: string, updateForwardedAddressRequest: UpdateForwardedAddressRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateForwardedAddress(address, updateForwardedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Address information
         * @param {string} user ID of the User
         * @param {string} address ID of the Address
         * @param {UpdateUserAddressRequest} updateUserAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAddress(user: string, address: string, updateUserAddressRequest: UpdateUserAddressRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateUserAddress(user, address, updateUserAddressRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesApi - interface
 * @export
 * @interface AddressesApi
 */
export interface AddressesApiInterface {
    /**
     * Add a new forwarded email address. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both \"firstlast@example.com\" and \"first.last@example.com\" Special addresses `*@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument)
     * @summary Create new forwarded Address
     * @param {CreateForwardedAddressRequest} createForwardedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    createForwardedAddress(createForwardedAddressRequest: CreateForwardedAddressRequest, options?: any): AxiosPromise<CreateForwardedAddressResponse>;

    /**
     * Add a new email address for a User. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both \"firstlast@example.com\" and \"first.last@example.com\" Special addresses `*@example.com`, `*suffix@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument)
     * @summary Create new Address
     * @param {string} user ID of the User
     * @param {CreateUserAddressRequest} createUserAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    createUserAddress(user: string, createUserAddressRequest: CreateUserAddressRequest, options?: any): AxiosPromise<CreateUserAddressResponse>;

    /**
     * 
     * @summary Delete a forwarded Address
     * @param {string} address ID of the Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    deleteForwardedAddress(address: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Delete an Address
     * @param {string} user ID of the User
     * @param {string} address ID of the Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    deleteUserAddress(user: string, address: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary List registered Addresses
     * @param {string} [query] Partial match of an address
     * @param {string} [forward] Partial match of a forward email address or URL
     * @param {string} [tags] Comma separated list of tags. The Address must have at least one to be set
     * @param {string} [requiredTags] Comma separated list of tags. The Address must have all listed tags to be set
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddresses(query?: string, forward?: string, tags?: string, requiredTags?: string, metaData?: boolean, internalData?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetAddressesResponse>;

    /**
     * 
     * @summary Request forwarded Addresses information
     * @param {string} address ID of the Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getForwardedAddress(address: string, options?: any): AxiosPromise<GetForwardedAddressResponse>;

    /**
     * 
     * @summary Request Addresses information
     * @param {string} user ID of the User
     * @param {string} address ID of the Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getUserAddress(user: string, address: string, options?: any): AxiosPromise<GetUserAddressResponse>;

    /**
     * 
     * @summary List registered Addresses for a User
     * @param {string} user ID of the User
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getUserAddresses(user: string, metaData?: boolean, internalData?: boolean, options?: any): AxiosPromise<GetUserAddressesResponse>;

    /**
     * Lists addresses from email headers. Includes addresses both from sent and received messages. Sorted by last usage.
     * @summary List addresses from communication register
     * @param {string} user ID of the User
     * @param {string} query Prefix of an address or a name
     * @param {number} [limit] How many records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getUserAddressregister(user: string, query: string, limit?: number, options?: any): AxiosPromise<GetUserAddressesregisterResponse>;

    /**
     * Renames domain names for addresses, DKIM keys and Domain Aliases
     * @summary Rename domain in addresses
     * @param {RenameDomainRequest} renameDomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    renameDomain(renameDomainRequest: RenameDomainRequest, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Get Address info
     * @param {string} address ID of the Address or e-mail address string
     * @param {boolean} [allowWildcard] If true then resolves also wildcard addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    resolveAddress(address: string, allowWildcard?: boolean, options?: any): AxiosPromise<ResolveAddressResponse>;

    /**
     * 
     * @summary Update forwarded Address information
     * @param {string} address ID of the Address
     * @param {UpdateForwardedAddressRequest} updateForwardedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    updateForwardedAddress(address: string, updateForwardedAddressRequest: UpdateForwardedAddressRequest, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Update Address information
     * @param {string} user ID of the User
     * @param {string} address ID of the Address
     * @param {UpdateUserAddressRequest} updateUserAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    updateUserAddress(user: string, address: string, updateUserAddressRequest: UpdateUserAddressRequest, options?: any): AxiosPromise<SuccessResponse>;

}

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI implements AddressesApiInterface {
    /**
     * Add a new forwarded email address. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both \"firstlast@example.com\" and \"first.last@example.com\" Special addresses `*@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument)
     * @summary Create new forwarded Address
     * @param {CreateForwardedAddressRequest} createForwardedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public createForwardedAddress(createForwardedAddressRequest: CreateForwardedAddressRequest, options?: any) {
        return AddressesApiFp(this.configuration).createForwardedAddress(createForwardedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new email address for a User. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both \"firstlast@example.com\" and \"first.last@example.com\" Special addresses `*@example.com`, `*suffix@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument)
     * @summary Create new Address
     * @param {string} user ID of the User
     * @param {CreateUserAddressRequest} createUserAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public createUserAddress(user: string, createUserAddressRequest: CreateUserAddressRequest, options?: any) {
        return AddressesApiFp(this.configuration).createUserAddress(user, createUserAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a forwarded Address
     * @param {string} address ID of the Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public deleteForwardedAddress(address: string, options?: any) {
        return AddressesApiFp(this.configuration).deleteForwardedAddress(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an Address
     * @param {string} user ID of the User
     * @param {string} address ID of the Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public deleteUserAddress(user: string, address: string, options?: any) {
        return AddressesApiFp(this.configuration).deleteUserAddress(user, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List registered Addresses
     * @param {string} [query] Partial match of an address
     * @param {string} [forward] Partial match of a forward email address or URL
     * @param {string} [tags] Comma separated list of tags. The Address must have at least one to be set
     * @param {string} [requiredTags] Comma separated list of tags. The Address must have all listed tags to be set
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getAddresses(query?: string, forward?: string, tags?: string, requiredTags?: string, metaData?: boolean, internalData?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any) {
        return AddressesApiFp(this.configuration).getAddresses(query, forward, tags, requiredTags, metaData, internalData, limit, page, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request forwarded Addresses information
     * @param {string} address ID of the Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getForwardedAddress(address: string, options?: any) {
        return AddressesApiFp(this.configuration).getForwardedAddress(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Addresses information
     * @param {string} user ID of the User
     * @param {string} address ID of the Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getUserAddress(user: string, address: string, options?: any) {
        return AddressesApiFp(this.configuration).getUserAddress(user, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List registered Addresses for a User
     * @param {string} user ID of the User
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getUserAddresses(user: string, metaData?: boolean, internalData?: boolean, options?: any) {
        return AddressesApiFp(this.configuration).getUserAddresses(user, metaData, internalData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists addresses from email headers. Includes addresses both from sent and received messages. Sorted by last usage.
     * @summary List addresses from communication register
     * @param {string} user ID of the User
     * @param {string} query Prefix of an address or a name
     * @param {number} [limit] How many records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getUserAddressregister(user: string, query: string, limit?: number, options?: any) {
        return AddressesApiFp(this.configuration).getUserAddressregister(user, query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Renames domain names for addresses, DKIM keys and Domain Aliases
     * @summary Rename domain in addresses
     * @param {RenameDomainRequest} renameDomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public renameDomain(renameDomainRequest: RenameDomainRequest, options?: any) {
        return AddressesApiFp(this.configuration).renameDomain(renameDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Address info
     * @param {string} address ID of the Address or e-mail address string
     * @param {boolean} [allowWildcard] If true then resolves also wildcard addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public resolveAddress(address: string, allowWildcard?: boolean, options?: any) {
        return AddressesApiFp(this.configuration).resolveAddress(address, allowWildcard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update forwarded Address information
     * @param {string} address ID of the Address
     * @param {UpdateForwardedAddressRequest} updateForwardedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public updateForwardedAddress(address: string, updateForwardedAddressRequest: UpdateForwardedAddressRequest, options?: any) {
        return AddressesApiFp(this.configuration).updateForwardedAddress(address, updateForwardedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Address information
     * @param {string} user ID of the User
     * @param {string} address ID of the Address
     * @param {UpdateUserAddressRequest} updateUserAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public updateUserAddress(user: string, address: string, updateUserAddressRequest: UpdateUserAddressRequest, options?: any) {
        return AddressesApiFp(this.configuration).updateUserAddress(user, address, updateUserAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationPasswordsApi - axios parameter creator
 * @export
 */
export const ApplicationPasswordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new Application Password
         * @param {string} user ID of the User
         * @param {CreateASPRequest} createASPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createASP: async (user: string, createASPRequest: CreateASPRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createASP', 'user', user)
            // verify required parameter 'createASPRequest' is not null or undefined
            assertParamExists('createASP', 'createASPRequest', createASPRequest)
            const localVarPath = `/users/{user}/asps`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createASPRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an Application Password
         * @param {string} user ID of the User
         * @param {string} asp ID of the Application Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteASP: async (user: string, asp: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('deleteASP', 'user', user)
            // verify required parameter 'asp' is not null or undefined
            assertParamExists('deleteASP', 'asp', asp)
            const localVarPath = `/users/{user}/asps/{asp}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"asp"}}`, encodeURIComponent(String(asp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request ASP information
         * @param {string} user ID of the User
         * @param {string} asp ID of the Application Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getASP: async (user: string, asp: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getASP', 'user', user)
            // verify required parameter 'asp' is not null or undefined
            assertParamExists('getASP', 'asp', asp)
            const localVarPath = `/users/{user}/asps/{asp}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"asp"}}`, encodeURIComponent(String(asp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Application Passwords
         * @param {string} user ID of the User
         * @param {boolean} [showAll] If not true then skips entries with a TTL set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getASPs: async (user: string, showAll?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getASPs', 'user', user)
            const localVarPath = `/users/{user}/asps`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (showAll !== undefined) {
                localVarQueryParameter['showAll'] = showAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationPasswordsApi - functional programming interface
 * @export
 */
export const ApplicationPasswordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationPasswordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new Application Password
         * @param {string} user ID of the User
         * @param {CreateASPRequest} createASPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createASP(user: string, createASPRequest: CreateASPRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateASPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createASP(user, createASPRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an Application Password
         * @param {string} user ID of the User
         * @param {string} asp ID of the Application Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteASP(user: string, asp: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteASP(user, asp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request ASP information
         * @param {string} user ID of the User
         * @param {string} asp ID of the Application Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getASP(user: string, asp: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetASPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getASP(user, asp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Application Passwords
         * @param {string} user ID of the User
         * @param {boolean} [showAll] If not true then skips entries with a TTL set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getASPs(user: string, showAll?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetASPsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getASPs(user, showAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationPasswordsApi - factory interface
 * @export
 */
export const ApplicationPasswordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationPasswordsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new Application Password
         * @param {string} user ID of the User
         * @param {CreateASPRequest} createASPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createASP(user: string, createASPRequest: CreateASPRequest, options?: any): AxiosPromise<CreateASPResponse> {
            return localVarFp.createASP(user, createASPRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an Application Password
         * @param {string} user ID of the User
         * @param {string} asp ID of the Application Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteASP(user: string, asp: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteASP(user, asp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request ASP information
         * @param {string} user ID of the User
         * @param {string} asp ID of the Application Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getASP(user: string, asp: string, options?: any): AxiosPromise<GetASPResponse> {
            return localVarFp.getASP(user, asp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Application Passwords
         * @param {string} user ID of the User
         * @param {boolean} [showAll] If not true then skips entries with a TTL set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getASPs(user: string, showAll?: boolean, options?: any): AxiosPromise<GetASPsResponse> {
            return localVarFp.getASPs(user, showAll, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationPasswordsApi - interface
 * @export
 * @interface ApplicationPasswordsApi
 */
export interface ApplicationPasswordsApiInterface {
    /**
     * 
     * @summary Create new Application Password
     * @param {string} user ID of the User
     * @param {CreateASPRequest} createASPRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationPasswordsApiInterface
     */
    createASP(user: string, createASPRequest: CreateASPRequest, options?: any): AxiosPromise<CreateASPResponse>;

    /**
     * 
     * @summary Delete an Application Password
     * @param {string} user ID of the User
     * @param {string} asp ID of the Application Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationPasswordsApiInterface
     */
    deleteASP(user: string, asp: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Request ASP information
     * @param {string} user ID of the User
     * @param {string} asp ID of the Application Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationPasswordsApiInterface
     */
    getASP(user: string, asp: string, options?: any): AxiosPromise<GetASPResponse>;

    /**
     * 
     * @summary List Application Passwords
     * @param {string} user ID of the User
     * @param {boolean} [showAll] If not true then skips entries with a TTL set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationPasswordsApiInterface
     */
    getASPs(user: string, showAll?: boolean, options?: any): AxiosPromise<GetASPsResponse>;

}

/**
 * ApplicationPasswordsApi - object-oriented interface
 * @export
 * @class ApplicationPasswordsApi
 * @extends {BaseAPI}
 */
export class ApplicationPasswordsApi extends BaseAPI implements ApplicationPasswordsApiInterface {
    /**
     * 
     * @summary Create new Application Password
     * @param {string} user ID of the User
     * @param {CreateASPRequest} createASPRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationPasswordsApi
     */
    public createASP(user: string, createASPRequest: CreateASPRequest, options?: any) {
        return ApplicationPasswordsApiFp(this.configuration).createASP(user, createASPRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an Application Password
     * @param {string} user ID of the User
     * @param {string} asp ID of the Application Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationPasswordsApi
     */
    public deleteASP(user: string, asp: string, options?: any) {
        return ApplicationPasswordsApiFp(this.configuration).deleteASP(user, asp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request ASP information
     * @param {string} user ID of the User
     * @param {string} asp ID of the Application Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationPasswordsApi
     */
    public getASP(user: string, asp: string, options?: any) {
        return ApplicationPasswordsApiFp(this.configuration).getASP(user, asp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Application Passwords
     * @param {string} user ID of the User
     * @param {boolean} [showAll] If not true then skips entries with a TTL set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationPasswordsApi
     */
    public getASPs(user: string, showAll?: boolean, options?: any) {
        return ApplicationPasswordsApiFp(this.configuration).getASPs(user, showAll, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArchiveApi - axios parameter creator
 * @export
 */
export const ArchiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive contains all recently deleted messages besides Drafts etc.
         * @summary List archived messages
         * @param {string} user ID of the User
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {Order} [order] Ordering of the records by insert date
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchivedMessages: async (user: string, limit?: number, page?: number, order?: Order, next?: string, previous?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getArchivedMessages', 'user', user)
            const localVarPath = `/users/{user}/archived/messages`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores a single archived message by moving it back to the mailbox it was deleted from or to provided target mailbox. If target mailbox does not exist, then the message is moved to INBOX.
         * @summary Restore archived Message
         * @param {string} user ID of the User
         * @param {number} message Message ID
         * @param {RestoreMessageRequest} [restoreMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreMessage: async (user: string, message: number, restoreMessageRequest?: RestoreMessageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('restoreMessage', 'user', user)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('restoreMessage', 'message', message)
            const localVarPath = `/users/{user}/archived/messages/{message}/restore`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"message"}}`, encodeURIComponent(String(message)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(restoreMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates a restore task to move archived messages of a date range back to the mailboxes the messages were deleted from. If target mailbox does not exist, then the messages are moved to INBOX.
         * @summary Restore archived messages
         * @param {string} user ID of the User
         * @param {RestoreMessagesRequest} restoreMessagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreMessages: async (user: string, restoreMessagesRequest: RestoreMessagesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('restoreMessages', 'user', user)
            // verify required parameter 'restoreMessagesRequest' is not null or undefined
            assertParamExists('restoreMessages', 'restoreMessagesRequest', restoreMessagesRequest)
            const localVarPath = `/users/{user}/archived/restore`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(restoreMessagesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArchiveApi - functional programming interface
 * @export
 */
export const ArchiveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArchiveApiAxiosParamCreator(configuration)
    return {
        /**
         * Archive contains all recently deleted messages besides Drafts etc.
         * @summary List archived messages
         * @param {string} user ID of the User
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {Order} [order] Ordering of the records by insert date
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArchivedMessages(user: string, limit?: number, page?: number, order?: Order, next?: string, previous?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetArchivedMessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArchivedMessages(user, limit, page, order, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restores a single archived message by moving it back to the mailbox it was deleted from or to provided target mailbox. If target mailbox does not exist, then the message is moved to INBOX.
         * @summary Restore archived Message
         * @param {string} user ID of the User
         * @param {number} message Message ID
         * @param {RestoreMessageRequest} [restoreMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreMessage(user: string, message: number, restoreMessageRequest?: RestoreMessageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreMessage(user, message, restoreMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiates a restore task to move archived messages of a date range back to the mailboxes the messages were deleted from. If target mailbox does not exist, then the messages are moved to INBOX.
         * @summary Restore archived messages
         * @param {string} user ID of the User
         * @param {RestoreMessagesRequest} restoreMessagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreMessages(user: string, restoreMessagesRequest: RestoreMessagesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreMessages(user, restoreMessagesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArchiveApi - factory interface
 * @export
 */
export const ArchiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArchiveApiFp(configuration)
    return {
        /**
         * Archive contains all recently deleted messages besides Drafts etc.
         * @summary List archived messages
         * @param {string} user ID of the User
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {Order} [order] Ordering of the records by insert date
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchivedMessages(user: string, limit?: number, page?: number, order?: Order, next?: string, previous?: string, options?: any): AxiosPromise<GetArchivedMessagesResponse> {
            return localVarFp.getArchivedMessages(user, limit, page, order, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores a single archived message by moving it back to the mailbox it was deleted from or to provided target mailbox. If target mailbox does not exist, then the message is moved to INBOX.
         * @summary Restore archived Message
         * @param {string} user ID of the User
         * @param {number} message Message ID
         * @param {RestoreMessageRequest} [restoreMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreMessage(user: string, message: number, restoreMessageRequest?: RestoreMessageRequest, options?: any): AxiosPromise<RestoreMessageResponse> {
            return localVarFp.restoreMessage(user, message, restoreMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a restore task to move archived messages of a date range back to the mailboxes the messages were deleted from. If target mailbox does not exist, then the messages are moved to INBOX.
         * @summary Restore archived messages
         * @param {string} user ID of the User
         * @param {RestoreMessagesRequest} restoreMessagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreMessages(user: string, restoreMessagesRequest: RestoreMessagesRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.restoreMessages(user, restoreMessagesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArchiveApi - interface
 * @export
 * @interface ArchiveApi
 */
export interface ArchiveApiInterface {
    /**
     * Archive contains all recently deleted messages besides Drafts etc.
     * @summary List archived messages
     * @param {string} user ID of the User
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {Order} [order] Ordering of the records by insert date
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApiInterface
     */
    getArchivedMessages(user: string, limit?: number, page?: number, order?: Order, next?: string, previous?: string, options?: any): AxiosPromise<GetArchivedMessagesResponse>;

    /**
     * Restores a single archived message by moving it back to the mailbox it was deleted from or to provided target mailbox. If target mailbox does not exist, then the message is moved to INBOX.
     * @summary Restore archived Message
     * @param {string} user ID of the User
     * @param {number} message Message ID
     * @param {RestoreMessageRequest} [restoreMessageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApiInterface
     */
    restoreMessage(user: string, message: number, restoreMessageRequest?: RestoreMessageRequest, options?: any): AxiosPromise<RestoreMessageResponse>;

    /**
     * Initiates a restore task to move archived messages of a date range back to the mailboxes the messages were deleted from. If target mailbox does not exist, then the messages are moved to INBOX.
     * @summary Restore archived messages
     * @param {string} user ID of the User
     * @param {RestoreMessagesRequest} restoreMessagesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApiInterface
     */
    restoreMessages(user: string, restoreMessagesRequest: RestoreMessagesRequest, options?: any): AxiosPromise<SuccessResponse>;

}

/**
 * ArchiveApi - object-oriented interface
 * @export
 * @class ArchiveApi
 * @extends {BaseAPI}
 */
export class ArchiveApi extends BaseAPI implements ArchiveApiInterface {
    /**
     * Archive contains all recently deleted messages besides Drafts etc.
     * @summary List archived messages
     * @param {string} user ID of the User
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {Order} [order] Ordering of the records by insert date
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public getArchivedMessages(user: string, limit?: number, page?: number, order?: Order, next?: string, previous?: string, options?: any) {
        return ArchiveApiFp(this.configuration).getArchivedMessages(user, limit, page, order, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restores a single archived message by moving it back to the mailbox it was deleted from or to provided target mailbox. If target mailbox does not exist, then the message is moved to INBOX.
     * @summary Restore archived Message
     * @param {string} user ID of the User
     * @param {number} message Message ID
     * @param {RestoreMessageRequest} [restoreMessageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public restoreMessage(user: string, message: number, restoreMessageRequest?: RestoreMessageRequest, options?: any) {
        return ArchiveApiFp(this.configuration).restoreMessage(user, message, restoreMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates a restore task to move archived messages of a date range back to the mailboxes the messages were deleted from. If target mailbox does not exist, then the messages are moved to INBOX.
     * @summary Restore archived messages
     * @param {string} user ID of the User
     * @param {RestoreMessagesRequest} restoreMessagesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public restoreMessages(user: string, restoreMessagesRequest: RestoreMessagesRequest, options?: any) {
        return ArchiveApiFp(this.configuration).restoreMessages(user, restoreMessagesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuditApi - axios parameter creator
 * @export
 */
export const AuditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiates a message audit
         * @summary Create new audit
         * @param {CreateAuditRequest} createAuditRequest Initiates a message audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAudit: async (createAuditRequest: CreateAuditRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAuditRequest' is not null or undefined
            assertParamExists('createAudit', 'createAuditRequest', createAuditRequest)
            const localVarPath = `/audit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAuditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method returns information about stored audit
         * @summary Request Audit Info
         * @param {string} audit ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudit: async (audit: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'audit' is not null or undefined
            assertParamExists('getAudit', 'audit', audit)
            const localVarPath = `/audit/{audit}`
                .replace(`{${"audit"}}`, encodeURIComponent(String(audit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method returns a mailbox file that contains all audited emails
         * @summary Export Audited Emails
         * @param {string} audit ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditEmails: async (audit: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'audit' is not null or undefined
            assertParamExists('getAuditEmails', 'audit', audit)
            const localVarPath = `/audit/{audit}/export.mbox`
                .replace(`{${"audit"}}`, encodeURIComponent(String(audit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditApi - functional programming interface
 * @export
 */
export const AuditApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiates a message audit
         * @summary Create new audit
         * @param {CreateAuditRequest} createAuditRequest Initiates a message audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAudit(createAuditRequest: CreateAuditRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAuditResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAudit(createAuditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns information about stored audit
         * @summary Request Audit Info
         * @param {string} audit ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudit(audit: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuditResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAudit(audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns a mailbox file that contains all audited emails
         * @summary Export Audited Emails
         * @param {string} audit ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditEmails(audit: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditEmails(audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuditApi - factory interface
 * @export
 */
export const AuditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditApiFp(configuration)
    return {
        /**
         * Initiates a message audit
         * @summary Create new audit
         * @param {CreateAuditRequest} createAuditRequest Initiates a message audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAudit(createAuditRequest: CreateAuditRequest, options?: any): AxiosPromise<CreateAuditResponse> {
            return localVarFp.createAudit(createAuditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This method returns information about stored audit
         * @summary Request Audit Info
         * @param {string} audit ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudit(audit: string, options?: any): AxiosPromise<GetAuditResponse> {
            return localVarFp.getAudit(audit, options).then((request) => request(axios, basePath));
        },
        /**
         * This method returns a mailbox file that contains all audited emails
         * @summary Export Audited Emails
         * @param {string} audit ID of the Audit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditEmails(audit: string, options?: any): AxiosPromise<void> {
            return localVarFp.getAuditEmails(audit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditApi - interface
 * @export
 * @interface AuditApi
 */
export interface AuditApiInterface {
    /**
     * Initiates a message audit
     * @summary Create new audit
     * @param {CreateAuditRequest} createAuditRequest Initiates a message audit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApiInterface
     */
    createAudit(createAuditRequest: CreateAuditRequest, options?: any): AxiosPromise<CreateAuditResponse>;

    /**
     * This method returns information about stored audit
     * @summary Request Audit Info
     * @param {string} audit ID of the Audit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApiInterface
     */
    getAudit(audit: string, options?: any): AxiosPromise<GetAuditResponse>;

    /**
     * This method returns a mailbox file that contains all audited emails
     * @summary Export Audited Emails
     * @param {string} audit ID of the Audit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApiInterface
     */
    getAuditEmails(audit: string, options?: any): AxiosPromise<void>;

}

/**
 * AuditApi - object-oriented interface
 * @export
 * @class AuditApi
 * @extends {BaseAPI}
 */
export class AuditApi extends BaseAPI implements AuditApiInterface {
    /**
     * Initiates a message audit
     * @summary Create new audit
     * @param {CreateAuditRequest} createAuditRequest Initiates a message audit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public createAudit(createAuditRequest: CreateAuditRequest, options?: any) {
        return AuditApiFp(this.configuration).createAudit(createAuditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns information about stored audit
     * @summary Request Audit Info
     * @param {string} audit ID of the Audit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public getAudit(audit: string, options?: any) {
        return AuditApiFp(this.configuration).getAudit(audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns a mailbox file that contains all audited emails
     * @summary Export Audited Emails
     * @param {string} audit ID of the Audit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public getAuditEmails(audit: string, options?: any) {
        return AuditApiFp(this.configuration).getAuditEmails(audit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate a User
         * @param {AuthenticateRequest} authenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (authenticateRequest: AuthenticateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticateRequest' is not null or undefined
            assertParamExists('authenticate', 'authenticateRequest', authenticateRequest)
            const localVarPath = `/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List authentication Events
         * @param {string} user ID of the User
         * @param {string} [action] Limit listing only to values with specific action value
         * @param {string} [filterIp] Limit listing only to values with specific IP address
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthlog: async (user: string, action?: string, filterIp?: string, limit?: number, page?: number, next?: string, previous?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getAuthlog', 'user', user)
            const localVarPath = `/users/{user}/authlog`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (filterIp !== undefined) {
                localVarQueryParameter['filterIp'] = filterIp;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Event information
         * @param {string} user ID of the User
         * @param {string} event ID of the Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthlogEvent: async (user: string, event: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getAuthlogEvent', 'user', user)
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getAuthlogEvent', 'event', event)
            const localVarPath = `/users/{user}/authlog/{event}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"event"}}`, encodeURIComponent(String(event)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method invalidates currently used authentication token. If token is not provided then nothing happens
         * @summary Invalidate authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateAccessToken: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if an username exists and can be used for authentication
         * @summary Pre-auth check
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preauth: async (inlineObject: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('preauth', 'inlineObject', inlineObject)
            const localVarPath = `/preauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate a User
         * @param {AuthenticateRequest} authenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(authenticateRequest: AuthenticateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(authenticateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List authentication Events
         * @param {string} user ID of the User
         * @param {string} [action] Limit listing only to values with specific action value
         * @param {string} [filterIp] Limit listing only to values with specific IP address
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthlog(user: string, action?: string, filterIp?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthlogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthlog(user, action, filterIp, limit, page, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Event information
         * @param {string} user ID of the User
         * @param {string} event ID of the Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthlogEvent(user: string, event: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthlogEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthlogEvent(user, event, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method invalidates currently used authentication token. If token is not provided then nothing happens
         * @summary Invalidate authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidateAccessToken(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invalidateAccessToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if an username exists and can be used for authentication
         * @summary Pre-auth check
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async preauth(inlineObject: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.preauth(inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate a User
         * @param {AuthenticateRequest} authenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(authenticateRequest: AuthenticateRequest, options?: any): AxiosPromise<AuthenticateResponse> {
            return localVarFp.authenticate(authenticateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List authentication Events
         * @param {string} user ID of the User
         * @param {string} [action] Limit listing only to values with specific action value
         * @param {string} [filterIp] Limit listing only to values with specific IP address
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthlog(user: string, action?: string, filterIp?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetAuthlogResponse> {
            return localVarFp.getAuthlog(user, action, filterIp, limit, page, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Event information
         * @param {string} user ID of the User
         * @param {string} event ID of the Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthlogEvent(user: string, event: string, options?: any): AxiosPromise<GetAuthlogEventResponse> {
            return localVarFp.getAuthlogEvent(user, event, options).then((request) => request(axios, basePath));
        },
        /**
         * This method invalidates currently used authentication token. If token is not provided then nothing happens
         * @summary Invalidate authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateAccessToken(options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.invalidateAccessToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Check if an username exists and can be used for authentication
         * @summary Pre-auth check
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preauth(inlineObject: InlineObject, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.preauth(inlineObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * 
     * @summary Authenticate a User
     * @param {AuthenticateRequest} authenticateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authenticate(authenticateRequest: AuthenticateRequest, options?: any): AxiosPromise<AuthenticateResponse>;

    /**
     * 
     * @summary List authentication Events
     * @param {string} user ID of the User
     * @param {string} [action] Limit listing only to values with specific action value
     * @param {string} [filterIp] Limit listing only to values with specific IP address
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    getAuthlog(user: string, action?: string, filterIp?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetAuthlogResponse>;

    /**
     * 
     * @summary Request Event information
     * @param {string} user ID of the User
     * @param {string} event ID of the Event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    getAuthlogEvent(user: string, event: string, options?: any): AxiosPromise<GetAuthlogEventResponse>;

    /**
     * This method invalidates currently used authentication token. If token is not provided then nothing happens
     * @summary Invalidate authentication token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    invalidateAccessToken(options?: any): AxiosPromise<SuccessResponse>;

    /**
     * Check if an username exists and can be used for authentication
     * @summary Pre-auth check
     * @param {InlineObject} inlineObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    preauth(inlineObject: InlineObject, options?: any): AxiosPromise<InlineResponse200>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * 
     * @summary Authenticate a User
     * @param {AuthenticateRequest} authenticateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticate(authenticateRequest: AuthenticateRequest, options?: any) {
        return AuthenticationApiFp(this.configuration).authenticate(authenticateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List authentication Events
     * @param {string} user ID of the User
     * @param {string} [action] Limit listing only to values with specific action value
     * @param {string} [filterIp] Limit listing only to values with specific IP address
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getAuthlog(user: string, action?: string, filterIp?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).getAuthlog(user, action, filterIp, limit, page, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Event information
     * @param {string} user ID of the User
     * @param {string} event ID of the Event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getAuthlogEvent(user: string, event: string, options?: any) {
        return AuthenticationApiFp(this.configuration).getAuthlogEvent(user, event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method invalidates currently used authentication token. If token is not provided then nothing happens
     * @summary Invalidate authentication token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public invalidateAccessToken(options?: any) {
        return AuthenticationApiFp(this.configuration).invalidateAccessToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if an username exists and can be used for authentication
     * @summary Pre-auth check
     * @param {InlineObject} inlineObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public preauth(inlineObject: InlineObject, options?: any) {
        return AuthenticationApiFp(this.configuration).preauth(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AutorepliesApi - axios parameter creator
 * @export
 */
export const AutorepliesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Autoreply information
         * @param {string} user ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutoreply: async (user: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('deleteAutoreply', 'user', user)
            const localVarPath = `/users/{user}/autoreply`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Autoreply information
         * @param {string} user ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreply: async (user: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getAutoreply', 'user', user)
            const localVarPath = `/users/{user}/autoreply`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Autoreply information
         * @param {string} user ID of the User
         * @param {UpdateAutoreplyRequest} updateAutoreplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoreply: async (user: string, updateAutoreplyRequest: UpdateAutoreplyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateAutoreply', 'user', user)
            // verify required parameter 'updateAutoreplyRequest' is not null or undefined
            assertParamExists('updateAutoreply', 'updateAutoreplyRequest', updateAutoreplyRequest)
            const localVarPath = `/users/{user}/autoreply`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAutoreplyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutorepliesApi - functional programming interface
 * @export
 */
export const AutorepliesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutorepliesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Autoreply information
         * @param {string} user ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAutoreply(user: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAutoreply(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Autoreply information
         * @param {string} user ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutoreply(user: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAutoreplyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoreply(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Autoreply information
         * @param {string} user ID of the User
         * @param {UpdateAutoreplyRequest} updateAutoreplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAutoreply(user: string, updateAutoreplyRequest: UpdateAutoreplyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAutoreply(user, updateAutoreplyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutorepliesApi - factory interface
 * @export
 */
export const AutorepliesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutorepliesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Autoreply information
         * @param {string} user ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutoreply(user: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteAutoreply(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Autoreply information
         * @param {string} user ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreply(user: string, options?: any): AxiosPromise<GetAutoreplyResponse> {
            return localVarFp.getAutoreply(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Autoreply information
         * @param {string} user ID of the User
         * @param {UpdateAutoreplyRequest} updateAutoreplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoreply(user: string, updateAutoreplyRequest: UpdateAutoreplyRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateAutoreply(user, updateAutoreplyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutorepliesApi - interface
 * @export
 * @interface AutorepliesApi
 */
export interface AutorepliesApiInterface {
    /**
     * 
     * @summary Delete Autoreply information
     * @param {string} user ID of the User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutorepliesApiInterface
     */
    deleteAutoreply(user: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Request Autoreply information
     * @param {string} user ID of the User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutorepliesApiInterface
     */
    getAutoreply(user: string, options?: any): AxiosPromise<GetAutoreplyResponse>;

    /**
     * 
     * @summary Update Autoreply information
     * @param {string} user ID of the User
     * @param {UpdateAutoreplyRequest} updateAutoreplyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutorepliesApiInterface
     */
    updateAutoreply(user: string, updateAutoreplyRequest: UpdateAutoreplyRequest, options?: any): AxiosPromise<SuccessResponse>;

}

/**
 * AutorepliesApi - object-oriented interface
 * @export
 * @class AutorepliesApi
 * @extends {BaseAPI}
 */
export class AutorepliesApi extends BaseAPI implements AutorepliesApiInterface {
    /**
     * 
     * @summary Delete Autoreply information
     * @param {string} user ID of the User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutorepliesApi
     */
    public deleteAutoreply(user: string, options?: any) {
        return AutorepliesApiFp(this.configuration).deleteAutoreply(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Autoreply information
     * @param {string} user ID of the User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutorepliesApi
     */
    public getAutoreply(user: string, options?: any) {
        return AutorepliesApiFp(this.configuration).getAutoreply(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Autoreply information
     * @param {string} user ID of the User
     * @param {UpdateAutoreplyRequest} updateAutoreplyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutorepliesApi
     */
    public updateAutoreply(user: string, updateAutoreplyRequest: UpdateAutoreplyRequest, options?: any) {
        return AutorepliesApiFp(this.configuration).updateAutoreply(user, updateAutoreplyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertsApi - axios parameter creator
 * @export
 */
export const CertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a TLS certificate
         * @param {string} cert ID of the TLS certificate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTlsCert: async (cert: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cert' is not null or undefined
            assertParamExists('deleteTlsCert', 'cert', cert)
            const localVarPath = `/certs/{cert}`
                .replace(`{${"cert"}}`, encodeURIComponent(String(cert)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request TLS certificate information
         * @param {string} cert ID of the TLS certificate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTLSCerticate: async (cert: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cert' is not null or undefined
            assertParamExists('getTLSCerticate', 'cert', cert)
            const localVarPath = `/certs/{cert}`
                .replace(`{${"cert"}}`, encodeURIComponent(String(cert)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List registered TLS certificates
         * @param {string} [query] Partial match of a server name
         * @param {boolean} [altNames] Match &#x60;query&#x60; value against SAN as well (including wildcard names)
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTLSCerticates: async (query?: string, altNames?: boolean, limit?: number, page?: number, next?: string, previous?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/certs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (altNames !== undefined) {
                localVarQueryParameter['altNames'] = altNames;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resolve ID for a server name
         * @param {string} servername Server name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveTLSCertificate: async (servername: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'servername' is not null or undefined
            assertParamExists('resolveTLSCertificate', 'servername', servername)
            const localVarPath = `/certs/resolve/{servername}`
                .replace(`{${"servername"}}`, encodeURIComponent(String(servername)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new TLS certificate for a server name or update existing one. You can add a single certificate for each server name but SAN names are supported as well. For example you can add a sertificate for \"mydomain.com\" that includes \"\\*.mydomain.com\" in SAN and the same certificate would be used for requests that do not have it\'s own server name registered but match the SAN value. > NB! you must ensure yourself that the `servername` value is actually listed in certificate\'s common name or SAN as WildDuck is going to use this certificate regardless. 
         * @summary Create or update TLS certificate for server name
         * @param {UpdateTLSCertRequest} updateTLSCertRequest Add a new TLS certificate for a server name or update existing one
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTLSCertificate: async (updateTLSCertRequest: UpdateTLSCertRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateTLSCertRequest' is not null or undefined
            assertParamExists('updateTLSCertificate', 'updateTLSCertRequest', updateTLSCertRequest)
            const localVarPath = `/certs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTLSCertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertsApi - functional programming interface
 * @export
 */
export const CertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a TLS certificate
         * @param {string} cert ID of the TLS certificate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTlsCert(cert: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTlsCert(cert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request TLS certificate information
         * @param {string} cert ID of the TLS certificate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTLSCerticate(cert: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTLSCertResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTLSCerticate(cert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List registered TLS certificates
         * @param {string} [query] Partial match of a server name
         * @param {boolean} [altNames] Match &#x60;query&#x60; value against SAN as well (including wildcard names)
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTLSCerticates(query?: string, altNames?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTLSCertsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTLSCerticates(query, altNames, limit, page, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resolve ID for a server name
         * @param {string} servername Server name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveTLSCertificate(servername: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolveIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveTLSCertificate(servername, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new TLS certificate for a server name or update existing one. You can add a single certificate for each server name but SAN names are supported as well. For example you can add a sertificate for \"mydomain.com\" that includes \"\\*.mydomain.com\" in SAN and the same certificate would be used for requests that do not have it\'s own server name registered but match the SAN value. > NB! you must ensure yourself that the `servername` value is actually listed in certificate\'s common name or SAN as WildDuck is going to use this certificate regardless. 
         * @summary Create or update TLS certificate for server name
         * @param {UpdateTLSCertRequest} updateTLSCertRequest Add a new TLS certificate for a server name or update existing one
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTLSCertificate(updateTLSCertRequest: UpdateTLSCertRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateTLSCertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTLSCertificate(updateTLSCertRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertsApi - factory interface
 * @export
 */
export const CertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a TLS certificate
         * @param {string} cert ID of the TLS certificate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTlsCert(cert: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteTlsCert(cert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request TLS certificate information
         * @param {string} cert ID of the TLS certificate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTLSCerticate(cert: string, options?: any): AxiosPromise<GetTLSCertResult> {
            return localVarFp.getTLSCerticate(cert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List registered TLS certificates
         * @param {string} [query] Partial match of a server name
         * @param {boolean} [altNames] Match &#x60;query&#x60; value against SAN as well (including wildcard names)
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTLSCerticates(query?: string, altNames?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetTLSCertsResponse> {
            return localVarFp.getTLSCerticates(query, altNames, limit, page, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resolve ID for a server name
         * @param {string} servername Server name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveTLSCertificate(servername: string, options?: any): AxiosPromise<ResolveIdResponse> {
            return localVarFp.resolveTLSCertificate(servername, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new TLS certificate for a server name or update existing one. You can add a single certificate for each server name but SAN names are supported as well. For example you can add a sertificate for \"mydomain.com\" that includes \"\\*.mydomain.com\" in SAN and the same certificate would be used for requests that do not have it\'s own server name registered but match the SAN value. > NB! you must ensure yourself that the `servername` value is actually listed in certificate\'s common name or SAN as WildDuck is going to use this certificate regardless. 
         * @summary Create or update TLS certificate for server name
         * @param {UpdateTLSCertRequest} updateTLSCertRequest Add a new TLS certificate for a server name or update existing one
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTLSCertificate(updateTLSCertRequest: UpdateTLSCertRequest, options?: any): AxiosPromise<UpdateTLSCertResponse> {
            return localVarFp.updateTLSCertificate(updateTLSCertRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CertsApi - interface
 * @export
 * @interface CertsApi
 */
export interface CertsApiInterface {
    /**
     * 
     * @summary Delete a TLS certificate
     * @param {string} cert ID of the TLS certificate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertsApiInterface
     */
    deleteTlsCert(cert: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Request TLS certificate information
     * @param {string} cert ID of the TLS certificate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertsApiInterface
     */
    getTLSCerticate(cert: string, options?: any): AxiosPromise<GetTLSCertResult>;

    /**
     * 
     * @summary List registered TLS certificates
     * @param {string} [query] Partial match of a server name
     * @param {boolean} [altNames] Match &#x60;query&#x60; value against SAN as well (including wildcard names)
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertsApiInterface
     */
    getTLSCerticates(query?: string, altNames?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetTLSCertsResponse>;

    /**
     * 
     * @summary Resolve ID for a server name
     * @param {string} servername Server name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertsApiInterface
     */
    resolveTLSCertificate(servername: string, options?: any): AxiosPromise<ResolveIdResponse>;

    /**
     * Add a new TLS certificate for a server name or update existing one. You can add a single certificate for each server name but SAN names are supported as well. For example you can add a sertificate for \"mydomain.com\" that includes \"\\*.mydomain.com\" in SAN and the same certificate would be used for requests that do not have it\'s own server name registered but match the SAN value. > NB! you must ensure yourself that the `servername` value is actually listed in certificate\'s common name or SAN as WildDuck is going to use this certificate regardless. 
     * @summary Create or update TLS certificate for server name
     * @param {UpdateTLSCertRequest} updateTLSCertRequest Add a new TLS certificate for a server name or update existing one
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertsApiInterface
     */
    updateTLSCertificate(updateTLSCertRequest: UpdateTLSCertRequest, options?: any): AxiosPromise<UpdateTLSCertResponse>;

}

/**
 * CertsApi - object-oriented interface
 * @export
 * @class CertsApi
 * @extends {BaseAPI}
 */
export class CertsApi extends BaseAPI implements CertsApiInterface {
    /**
     * 
     * @summary Delete a TLS certificate
     * @param {string} cert ID of the TLS certificate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertsApi
     */
    public deleteTlsCert(cert: string, options?: any) {
        return CertsApiFp(this.configuration).deleteTlsCert(cert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request TLS certificate information
     * @param {string} cert ID of the TLS certificate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertsApi
     */
    public getTLSCerticate(cert: string, options?: any) {
        return CertsApiFp(this.configuration).getTLSCerticate(cert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List registered TLS certificates
     * @param {string} [query] Partial match of a server name
     * @param {boolean} [altNames] Match &#x60;query&#x60; value against SAN as well (including wildcard names)
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertsApi
     */
    public getTLSCerticates(query?: string, altNames?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any) {
        return CertsApiFp(this.configuration).getTLSCerticates(query, altNames, limit, page, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resolve ID for a server name
     * @param {string} servername Server name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertsApi
     */
    public resolveTLSCertificate(servername: string, options?: any) {
        return CertsApiFp(this.configuration).resolveTLSCertificate(servername, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new TLS certificate for a server name or update existing one. You can add a single certificate for each server name but SAN names are supported as well. For example you can add a sertificate for \"mydomain.com\" that includes \"\\*.mydomain.com\" in SAN and the same certificate would be used for requests that do not have it\'s own server name registered but match the SAN value. > NB! you must ensure yourself that the `servername` value is actually listed in certificate\'s common name or SAN as WildDuck is going to use this certificate regardless. 
     * @summary Create or update TLS certificate for server name
     * @param {UpdateTLSCertRequest} updateTLSCertRequest Add a new TLS certificate for a server name or update existing one
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertsApi
     */
    public updateTLSCertificate(updateTLSCertRequest: UpdateTLSCertRequest, options?: any) {
        return CertsApiFp(this.configuration).updateTLSCertificate(updateTLSCertRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DKIMApi - axios parameter creator
 * @export
 */
export const DKIMApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a DKIM key
         * @param {string} dkim ID of the DKIM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDkimKey: async (dkim: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dkim' is not null or undefined
            assertParamExists('deleteDkimKey', 'dkim', dkim)
            const localVarPath = `/dkim/{dkim}`
                .replace(`{${"dkim"}}`, encodeURIComponent(String(dkim)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request DKIM information
         * @param {string} dkim ID of the DKIM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDkimKey: async (dkim: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dkim' is not null or undefined
            assertParamExists('getDkimKey', 'dkim', dkim)
            const localVarPath = `/dkim/{dkim}`
                .replace(`{${"dkim"}}`, encodeURIComponent(String(dkim)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List registered DKIM keys
         * @param {string} [query] Partial match of a Domain name
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDkimKeys: async (query?: string, limit?: number, page?: number, next?: string, previous?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dkim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resolve ID for a DKIM domain
         * @param {string} domain DKIM domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveDkim: async (domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('resolveDkim', 'domain', domain)
            const localVarPath = `/dkim/resolve/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name.
         * @summary Create or update DKIM key for domain
         * @param {UpdateDkimKeyRequest} updateDkimKeyRequest Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDkimKey: async (updateDkimKeyRequest: UpdateDkimKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDkimKeyRequest' is not null or undefined
            assertParamExists('updateDkimKey', 'updateDkimKeyRequest', updateDkimKeyRequest)
            const localVarPath = `/dkim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDkimKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DKIMApi - functional programming interface
 * @export
 */
export const DKIMApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DKIMApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a DKIM key
         * @param {string} dkim ID of the DKIM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDkimKey(dkim: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDkimKey(dkim, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request DKIM information
         * @param {string} dkim ID of the DKIM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDkimKey(dkim: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDkimKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDkimKey(dkim, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List registered DKIM keys
         * @param {string} [query] Partial match of a Domain name
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDkimKeys(query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDkimKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDkimKeys(query, limit, page, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resolve ID for a DKIM domain
         * @param {string} domain DKIM domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveDkim(domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolveIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveDkim(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name.
         * @summary Create or update DKIM key for domain
         * @param {UpdateDkimKeyRequest} updateDkimKeyRequest Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDkimKey(updateDkimKeyRequest: UpdateDkimKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateDkimKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDkimKey(updateDkimKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DKIMApi - factory interface
 * @export
 */
export const DKIMApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DKIMApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a DKIM key
         * @param {string} dkim ID of the DKIM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDkimKey(dkim: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteDkimKey(dkim, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request DKIM information
         * @param {string} dkim ID of the DKIM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDkimKey(dkim: string, options?: any): AxiosPromise<GetDkimKeyResponse> {
            return localVarFp.getDkimKey(dkim, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List registered DKIM keys
         * @param {string} [query] Partial match of a Domain name
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDkimKeys(query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetDkimKeysResponse> {
            return localVarFp.getDkimKeys(query, limit, page, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resolve ID for a DKIM domain
         * @param {string} domain DKIM domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveDkim(domain: string, options?: any): AxiosPromise<ResolveIdResponse> {
            return localVarFp.resolveDkim(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name.
         * @summary Create or update DKIM key for domain
         * @param {UpdateDkimKeyRequest} updateDkimKeyRequest Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDkimKey(updateDkimKeyRequest: UpdateDkimKeyRequest, options?: any): AxiosPromise<UpdateDkimKeyResponse> {
            return localVarFp.updateDkimKey(updateDkimKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DKIMApi - interface
 * @export
 * @interface DKIMApi
 */
export interface DKIMApiInterface {
    /**
     * 
     * @summary Delete a DKIM key
     * @param {string} dkim ID of the DKIM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DKIMApiInterface
     */
    deleteDkimKey(dkim: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Request DKIM information
     * @param {string} dkim ID of the DKIM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DKIMApiInterface
     */
    getDkimKey(dkim: string, options?: any): AxiosPromise<GetDkimKeyResponse>;

    /**
     * 
     * @summary List registered DKIM keys
     * @param {string} [query] Partial match of a Domain name
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DKIMApiInterface
     */
    getDkimKeys(query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetDkimKeysResponse>;

    /**
     * 
     * @summary Resolve ID for a DKIM domain
     * @param {string} domain DKIM domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DKIMApiInterface
     */
    resolveDkim(domain: string, options?: any): AxiosPromise<ResolveIdResponse>;

    /**
     * Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name.
     * @summary Create or update DKIM key for domain
     * @param {UpdateDkimKeyRequest} updateDkimKeyRequest Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DKIMApiInterface
     */
    updateDkimKey(updateDkimKeyRequest: UpdateDkimKeyRequest, options?: any): AxiosPromise<UpdateDkimKeyResponse>;

}

/**
 * DKIMApi - object-oriented interface
 * @export
 * @class DKIMApi
 * @extends {BaseAPI}
 */
export class DKIMApi extends BaseAPI implements DKIMApiInterface {
    /**
     * 
     * @summary Delete a DKIM key
     * @param {string} dkim ID of the DKIM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DKIMApi
     */
    public deleteDkimKey(dkim: string, options?: any) {
        return DKIMApiFp(this.configuration).deleteDkimKey(dkim, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request DKIM information
     * @param {string} dkim ID of the DKIM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DKIMApi
     */
    public getDkimKey(dkim: string, options?: any) {
        return DKIMApiFp(this.configuration).getDkimKey(dkim, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List registered DKIM keys
     * @param {string} [query] Partial match of a Domain name
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DKIMApi
     */
    public getDkimKeys(query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any) {
        return DKIMApiFp(this.configuration).getDkimKeys(query, limit, page, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resolve ID for a DKIM domain
     * @param {string} domain DKIM domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DKIMApi
     */
    public resolveDkim(domain: string, options?: any) {
        return DKIMApiFp(this.configuration).resolveDkim(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name.
     * @summary Create or update DKIM key for domain
     * @param {UpdateDkimKeyRequest} updateDkimKeyRequest Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DKIMApi
     */
    public updateDkimKey(updateDkimKeyRequest: UpdateDkimKeyRequest, options?: any) {
        return DKIMApiFp(this.configuration).updateDkimKey(updateDkimKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DomainAccessApi - axios parameter creator
 * @export
 */
export const DomainAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If an email is sent from a domain that is listed in the allowlist then it is never marked as spam. Lists apply for tagged users.
         * @summary Add domain to allowlist
         * @param {string} tag Tag to look for
         * @param {CreateAllowedDomainRequest} createAllowedDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedDomain: async (tag: string, createAllowedDomainRequest: CreateAllowedDomainRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('createAllowedDomain', 'tag', tag)
            // verify required parameter 'createAllowedDomainRequest' is not null or undefined
            assertParamExists('createAllowedDomain', 'createAllowedDomainRequest', createAllowedDomainRequest)
            const localVarPath = `/domainaccess/{tag}/allow`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAllowedDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If an email is sent from a domain that is listed in the blocklist then it is always marked as spam. Lists apply for tagged users.
         * @summary Add domain to blocklist
         * @param {string} tag Tag to look for
         * @param {CreateBlockedDomainRequest} createBlockedDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlockedDomain: async (tag: string, createBlockedDomainRequest: CreateBlockedDomainRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('createBlockedDomain', 'tag', tag)
            // verify required parameter 'createBlockedDomainRequest' is not null or undefined
            assertParamExists('createBlockedDomain', 'createBlockedDomainRequest', createBlockedDomainRequest)
            const localVarPath = `/domainaccess/{tag}/block`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBlockedDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Domain from listing
         * @param {string} domain Listed domains unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainListing: async (domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('deleteDomainListing', 'domain', domain)
            const localVarPath = `/domainaccess/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List allowlisted domains
         * @param {string} tag Tag to look for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedDomain: async (tag: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getAllowedDomain', 'tag', tag)
            const localVarPath = `/domainaccess/{tag}/allow`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List blocklisted domains
         * @param {string} tag Tag to look for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockedDomain: async (tag: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getBlockedDomain', 'tag', tag)
            const localVarPath = `/domainaccess/{tag}/block`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainAccessApi - functional programming interface
 * @export
 */
export const DomainAccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainAccessApiAxiosParamCreator(configuration)
    return {
        /**
         * If an email is sent from a domain that is listed in the allowlist then it is never marked as spam. Lists apply for tagged users.
         * @summary Add domain to allowlist
         * @param {string} tag Tag to look for
         * @param {CreateAllowedDomainRequest} createAllowedDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedDomain(tag: string, createAllowedDomainRequest: CreateAllowedDomainRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAllowedDomainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAllowedDomain(tag, createAllowedDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If an email is sent from a domain that is listed in the blocklist then it is always marked as spam. Lists apply for tagged users.
         * @summary Add domain to blocklist
         * @param {string} tag Tag to look for
         * @param {CreateBlockedDomainRequest} createBlockedDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBlockedDomain(tag: string, createBlockedDomainRequest: CreateBlockedDomainRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBlockedDomainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBlockedDomain(tag, createBlockedDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Domain from listing
         * @param {string} domain Listed domains unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainListing(domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainListing(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List allowlisted domains
         * @param {string} tag Tag to look for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedDomain(tag: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllowedDomainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllowedDomain(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List blocklisted domains
         * @param {string} tag Tag to look for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockedDomain(tag: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBlockedDomainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockedDomain(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DomainAccessApi - factory interface
 * @export
 */
export const DomainAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainAccessApiFp(configuration)
    return {
        /**
         * If an email is sent from a domain that is listed in the allowlist then it is never marked as spam. Lists apply for tagged users.
         * @summary Add domain to allowlist
         * @param {string} tag Tag to look for
         * @param {CreateAllowedDomainRequest} createAllowedDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedDomain(tag: string, createAllowedDomainRequest: CreateAllowedDomainRequest, options?: any): AxiosPromise<CreateAllowedDomainResponse> {
            return localVarFp.createAllowedDomain(tag, createAllowedDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If an email is sent from a domain that is listed in the blocklist then it is always marked as spam. Lists apply for tagged users.
         * @summary Add domain to blocklist
         * @param {string} tag Tag to look for
         * @param {CreateBlockedDomainRequest} createBlockedDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlockedDomain(tag: string, createBlockedDomainRequest: CreateBlockedDomainRequest, options?: any): AxiosPromise<CreateBlockedDomainResponse> {
            return localVarFp.createBlockedDomain(tag, createBlockedDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Domain from listing
         * @param {string} domain Listed domains unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainListing(domain: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteDomainListing(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List allowlisted domains
         * @param {string} tag Tag to look for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedDomain(tag: string, options?: any): AxiosPromise<GetAllowedDomainResponse> {
            return localVarFp.getAllowedDomain(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List blocklisted domains
         * @param {string} tag Tag to look for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockedDomain(tag: string, options?: any): AxiosPromise<GetBlockedDomainResponse> {
            return localVarFp.getBlockedDomain(tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainAccessApi - interface
 * @export
 * @interface DomainAccessApi
 */
export interface DomainAccessApiInterface {
    /**
     * If an email is sent from a domain that is listed in the allowlist then it is never marked as spam. Lists apply for tagged users.
     * @summary Add domain to allowlist
     * @param {string} tag Tag to look for
     * @param {CreateAllowedDomainRequest} createAllowedDomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAccessApiInterface
     */
    createAllowedDomain(tag: string, createAllowedDomainRequest: CreateAllowedDomainRequest, options?: any): AxiosPromise<CreateAllowedDomainResponse>;

    /**
     * If an email is sent from a domain that is listed in the blocklist then it is always marked as spam. Lists apply for tagged users.
     * @summary Add domain to blocklist
     * @param {string} tag Tag to look for
     * @param {CreateBlockedDomainRequest} createBlockedDomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAccessApiInterface
     */
    createBlockedDomain(tag: string, createBlockedDomainRequest: CreateBlockedDomainRequest, options?: any): AxiosPromise<CreateBlockedDomainResponse>;

    /**
     * 
     * @summary Delete a Domain from listing
     * @param {string} domain Listed domains unique ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAccessApiInterface
     */
    deleteDomainListing(domain: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary List allowlisted domains
     * @param {string} tag Tag to look for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAccessApiInterface
     */
    getAllowedDomain(tag: string, options?: any): AxiosPromise<GetAllowedDomainResponse>;

    /**
     * 
     * @summary List blocklisted domains
     * @param {string} tag Tag to look for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAccessApiInterface
     */
    getBlockedDomain(tag: string, options?: any): AxiosPromise<GetBlockedDomainResponse>;

}

/**
 * DomainAccessApi - object-oriented interface
 * @export
 * @class DomainAccessApi
 * @extends {BaseAPI}
 */
export class DomainAccessApi extends BaseAPI implements DomainAccessApiInterface {
    /**
     * If an email is sent from a domain that is listed in the allowlist then it is never marked as spam. Lists apply for tagged users.
     * @summary Add domain to allowlist
     * @param {string} tag Tag to look for
     * @param {CreateAllowedDomainRequest} createAllowedDomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAccessApi
     */
    public createAllowedDomain(tag: string, createAllowedDomainRequest: CreateAllowedDomainRequest, options?: any) {
        return DomainAccessApiFp(this.configuration).createAllowedDomain(tag, createAllowedDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If an email is sent from a domain that is listed in the blocklist then it is always marked as spam. Lists apply for tagged users.
     * @summary Add domain to blocklist
     * @param {string} tag Tag to look for
     * @param {CreateBlockedDomainRequest} createBlockedDomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAccessApi
     */
    public createBlockedDomain(tag: string, createBlockedDomainRequest: CreateBlockedDomainRequest, options?: any) {
        return DomainAccessApiFp(this.configuration).createBlockedDomain(tag, createBlockedDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Domain from listing
     * @param {string} domain Listed domains unique ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAccessApi
     */
    public deleteDomainListing(domain: string, options?: any) {
        return DomainAccessApiFp(this.configuration).deleteDomainListing(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List allowlisted domains
     * @param {string} tag Tag to look for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAccessApi
     */
    public getAllowedDomain(tag: string, options?: any) {
        return DomainAccessApiFp(this.configuration).getAllowedDomain(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List blocklisted domains
     * @param {string} tag Tag to look for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAccessApi
     */
    public getBlockedDomain(tag: string, options?: any) {
        return DomainAccessApiFp(this.configuration).getBlockedDomain(tag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DomainAliasesApi - axios parameter creator
 * @export
 */
export const DomainAliasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new Alias for a Domain. This allows to accept mail on username@domain and username@alias
         * @summary Create new Domain Alias
         * @param {CreateDomainAliasRequest} createDomainAliasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainAlias: async (createDomainAliasRequest: CreateDomainAliasRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDomainAliasRequest' is not null or undefined
            assertParamExists('createDomainAlias', 'createDomainAliasRequest', createDomainAliasRequest)
            const localVarPath = `/domainaliases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDomainAliasRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an Alias
         * @param {string} alias ID of the Alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainAlias: async (alias: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('deleteDomainAlias', 'alias', alias)
            const localVarPath = `/domainaliases/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Alias information
         * @param {string} alias ID of the Alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainAlias: async (alias: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('getDomainAlias', 'alias', alias)
            const localVarPath = `/domainaliases/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List registered Domain Aliases
         * @param {string} [query] Partial match of a Domain Alias or Domain name
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainAliases: async (query?: string, limit?: number, page?: number, next?: string, previous?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/domainaliases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resolve ID for a domain aias
         * @param {string} alias Alias domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveDomainAlias: async (alias: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('resolveDomainAlias', 'alias', alias)
            const localVarPath = `/domainaliases/resolve/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainAliasesApi - functional programming interface
 * @export
 */
export const DomainAliasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainAliasesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new Alias for a Domain. This allows to accept mail on username@domain and username@alias
         * @summary Create new Domain Alias
         * @param {CreateDomainAliasRequest} createDomainAliasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainAlias(createDomainAliasRequest: CreateDomainAliasRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainAliasResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainAlias(createDomainAliasRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an Alias
         * @param {string} alias ID of the Alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainAlias(alias: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainAlias(alias, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Alias information
         * @param {string} alias ID of the Alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainAlias(alias: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainAliasResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainAlias(alias, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List registered Domain Aliases
         * @param {string} [query] Partial match of a Domain Alias or Domain name
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainAliases(query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainAliasesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainAliases(query, limit, page, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resolve ID for a domain aias
         * @param {string} alias Alias domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveDomainAlias(alias: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolveIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveDomainAlias(alias, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DomainAliasesApi - factory interface
 * @export
 */
export const DomainAliasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainAliasesApiFp(configuration)
    return {
        /**
         * Add a new Alias for a Domain. This allows to accept mail on username@domain and username@alias
         * @summary Create new Domain Alias
         * @param {CreateDomainAliasRequest} createDomainAliasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainAlias(createDomainAliasRequest: CreateDomainAliasRequest, options?: any): AxiosPromise<CreateDomainAliasResponse> {
            return localVarFp.createDomainAlias(createDomainAliasRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an Alias
         * @param {string} alias ID of the Alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainAlias(alias: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteDomainAlias(alias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Alias information
         * @param {string} alias ID of the Alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainAlias(alias: string, options?: any): AxiosPromise<GetDomainAliasResponse> {
            return localVarFp.getDomainAlias(alias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List registered Domain Aliases
         * @param {string} [query] Partial match of a Domain Alias or Domain name
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainAliases(query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetDomainAliasesResponse> {
            return localVarFp.getDomainAliases(query, limit, page, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resolve ID for a domain aias
         * @param {string} alias Alias domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveDomainAlias(alias: string, options?: any): AxiosPromise<ResolveIdResponse> {
            return localVarFp.resolveDomainAlias(alias, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainAliasesApi - interface
 * @export
 * @interface DomainAliasesApi
 */
export interface DomainAliasesApiInterface {
    /**
     * Add a new Alias for a Domain. This allows to accept mail on username@domain and username@alias
     * @summary Create new Domain Alias
     * @param {CreateDomainAliasRequest} createDomainAliasRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAliasesApiInterface
     */
    createDomainAlias(createDomainAliasRequest: CreateDomainAliasRequest, options?: any): AxiosPromise<CreateDomainAliasResponse>;

    /**
     * 
     * @summary Delete an Alias
     * @param {string} alias ID of the Alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAliasesApiInterface
     */
    deleteDomainAlias(alias: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Request Alias information
     * @param {string} alias ID of the Alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAliasesApiInterface
     */
    getDomainAlias(alias: string, options?: any): AxiosPromise<GetDomainAliasResponse>;

    /**
     * 
     * @summary List registered Domain Aliases
     * @param {string} [query] Partial match of a Domain Alias or Domain name
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAliasesApiInterface
     */
    getDomainAliases(query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetDomainAliasesResponse>;

    /**
     * 
     * @summary Resolve ID for a domain aias
     * @param {string} alias Alias domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAliasesApiInterface
     */
    resolveDomainAlias(alias: string, options?: any): AxiosPromise<ResolveIdResponse>;

}

/**
 * DomainAliasesApi - object-oriented interface
 * @export
 * @class DomainAliasesApi
 * @extends {BaseAPI}
 */
export class DomainAliasesApi extends BaseAPI implements DomainAliasesApiInterface {
    /**
     * Add a new Alias for a Domain. This allows to accept mail on username@domain and username@alias
     * @summary Create new Domain Alias
     * @param {CreateDomainAliasRequest} createDomainAliasRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAliasesApi
     */
    public createDomainAlias(createDomainAliasRequest: CreateDomainAliasRequest, options?: any) {
        return DomainAliasesApiFp(this.configuration).createDomainAlias(createDomainAliasRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an Alias
     * @param {string} alias ID of the Alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAliasesApi
     */
    public deleteDomainAlias(alias: string, options?: any) {
        return DomainAliasesApiFp(this.configuration).deleteDomainAlias(alias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Alias information
     * @param {string} alias ID of the Alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAliasesApi
     */
    public getDomainAlias(alias: string, options?: any) {
        return DomainAliasesApiFp(this.configuration).getDomainAlias(alias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List registered Domain Aliases
     * @param {string} [query] Partial match of a Domain Alias or Domain name
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAliasesApi
     */
    public getDomainAliases(query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any) {
        return DomainAliasesApiFp(this.configuration).getDomainAliases(query, limit, page, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resolve ID for a domain aias
     * @param {string} alias Alias domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainAliasesApi
     */
    public resolveDomainAlias(alias: string, options?: any) {
        return DomainAliasesApiFp(this.configuration).resolveDomainAlias(alias, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExportApi - axios parameter creator
 * @export
 */
export const ExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export data for matching users. Export dump does not include emails, only account structure (user data, password hashes, mailboxes, filters, etc.). A special \"export\"-role access token is required for exporting and importing.
         * @summary Export data
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExport: async (inlineObject1: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('createExport', 'inlineObject1', inlineObject1)
            const localVarPath = `/data/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import data from an export dump. If a database entry already exists, it is not modified. A special \"export\"-role access token is required for exporting and importing.
         * @summary Import user data
         * @param {any} body Import user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImport: async (body: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createImport', 'body', body)
            const localVarPath = `/data/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 * @export
 */
export const ExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportApiAxiosParamCreator(configuration)
    return {
        /**
         * Export data for matching users. Export dump does not include emails, only account structure (user data, password hashes, mailboxes, filters, etc.). A special \"export\"-role access token is required for exporting and importing.
         * @summary Export data
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExport(inlineObject1: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExport(inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import data from an export dump. If a database entry already exists, it is not modified. A special \"export\"-role access token is required for exporting and importing.
         * @summary Import user data
         * @param {any} body Import user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImport(body: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImport(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExportApi - factory interface
 * @export
 */
export const ExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportApiFp(configuration)
    return {
        /**
         * Export data for matching users. Export dump does not include emails, only account structure (user data, password hashes, mailboxes, filters, etc.). A special \"export\"-role access token is required for exporting and importing.
         * @summary Export data
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExport(inlineObject1: InlineObject1, options?: any): AxiosPromise<any> {
            return localVarFp.createExport(inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * Import data from an export dump. If a database entry already exists, it is not modified. A special \"export\"-role access token is required for exporting and importing.
         * @summary Import user data
         * @param {any} body Import user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImport(body: any, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.createImport(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportApi - interface
 * @export
 * @interface ExportApi
 */
export interface ExportApiInterface {
    /**
     * Export data for matching users. Export dump does not include emails, only account structure (user data, password hashes, mailboxes, filters, etc.). A special \"export\"-role access token is required for exporting and importing.
     * @summary Export data
     * @param {InlineObject1} inlineObject1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApiInterface
     */
    createExport(inlineObject1: InlineObject1, options?: any): AxiosPromise<any>;

    /**
     * Import data from an export dump. If a database entry already exists, it is not modified. A special \"export\"-role access token is required for exporting and importing.
     * @summary Import user data
     * @param {any} body Import user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApiInterface
     */
    createImport(body: any, options?: any): AxiosPromise<InlineResponse2001>;

}

/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
export class ExportApi extends BaseAPI implements ExportApiInterface {
    /**
     * Export data for matching users. Export dump does not include emails, only account structure (user data, password hashes, mailboxes, filters, etc.). A special \"export\"-role access token is required for exporting and importing.
     * @summary Export data
     * @param {InlineObject1} inlineObject1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public createExport(inlineObject1: InlineObject1, options?: any) {
        return ExportApiFp(this.configuration).createExport(inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import data from an export dump. If a database entry already exists, it is not modified. A special \"export\"-role access token is required for exporting and importing.
     * @summary Import user data
     * @param {any} body Import user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public createImport(body: any, options?: any) {
        return ExportApiFp(this.configuration).createImport(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FiltersApi - axios parameter creator
 * @export
 */
export const FiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new Filter
         * @param {string} user Users unique ID
         * @param {CreateFilterRequest} createFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilter: async (user: string, createFilterRequest: CreateFilterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createFilter', 'user', user)
            // verify required parameter 'createFilterRequest' is not null or undefined
            assertParamExists('createFilter', 'createFilterRequest', createFilterRequest)
            const localVarPath = `/users/{user}/filters`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Filter
         * @param {string} user Users unique ID
         * @param {string} filter Filters unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilter: async (user: string, filter: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('deleteFilter', 'user', user)
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('deleteFilter', 'filter', filter)
            const localVarPath = `/users/{user}/filters/{filter}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"filter"}}`, encodeURIComponent(String(filter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Filters
         * @param {string} [forward] Partial match of a forward email address or URL
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {number} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {number} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFilters: async (forward?: string, metaData?: boolean, limit?: number, page?: number, next?: number, previous?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (forward !== undefined) {
                localVarQueryParameter['forward'] = forward;
            }

            if (metaData !== undefined) {
                localVarQueryParameter['metaData'] = metaData;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Filter information
         * @param {string} user Users unique ID
         * @param {string} filter Filters unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilter: async (user: string, filter: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getFilter', 'user', user)
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('getFilter', 'filter', filter)
            const localVarPath = `/users/{user}/filters/{filter}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"filter"}}`, encodeURIComponent(String(filter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Filters for a User
         * @param {string} user Users unique ID
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters: async (user: string, metaData?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getFilters', 'user', user)
            const localVarPath = `/users/{user}/filters`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (metaData !== undefined) {
                localVarQueryParameter['metaData'] = metaData;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method updates Filter data. To unset a value, use empty strings
         * @summary Update Filter information
         * @param {string} user Users unique ID
         * @param {string} filter Filters unique ID
         * @param {UpdateFilterRequest} updateFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFilter: async (user: string, filter: string, updateFilterRequest: UpdateFilterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateFilter', 'user', user)
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('updateFilter', 'filter', filter)
            // verify required parameter 'updateFilterRequest' is not null or undefined
            assertParamExists('updateFilter', 'updateFilterRequest', updateFilterRequest)
            const localVarPath = `/users/{user}/filters/{filter}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"filter"}}`, encodeURIComponent(String(filter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FiltersApi - functional programming interface
 * @export
 */
export const FiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new Filter
         * @param {string} user Users unique ID
         * @param {CreateFilterRequest} createFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFilter(user: string, createFilterRequest: CreateFilterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateFilterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFilter(user, createFilterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Filter
         * @param {string} user Users unique ID
         * @param {string} filter Filters unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFilter(user: string, filter: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFilter(user, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Filters
         * @param {string} [forward] Partial match of a forward email address or URL
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {number} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {number} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFilters(forward?: string, metaData?: boolean, limit?: number, page?: number, next?: number, previous?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllFiltersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFilters(forward, metaData, limit, page, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Filter information
         * @param {string} user Users unique ID
         * @param {string} filter Filters unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilter(user: string, filter: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFilterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilter(user, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Filters for a User
         * @param {string} user Users unique ID
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilters(user: string, metaData?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFiltersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilters(user, metaData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method updates Filter data. To unset a value, use empty strings
         * @summary Update Filter information
         * @param {string} user Users unique ID
         * @param {string} filter Filters unique ID
         * @param {UpdateFilterRequest} updateFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFilter(user: string, filter: string, updateFilterRequest: UpdateFilterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateFilterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFilter(user, filter, updateFilterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FiltersApi - factory interface
 * @export
 */
export const FiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FiltersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new Filter
         * @param {string} user Users unique ID
         * @param {CreateFilterRequest} createFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilter(user: string, createFilterRequest: CreateFilterRequest, options?: any): AxiosPromise<UpdateFilterResponse> {
            return localVarFp.createFilter(user, createFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Filter
         * @param {string} user Users unique ID
         * @param {string} filter Filters unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilter(user: string, filter: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteFilter(user, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Filters
         * @param {string} [forward] Partial match of a forward email address or URL
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {number} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {number} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFilters(forward?: string, metaData?: boolean, limit?: number, page?: number, next?: number, previous?: number, options?: any): AxiosPromise<GetAllFiltersResponse> {
            return localVarFp.getAllFilters(forward, metaData, limit, page, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Filter information
         * @param {string} user Users unique ID
         * @param {string} filter Filters unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilter(user: string, filter: string, options?: any): AxiosPromise<GetFilterResponse> {
            return localVarFp.getFilter(user, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Filters for a User
         * @param {string} user Users unique ID
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters(user: string, metaData?: boolean, options?: any): AxiosPromise<GetFiltersResponse> {
            return localVarFp.getFilters(user, metaData, options).then((request) => request(axios, basePath));
        },
        /**
         * This method updates Filter data. To unset a value, use empty strings
         * @summary Update Filter information
         * @param {string} user Users unique ID
         * @param {string} filter Filters unique ID
         * @param {UpdateFilterRequest} updateFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFilter(user: string, filter: string, updateFilterRequest: UpdateFilterRequest, options?: any): AxiosPromise<UpdateFilterResponse> {
            return localVarFp.updateFilter(user, filter, updateFilterRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FiltersApi - interface
 * @export
 * @interface FiltersApi
 */
export interface FiltersApiInterface {
    /**
     * 
     * @summary Create new Filter
     * @param {string} user Users unique ID
     * @param {CreateFilterRequest} createFilterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    createFilter(user: string, createFilterRequest: CreateFilterRequest, options?: any): AxiosPromise<UpdateFilterResponse>;

    /**
     * 
     * @summary Delete a Filter
     * @param {string} user Users unique ID
     * @param {string} filter Filters unique ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    deleteFilter(user: string, filter: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary List all Filters
     * @param {string} [forward] Partial match of a forward email address or URL
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {number} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {number} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    getAllFilters(forward?: string, metaData?: boolean, limit?: number, page?: number, next?: number, previous?: number, options?: any): AxiosPromise<GetAllFiltersResponse>;

    /**
     * 
     * @summary Request Filter information
     * @param {string} user Users unique ID
     * @param {string} filter Filters unique ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    getFilter(user: string, filter: string, options?: any): AxiosPromise<GetFilterResponse>;

    /**
     * 
     * @summary List Filters for a User
     * @param {string} user Users unique ID
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    getFilters(user: string, metaData?: boolean, options?: any): AxiosPromise<GetFiltersResponse>;

    /**
     * This method updates Filter data. To unset a value, use empty strings
     * @summary Update Filter information
     * @param {string} user Users unique ID
     * @param {string} filter Filters unique ID
     * @param {UpdateFilterRequest} updateFilterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    updateFilter(user: string, filter: string, updateFilterRequest: UpdateFilterRequest, options?: any): AxiosPromise<UpdateFilterResponse>;

}

/**
 * FiltersApi - object-oriented interface
 * @export
 * @class FiltersApi
 * @extends {BaseAPI}
 */
export class FiltersApi extends BaseAPI implements FiltersApiInterface {
    /**
     * 
     * @summary Create new Filter
     * @param {string} user Users unique ID
     * @param {CreateFilterRequest} createFilterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public createFilter(user: string, createFilterRequest: CreateFilterRequest, options?: any) {
        return FiltersApiFp(this.configuration).createFilter(user, createFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Filter
     * @param {string} user Users unique ID
     * @param {string} filter Filters unique ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public deleteFilter(user: string, filter: string, options?: any) {
        return FiltersApiFp(this.configuration).deleteFilter(user, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Filters
     * @param {string} [forward] Partial match of a forward email address or URL
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {number} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {number} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public getAllFilters(forward?: string, metaData?: boolean, limit?: number, page?: number, next?: number, previous?: number, options?: any) {
        return FiltersApiFp(this.configuration).getAllFilters(forward, metaData, limit, page, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Filter information
     * @param {string} user Users unique ID
     * @param {string} filter Filters unique ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public getFilter(user: string, filter: string, options?: any) {
        return FiltersApiFp(this.configuration).getFilter(user, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Filters for a User
     * @param {string} user Users unique ID
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public getFilters(user: string, metaData?: boolean, options?: any) {
        return FiltersApiFp(this.configuration).getFilters(user, metaData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method updates Filter data. To unset a value, use empty strings
     * @summary Update Filter information
     * @param {string} user Users unique ID
     * @param {string} filter Filters unique ID
     * @param {UpdateFilterRequest} updateFilterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public updateFilter(user: string, filter: string, updateFilterRequest: UpdateFilterRequest, options?: any) {
        return FiltersApiFp(this.configuration).updateFilter(user, filter, updateFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MailboxesApi - axios parameter creator
 * @export
 */
export const MailboxesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new Mailbox
         * @param {string} user Users unique ID
         * @param {CreateMailboxRequest} createMailboxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMailbox: async (user: string, createMailboxRequest: CreateMailboxRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createMailbox', 'user', user)
            // verify required parameter 'createMailboxRequest' is not null or undefined
            assertParamExists('createMailbox', 'createMailboxRequest', createMailboxRequest)
            const localVarPath = `/users/{user}/mailboxes`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMailboxRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Mailbox
         * @param {string} user Users unique ID
         * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMailbox: async (user: string, mailbox: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('deleteMailbox', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('deleteMailbox', 'mailbox', mailbox)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Mailbox information
         * @param {string} user Users unique ID
         * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailbox: async (user: string, mailbox: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getMailbox', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('getMailbox', 'mailbox', mailbox)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Mailboxes for a User
         * @param {string} user Users unique ID
         * @param {boolean} [specialUse] Should the response include only folders with specialUse flag set.
         * @param {boolean} [showHidden] Hidden folders are not included in the listing by default.
         * @param {boolean} [counters] Should the response include counters (total + unseen). Counters come with some overhead.
         * @param {boolean} [sizes] Should the response include mailbox size in bytes. Size numbers come with a lot of overhead as an aggregated query is ran.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailboxes: async (user: string, specialUse?: boolean, showHidden?: boolean, counters?: boolean, sizes?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getMailboxes', 'user', user)
            const localVarPath = `/users/{user}/mailboxes`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (specialUse !== undefined) {
                localVarQueryParameter['specialUse'] = specialUse;
            }

            if (showHidden !== undefined) {
                localVarQueryParameter['showHidden'] = showHidden;
            }

            if (counters !== undefined) {
                localVarQueryParameter['counters'] = counters;
            }

            if (sizes !== undefined) {
                localVarQueryParameter['sizes'] = sizes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Mailbox information
         * @param {string} user Users unique ID
         * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
         * @param {UpdateMailboxRequest} updateMailboxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMailbox: async (user: string, mailbox: string, updateMailboxRequest: UpdateMailboxRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateMailbox', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('updateMailbox', 'mailbox', mailbox)
            // verify required parameter 'updateMailboxRequest' is not null or undefined
            assertParamExists('updateMailbox', 'updateMailboxRequest', updateMailboxRequest)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMailboxRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailboxesApi - functional programming interface
 * @export
 */
export const MailboxesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MailboxesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new Mailbox
         * @param {string} user Users unique ID
         * @param {CreateMailboxRequest} createMailboxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMailbox(user: string, createMailboxRequest: CreateMailboxRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMailboxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMailbox(user, createMailboxRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Mailbox
         * @param {string} user Users unique ID
         * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMailbox(user: string, mailbox: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMailbox(user, mailbox, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Mailbox information
         * @param {string} user Users unique ID
         * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMailbox(user: string, mailbox: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMailboxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailbox(user, mailbox, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Mailboxes for a User
         * @param {string} user Users unique ID
         * @param {boolean} [specialUse] Should the response include only folders with specialUse flag set.
         * @param {boolean} [showHidden] Hidden folders are not included in the listing by default.
         * @param {boolean} [counters] Should the response include counters (total + unseen). Counters come with some overhead.
         * @param {boolean} [sizes] Should the response include mailbox size in bytes. Size numbers come with a lot of overhead as an aggregated query is ran.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMailboxes(user: string, specialUse?: boolean, showHidden?: boolean, counters?: boolean, sizes?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMailboxesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailboxes(user, specialUse, showHidden, counters, sizes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Mailbox information
         * @param {string} user Users unique ID
         * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
         * @param {UpdateMailboxRequest} updateMailboxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMailbox(user: string, mailbox: string, updateMailboxRequest: UpdateMailboxRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMailbox(user, mailbox, updateMailboxRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MailboxesApi - factory interface
 * @export
 */
export const MailboxesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MailboxesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new Mailbox
         * @param {string} user Users unique ID
         * @param {CreateMailboxRequest} createMailboxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMailbox(user: string, createMailboxRequest: CreateMailboxRequest, options?: any): AxiosPromise<CreateMailboxResponse> {
            return localVarFp.createMailbox(user, createMailboxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Mailbox
         * @param {string} user Users unique ID
         * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMailbox(user: string, mailbox: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteMailbox(user, mailbox, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Mailbox information
         * @param {string} user Users unique ID
         * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailbox(user: string, mailbox: string, options?: any): AxiosPromise<GetMailboxResponse> {
            return localVarFp.getMailbox(user, mailbox, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Mailboxes for a User
         * @param {string} user Users unique ID
         * @param {boolean} [specialUse] Should the response include only folders with specialUse flag set.
         * @param {boolean} [showHidden] Hidden folders are not included in the listing by default.
         * @param {boolean} [counters] Should the response include counters (total + unseen). Counters come with some overhead.
         * @param {boolean} [sizes] Should the response include mailbox size in bytes. Size numbers come with a lot of overhead as an aggregated query is ran.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailboxes(user: string, specialUse?: boolean, showHidden?: boolean, counters?: boolean, sizes?: boolean, options?: any): AxiosPromise<GetMailboxesResponse> {
            return localVarFp.getMailboxes(user, specialUse, showHidden, counters, sizes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Mailbox information
         * @param {string} user Users unique ID
         * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
         * @param {UpdateMailboxRequest} updateMailboxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMailbox(user: string, mailbox: string, updateMailboxRequest: UpdateMailboxRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateMailbox(user, mailbox, updateMailboxRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MailboxesApi - interface
 * @export
 * @interface MailboxesApi
 */
export interface MailboxesApiInterface {
    /**
     * 
     * @summary Create new Mailbox
     * @param {string} user Users unique ID
     * @param {CreateMailboxRequest} createMailboxRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxesApiInterface
     */
    createMailbox(user: string, createMailboxRequest: CreateMailboxRequest, options?: any): AxiosPromise<CreateMailboxResponse>;

    /**
     * 
     * @summary Delete a Mailbox
     * @param {string} user Users unique ID
     * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxesApiInterface
     */
    deleteMailbox(user: string, mailbox: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Request Mailbox information
     * @param {string} user Users unique ID
     * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxesApiInterface
     */
    getMailbox(user: string, mailbox: string, options?: any): AxiosPromise<GetMailboxResponse>;

    /**
     * 
     * @summary List Mailboxes for a User
     * @param {string} user Users unique ID
     * @param {boolean} [specialUse] Should the response include only folders with specialUse flag set.
     * @param {boolean} [showHidden] Hidden folders are not included in the listing by default.
     * @param {boolean} [counters] Should the response include counters (total + unseen). Counters come with some overhead.
     * @param {boolean} [sizes] Should the response include mailbox size in bytes. Size numbers come with a lot of overhead as an aggregated query is ran.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxesApiInterface
     */
    getMailboxes(user: string, specialUse?: boolean, showHidden?: boolean, counters?: boolean, sizes?: boolean, options?: any): AxiosPromise<GetMailboxesResponse>;

    /**
     * 
     * @summary Update Mailbox information
     * @param {string} user Users unique ID
     * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
     * @param {UpdateMailboxRequest} updateMailboxRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxesApiInterface
     */
    updateMailbox(user: string, mailbox: string, updateMailboxRequest: UpdateMailboxRequest, options?: any): AxiosPromise<SuccessResponse>;

}

/**
 * MailboxesApi - object-oriented interface
 * @export
 * @class MailboxesApi
 * @extends {BaseAPI}
 */
export class MailboxesApi extends BaseAPI implements MailboxesApiInterface {
    /**
     * 
     * @summary Create new Mailbox
     * @param {string} user Users unique ID
     * @param {CreateMailboxRequest} createMailboxRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxesApi
     */
    public createMailbox(user: string, createMailboxRequest: CreateMailboxRequest, options?: any) {
        return MailboxesApiFp(this.configuration).createMailbox(user, createMailboxRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Mailbox
     * @param {string} user Users unique ID
     * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxesApi
     */
    public deleteMailbox(user: string, mailbox: string, options?: any) {
        return MailboxesApiFp(this.configuration).deleteMailbox(user, mailbox, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Mailbox information
     * @param {string} user Users unique ID
     * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxesApi
     */
    public getMailbox(user: string, mailbox: string, options?: any) {
        return MailboxesApiFp(this.configuration).getMailbox(user, mailbox, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Mailboxes for a User
     * @param {string} user Users unique ID
     * @param {boolean} [specialUse] Should the response include only folders with specialUse flag set.
     * @param {boolean} [showHidden] Hidden folders are not included in the listing by default.
     * @param {boolean} [counters] Should the response include counters (total + unseen). Counters come with some overhead.
     * @param {boolean} [sizes] Should the response include mailbox size in bytes. Size numbers come with a lot of overhead as an aggregated query is ran.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxesApi
     */
    public getMailboxes(user: string, specialUse?: boolean, showHidden?: boolean, counters?: boolean, sizes?: boolean, options?: any) {
        return MailboxesApiFp(this.configuration).getMailboxes(user, specialUse, showHidden, counters, sizes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Mailbox information
     * @param {string} user Users unique ID
     * @param {string} mailbox Mailbox unique ID. Special use folders and INBOX can not be deleted
     * @param {UpdateMailboxRequest} updateMailboxRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxesApi
     */
    public updateMailbox(user: string, mailbox: string, updateMailboxRequest: UpdateMailboxRequest, options?: any) {
        return MailboxesApiFp(this.configuration).updateMailbox(user, mailbox, updateMailboxRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a Message
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (user: string, mailbox: string, message: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('deleteMessage', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('deleteMessage', 'mailbox', mailbox)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('deleteMessage', 'message', message)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}/messages/{message}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)))
                .replace(`{${"message"}}`, encodeURIComponent(String(message)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all Messages from a Mailbox
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {boolean} [async] Schedule deletion task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessagesInMailbox: async (user: string, mailbox: string, async?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('deleteMessagesInMailbox', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('deleteMessagesInMailbox', 'mailbox', mailbox)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}/messages`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can delete outbound emails that are still in queue. Queue ID can be found from the `outbound` property of a stored email.
         * @summary Delete an Outbound Message
         * @param {string} user ID of the User
         * @param {string} queueId Outbound queue ID of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOutboundMessage: async (user: string, queueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('deleteOutboundMessage', 'user', user)
            // verify required parameter 'queueId' is not null or undefined
            assertParamExists('deleteOutboundMessage', 'queueId', queueId)
            const localVarPath = `/users/{user}/outbound/{queueId}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"queueId"}}`, encodeURIComponent(String(queueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
         * @summary Forward stored Message
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {ForwardStoredMessageRequest} forwardStoredMessageRequest This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardStoredMessage: async (user: string, mailbox: string, message: number, forwardStoredMessageRequest: ForwardStoredMessageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('forwardStoredMessage', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('forwardStoredMessage', 'mailbox', mailbox)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('forwardStoredMessage', 'message', message)
            // verify required parameter 'forwardStoredMessageRequest' is not null or undefined
            assertParamExists('forwardStoredMessage', 'forwardStoredMessageRequest', forwardStoredMessageRequest)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}/messages/{message}/forward`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)))
                .replace(`{${"message"}}`, encodeURIComponent(String(message)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forwardStoredMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Message information
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {boolean} [markAsSeen] If true then marks message as seen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage: async (user: string, mailbox: string, message: number, markAsSeen?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getMessage', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('getMessage', 'mailbox', mailbox)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('getMessage', 'message', message)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}/messages/{message}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)))
                .replace(`{${"message"}}`, encodeURIComponent(String(message)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (markAsSeen !== undefined) {
                localVarQueryParameter['markAsSeen'] = markAsSeen;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method returns attachment file contents in binary form
         * @summary Download Attachment
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message ID of the Message
         * @param {string} attachment ID of the Attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageAttachment: async (user: string, mailbox: string, message: number, attachment: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getMessageAttachment', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('getMessageAttachment', 'mailbox', mailbox)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('getMessageAttachment', 'message', message)
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('getMessageAttachment', 'attachment', attachment)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}/messages/{message}/attachments/{attachment}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)))
                .replace(`{${"message"}}`, encodeURIComponent(String(message)))
                .replace(`{${"attachment"}}`, encodeURIComponent(String(attachment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method returns the full RFC822 formatted source of the stored message
         * @summary Get Message source
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message ID of the Message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageSource: async (user: string, mailbox: string, message: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getMessageSource', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('getMessageSource', 'mailbox', mailbox)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('getMessageSource', 'message', message)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}/messages/{message}/message.eml`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)))
                .replace(`{${"message"}}`, encodeURIComponent(String(message)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List messages in a Mailbox
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {boolean} [unseen] If true, then returns only unseen messages
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [threadCounters] If true, then includes threadMessageCount in the response. Counters come with some overhead
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {Order} [order] Ordering of the records by insert date
         * @param {string} [includeHeaders] Comma separated list of header keys to include in the response
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages: async (user: string, mailbox: string, unseen?: boolean, metaData?: boolean, threadCounters?: boolean, limit?: number, page?: number, order?: Order, includeHeaders?: string, next?: string, previous?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getMessages', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('getMessages', 'mailbox', mailbox)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}/messages`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (unseen !== undefined) {
                localVarQueryParameter['unseen'] = unseen;
            }

            if (metaData !== undefined) {
                localVarQueryParameter['metaData'] = metaData;
            }

            if (threadCounters !== undefined) {
                localVarQueryParameter['threadCounters'] = threadCounters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (includeHeaders !== undefined) {
                localVarQueryParameter['includeHeaders'] = includeHeaders;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method allows applying an action to all matching messages. This is an async method so that it will return immediately. Actual modifications are run in the background.
         * @summary Search and update messages
         * @param {string} user ID of the User
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchApplyMessages: async (user: string, inlineObject2?: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('searchApplyMessages', 'user', user)
            const localVarPath = `/users/{user}/search`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method allows searching for matching messages.
         * @summary Search for messages
         * @param {string} user ID of the User
         * @param {string} [mailbox] ID of the Mailbox
         * @param {string} [thread] Thread ID
         * @param {string} [query] Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
         * @param {string} [datestart] Datestring for the earliest message storing time
         * @param {string} [dateend] Datestring for the latest message storing time
         * @param {string} [from] Partial match for the From: header line
         * @param {string} [to] Partial match for the To: and Cc: header lines
         * @param {string} [subject] Partial match for the Subject: header line
         * @param {boolean} [attachments] If true, then matches only messages with attachments
         * @param {boolean} [flagged] If true, then matches only messages with \\Flagged flags
         * @param {boolean} [unseen] If true, then matches only messages without \\Seen flags
         * @param {boolean} [searchable] If true, then matches messages not in Junk or Trash
         * @param {string} [orQuery] Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
         * @param {string} [orFrom] Partial match for the From: header line
         * @param {string} [orTo] Partial match for the To: and Cc: header lines
         * @param {string} [orSubject] Partial match for the Subject: header line
         * @param {number} [minSize] Minimal message size in bytes
         * @param {number} [maxSize] Maximal message size in bytes
         * @param {boolean} [threadCounters] If true, then includes threadMessageCount in the response. Counters come with some overhead
         * @param {number} [limit] How many records to return
         * @param {Order} [order] Ordering of the records by insert date. If no order is supplied, results are sorted by heir mongoDB ObjectId.
         * @param {string} [includeHeaders] Comma separated list of header keys to include in the response
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMessages: async (user: string, mailbox?: string, thread?: string, query?: string, datestart?: string, dateend?: string, from?: string, to?: string, subject?: string, attachments?: boolean, flagged?: boolean, unseen?: boolean, searchable?: boolean, orQuery?: string, orFrom?: string, orTo?: string, orSubject?: string, minSize?: number, maxSize?: number, threadCounters?: boolean, limit?: number, order?: Order, includeHeaders?: string, page?: number, next?: string, previous?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('searchMessages', 'user', user)
            const localVarPath = `/users/{user}/search`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (mailbox !== undefined) {
                localVarQueryParameter['mailbox'] = mailbox;
            }

            if (thread !== undefined) {
                localVarQueryParameter['thread'] = thread;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (datestart !== undefined) {
                localVarQueryParameter['datestart'] = (datestart as any instanceof Date) ?
                    (datestart as any).toISOString() :
                    datestart;
            }

            if (dateend !== undefined) {
                localVarQueryParameter['dateend'] = (dateend as any instanceof Date) ?
                    (dateend as any).toISOString() :
                    dateend;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (subject !== undefined) {
                localVarQueryParameter['subject'] = subject;
            }

            if (attachments !== undefined) {
                localVarQueryParameter['attachments'] = attachments;
            }

            if (flagged !== undefined) {
                localVarQueryParameter['flagged'] = flagged;
            }

            if (unseen !== undefined) {
                localVarQueryParameter['unseen'] = unseen;
            }

            if (searchable !== undefined) {
                localVarQueryParameter['searchable'] = searchable;
            }

            if (orQuery !== undefined) {
                localVarQueryParameter['or.query'] = orQuery;
            }

            if (orFrom !== undefined) {
                localVarQueryParameter['or.from'] = orFrom;
            }

            if (orTo !== undefined) {
                localVarQueryParameter['or.to'] = orTo;
            }

            if (orSubject !== undefined) {
                localVarQueryParameter['or.subject'] = orSubject;
            }

            if (minSize !== undefined) {
                localVarQueryParameter['minSize'] = minSize;
            }

            if (maxSize !== undefined) {
                localVarQueryParameter['maxSize'] = maxSize;
            }

            if (threadCounters !== undefined) {
                localVarQueryParameter['threadCounters'] = threadCounters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (includeHeaders !== undefined) {
                localVarQueryParameter['includeHeaders'] = includeHeaders;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
         * @summary Submit Draft for delivery
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {SubmitStoredMessageRequest} submitStoredMessageRequest This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitStoredMessage: async (user: string, mailbox: string, message: number, submitStoredMessageRequest: SubmitStoredMessageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('submitStoredMessage', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('submitStoredMessage', 'mailbox', mailbox)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('submitStoredMessage', 'message', message)
            // verify required parameter 'submitStoredMessageRequest' is not null or undefined
            assertParamExists('submitStoredMessage', 'submitStoredMessageRequest', submitStoredMessageRequest)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}/messages/{message}/submit`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)))
                .replace(`{${"message"}}`, encodeURIComponent(String(message)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitStoredMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method updates message flags and also allows to move messages to a different mailbox
         * @summary Update Message information
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {UpdateMessageRequest} updateMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage: async (user: string, mailbox: string, updateMessageRequest: UpdateMessageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateMessage', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('updateMessage', 'mailbox', mailbox)
            // verify required parameter 'updateMessageRequest' is not null or undefined
            assertParamExists('updateMessage', 'updateMessageRequest', updateMessageRequest)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}/messages`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method allows to upload either an RFC822 formatted message or a message structure to a mailbox. Raw message is stored unmodified, no headers are added or removed. If you want to generate the uploaded message from structured data fields, then do not use the raw property.
         * @summary Upload Message
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {UploadMessageRequest} uploadMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMessage: async (user: string, mailbox: string, uploadMessageRequest: UploadMessageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('uploadMessage', 'user', user)
            // verify required parameter 'mailbox' is not null or undefined
            assertParamExists('uploadMessage', 'mailbox', mailbox)
            // verify required parameter 'uploadMessageRequest' is not null or undefined
            assertParamExists('uploadMessage', 'uploadMessageRequest', uploadMessageRequest)
            const localVarPath = `/users/{user}/mailboxes/{mailbox}/messages`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"mailbox"}}`, encodeURIComponent(String(mailbox)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a Message
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(user: string, mailbox: string, message: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(user, mailbox, message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all Messages from a Mailbox
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {boolean} [async] Schedule deletion task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessagesInMailbox(user: string, mailbox: string, async?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMessagesInMailboxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessagesInMailbox(user, mailbox, async, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can delete outbound emails that are still in queue. Queue ID can be found from the `outbound` property of a stored email.
         * @summary Delete an Outbound Message
         * @param {string} user ID of the User
         * @param {string} queueId Outbound queue ID of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOutboundMessage(user: string, queueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOutboundMessage(user, queueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
         * @summary Forward stored Message
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {ForwardStoredMessageRequest} forwardStoredMessageRequest This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forwardStoredMessage(user: string, mailbox: string, message: number, forwardStoredMessageRequest: ForwardStoredMessageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForwardStoredMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardStoredMessage(user, mailbox, message, forwardStoredMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Message information
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {boolean} [markAsSeen] If true then marks message as seen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessage(user: string, mailbox: string, message: number, markAsSeen?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessage(user, mailbox, message, markAsSeen, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns attachment file contents in binary form
         * @summary Download Attachment
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message ID of the Message
         * @param {string} attachment ID of the Attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageAttachment(user: string, mailbox: string, message: number, attachment: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageAttachment(user, mailbox, message, attachment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns the full RFC822 formatted source of the stored message
         * @summary Get Message source
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message ID of the Message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageSource(user: string, mailbox: string, message: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageSource(user, mailbox, message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List messages in a Mailbox
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {boolean} [unseen] If true, then returns only unseen messages
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [threadCounters] If true, then includes threadMessageCount in the response. Counters come with some overhead
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {Order} [order] Ordering of the records by insert date
         * @param {string} [includeHeaders] Comma separated list of header keys to include in the response
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessages(user: string, mailbox: string, unseen?: boolean, metaData?: boolean, threadCounters?: boolean, limit?: number, page?: number, order?: Order, includeHeaders?: string, next?: string, previous?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessages(user, mailbox, unseen, metaData, threadCounters, limit, page, order, includeHeaders, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method allows applying an action to all matching messages. This is an async method so that it will return immediately. Actual modifications are run in the background.
         * @summary Search and update messages
         * @param {string} user ID of the User
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchApplyMessages(user: string, inlineObject2?: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchApplyMessages(user, inlineObject2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method allows searching for matching messages.
         * @summary Search for messages
         * @param {string} user ID of the User
         * @param {string} [mailbox] ID of the Mailbox
         * @param {string} [thread] Thread ID
         * @param {string} [query] Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
         * @param {string} [datestart] Datestring for the earliest message storing time
         * @param {string} [dateend] Datestring for the latest message storing time
         * @param {string} [from] Partial match for the From: header line
         * @param {string} [to] Partial match for the To: and Cc: header lines
         * @param {string} [subject] Partial match for the Subject: header line
         * @param {boolean} [attachments] If true, then matches only messages with attachments
         * @param {boolean} [flagged] If true, then matches only messages with \\Flagged flags
         * @param {boolean} [unseen] If true, then matches only messages without \\Seen flags
         * @param {boolean} [searchable] If true, then matches messages not in Junk or Trash
         * @param {string} [orQuery] Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
         * @param {string} [orFrom] Partial match for the From: header line
         * @param {string} [orTo] Partial match for the To: and Cc: header lines
         * @param {string} [orSubject] Partial match for the Subject: header line
         * @param {number} [minSize] Minimal message size in bytes
         * @param {number} [maxSize] Maximal message size in bytes
         * @param {boolean} [threadCounters] If true, then includes threadMessageCount in the response. Counters come with some overhead
         * @param {number} [limit] How many records to return
         * @param {Order} [order] Ordering of the records by insert date. If no order is supplied, results are sorted by heir mongoDB ObjectId.
         * @param {string} [includeHeaders] Comma separated list of header keys to include in the response
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMessages(user: string, mailbox?: string, thread?: string, query?: string, datestart?: string, dateend?: string, from?: string, to?: string, subject?: string, attachments?: boolean, flagged?: boolean, unseen?: boolean, searchable?: boolean, orQuery?: string, orFrom?: string, orTo?: string, orSubject?: string, minSize?: number, maxSize?: number, threadCounters?: boolean, limit?: number, order?: Order, includeHeaders?: string, page?: number, next?: string, previous?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchMessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMessages(user, mailbox, thread, query, datestart, dateend, from, to, subject, attachments, flagged, unseen, searchable, orQuery, orFrom, orTo, orSubject, minSize, maxSize, threadCounters, limit, order, includeHeaders, page, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
         * @summary Submit Draft for delivery
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {SubmitStoredMessageRequest} submitStoredMessageRequest This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitStoredMessage(user: string, mailbox: string, message: number, submitStoredMessageRequest: SubmitStoredMessageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitStoredMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitStoredMessage(user, mailbox, message, submitStoredMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method updates message flags and also allows to move messages to a different mailbox
         * @summary Update Message information
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {UpdateMessageRequest} updateMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMessage(user: string, mailbox: string, updateMessageRequest: UpdateMessageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMessage(user, mailbox, updateMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method allows to upload either an RFC822 formatted message or a message structure to a mailbox. Raw message is stored unmodified, no headers are added or removed. If you want to generate the uploaded message from structured data fields, then do not use the raw property.
         * @summary Upload Message
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {UploadMessageRequest} uploadMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMessage(user: string, mailbox: string, uploadMessageRequest: UploadMessageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMessage(user, mailbox, uploadMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a Message
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(user: string, mailbox: string, message: number, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteMessage(user, mailbox, message, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all Messages from a Mailbox
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {boolean} [async] Schedule deletion task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessagesInMailbox(user: string, mailbox: string, async?: boolean, options?: any): AxiosPromise<DeleteMessagesInMailboxResponse> {
            return localVarFp.deleteMessagesInMailbox(user, mailbox, async, options).then((request) => request(axios, basePath));
        },
        /**
         * You can delete outbound emails that are still in queue. Queue ID can be found from the `outbound` property of a stored email.
         * @summary Delete an Outbound Message
         * @param {string} user ID of the User
         * @param {string} queueId Outbound queue ID of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOutboundMessage(user: string, queueId: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteOutboundMessage(user, queueId, options).then((request) => request(axios, basePath));
        },
        /**
         * This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
         * @summary Forward stored Message
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {ForwardStoredMessageRequest} forwardStoredMessageRequest This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardStoredMessage(user: string, mailbox: string, message: number, forwardStoredMessageRequest: ForwardStoredMessageRequest, options?: any): AxiosPromise<ForwardStoredMessageResponse> {
            return localVarFp.forwardStoredMessage(user, mailbox, message, forwardStoredMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Message information
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {boolean} [markAsSeen] If true then marks message as seen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(user: string, mailbox: string, message: number, markAsSeen?: boolean, options?: any): AxiosPromise<GetMessageResponse> {
            return localVarFp.getMessage(user, mailbox, message, markAsSeen, options).then((request) => request(axios, basePath));
        },
        /**
         * This method returns attachment file contents in binary form
         * @summary Download Attachment
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message ID of the Message
         * @param {string} attachment ID of the Attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageAttachment(user: string, mailbox: string, message: number, attachment: string, options?: any): AxiosPromise<any> {
            return localVarFp.getMessageAttachment(user, mailbox, message, attachment, options).then((request) => request(axios, basePath));
        },
        /**
         * This method returns the full RFC822 formatted source of the stored message
         * @summary Get Message source
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message ID of the Message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageSource(user: string, mailbox: string, message: number, options?: any): AxiosPromise<object> {
            return localVarFp.getMessageSource(user, mailbox, message, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List messages in a Mailbox
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {boolean} [unseen] If true, then returns only unseen messages
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [threadCounters] If true, then includes threadMessageCount in the response. Counters come with some overhead
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {Order} [order] Ordering of the records by insert date
         * @param {string} [includeHeaders] Comma separated list of header keys to include in the response
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(user: string, mailbox: string, unseen?: boolean, metaData?: boolean, threadCounters?: boolean, limit?: number, page?: number, order?: Order, includeHeaders?: string, next?: string, previous?: string, options?: any): AxiosPromise<GetMessagesResponse> {
            return localVarFp.getMessages(user, mailbox, unseen, metaData, threadCounters, limit, page, order, includeHeaders, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * This method allows applying an action to all matching messages. This is an async method so that it will return immediately. Actual modifications are run in the background.
         * @summary Search and update messages
         * @param {string} user ID of the User
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchApplyMessages(user: string, inlineObject2?: InlineObject2, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.searchApplyMessages(user, inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * This method allows searching for matching messages.
         * @summary Search for messages
         * @param {string} user ID of the User
         * @param {string} [mailbox] ID of the Mailbox
         * @param {string} [thread] Thread ID
         * @param {string} [query] Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
         * @param {string} [datestart] Datestring for the earliest message storing time
         * @param {string} [dateend] Datestring for the latest message storing time
         * @param {string} [from] Partial match for the From: header line
         * @param {string} [to] Partial match for the To: and Cc: header lines
         * @param {string} [subject] Partial match for the Subject: header line
         * @param {boolean} [attachments] If true, then matches only messages with attachments
         * @param {boolean} [flagged] If true, then matches only messages with \\Flagged flags
         * @param {boolean} [unseen] If true, then matches only messages without \\Seen flags
         * @param {boolean} [searchable] If true, then matches messages not in Junk or Trash
         * @param {string} [orQuery] Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
         * @param {string} [orFrom] Partial match for the From: header line
         * @param {string} [orTo] Partial match for the To: and Cc: header lines
         * @param {string} [orSubject] Partial match for the Subject: header line
         * @param {number} [minSize] Minimal message size in bytes
         * @param {number} [maxSize] Maximal message size in bytes
         * @param {boolean} [threadCounters] If true, then includes threadMessageCount in the response. Counters come with some overhead
         * @param {number} [limit] How many records to return
         * @param {Order} [order] Ordering of the records by insert date. If no order is supplied, results are sorted by heir mongoDB ObjectId.
         * @param {string} [includeHeaders] Comma separated list of header keys to include in the response
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMessages(user: string, mailbox?: string, thread?: string, query?: string, datestart?: string, dateend?: string, from?: string, to?: string, subject?: string, attachments?: boolean, flagged?: boolean, unseen?: boolean, searchable?: boolean, orQuery?: string, orFrom?: string, orTo?: string, orSubject?: string, minSize?: number, maxSize?: number, threadCounters?: boolean, limit?: number, order?: Order, includeHeaders?: string, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<SearchMessagesResponse> {
            return localVarFp.searchMessages(user, mailbox, thread, query, datestart, dateend, from, to, subject, attachments, flagged, unseen, searchable, orQuery, orFrom, orTo, orSubject, minSize, maxSize, threadCounters, limit, order, includeHeaders, page, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
         * @summary Submit Draft for delivery
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {number} message Message ID
         * @param {SubmitStoredMessageRequest} submitStoredMessageRequest This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitStoredMessage(user: string, mailbox: string, message: number, submitStoredMessageRequest: SubmitStoredMessageRequest, options?: any): AxiosPromise<SubmitStoredMessageResponse> {
            return localVarFp.submitStoredMessage(user, mailbox, message, submitStoredMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This method updates message flags and also allows to move messages to a different mailbox
         * @summary Update Message information
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {UpdateMessageRequest} updateMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(user: string, mailbox: string, updateMessageRequest: UpdateMessageRequest, options?: any): AxiosPromise<UpdateMessageResponse> {
            return localVarFp.updateMessage(user, mailbox, updateMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This method allows to upload either an RFC822 formatted message or a message structure to a mailbox. Raw message is stored unmodified, no headers are added or removed. If you want to generate the uploaded message from structured data fields, then do not use the raw property.
         * @summary Upload Message
         * @param {string} user ID of the User
         * @param {string} mailbox ID of the Mailbox
         * @param {UploadMessageRequest} uploadMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMessage(user: string, mailbox: string, uploadMessageRequest: UploadMessageRequest, options?: any): AxiosPromise<UploadMessageResponse> {
            return localVarFp.uploadMessage(user, mailbox, uploadMessageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagesApi - interface
 * @export
 * @interface MessagesApi
 */
export interface MessagesApiInterface {
    /**
     * 
     * @summary Delete a Message
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message Message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    deleteMessage(user: string, mailbox: string, message: number, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Delete all Messages from a Mailbox
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {boolean} [async] Schedule deletion task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    deleteMessagesInMailbox(user: string, mailbox: string, async?: boolean, options?: any): AxiosPromise<DeleteMessagesInMailboxResponse>;

    /**
     * You can delete outbound emails that are still in queue. Queue ID can be found from the `outbound` property of a stored email.
     * @summary Delete an Outbound Message
     * @param {string} user ID of the User
     * @param {string} queueId Outbound queue ID of the message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    deleteOutboundMessage(user: string, queueId: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
     * @summary Forward stored Message
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message Message ID
     * @param {ForwardStoredMessageRequest} forwardStoredMessageRequest This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    forwardStoredMessage(user: string, mailbox: string, message: number, forwardStoredMessageRequest: ForwardStoredMessageRequest, options?: any): AxiosPromise<ForwardStoredMessageResponse>;

    /**
     * 
     * @summary Request Message information
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message Message ID
     * @param {boolean} [markAsSeen] If true then marks message as seen
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    getMessage(user: string, mailbox: string, message: number, markAsSeen?: boolean, options?: any): AxiosPromise<GetMessageResponse>;

    /**
     * This method returns attachment file contents in binary form
     * @summary Download Attachment
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message ID of the Message
     * @param {string} attachment ID of the Attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    getMessageAttachment(user: string, mailbox: string, message: number, attachment: string, options?: any): AxiosPromise<any>;

    /**
     * This method returns the full RFC822 formatted source of the stored message
     * @summary Get Message source
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message ID of the Message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    getMessageSource(user: string, mailbox: string, message: number, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary List messages in a Mailbox
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {boolean} [unseen] If true, then returns only unseen messages
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {boolean} [threadCounters] If true, then includes threadMessageCount in the response. Counters come with some overhead
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {Order} [order] Ordering of the records by insert date
     * @param {string} [includeHeaders] Comma separated list of header keys to include in the response
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    getMessages(user: string, mailbox: string, unseen?: boolean, metaData?: boolean, threadCounters?: boolean, limit?: number, page?: number, order?: Order, includeHeaders?: string, next?: string, previous?: string, options?: any): AxiosPromise<GetMessagesResponse>;

    /**
     * This method allows applying an action to all matching messages. This is an async method so that it will return immediately. Actual modifications are run in the background.
     * @summary Search and update messages
     * @param {string} user ID of the User
     * @param {InlineObject2} [inlineObject2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    searchApplyMessages(user: string, inlineObject2?: InlineObject2, options?: any): AxiosPromise<InlineResponse2002>;

    /**
     * This method allows searching for matching messages.
     * @summary Search for messages
     * @param {string} user ID of the User
     * @param {string} [mailbox] ID of the Mailbox
     * @param {string} [thread] Thread ID
     * @param {string} [query] Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
     * @param {string} [datestart] Datestring for the earliest message storing time
     * @param {string} [dateend] Datestring for the latest message storing time
     * @param {string} [from] Partial match for the From: header line
     * @param {string} [to] Partial match for the To: and Cc: header lines
     * @param {string} [subject] Partial match for the Subject: header line
     * @param {boolean} [attachments] If true, then matches only messages with attachments
     * @param {boolean} [flagged] If true, then matches only messages with \\Flagged flags
     * @param {boolean} [unseen] If true, then matches only messages without \\Seen flags
     * @param {boolean} [searchable] If true, then matches messages not in Junk or Trash
     * @param {string} [orQuery] Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
     * @param {string} [orFrom] Partial match for the From: header line
     * @param {string} [orTo] Partial match for the To: and Cc: header lines
     * @param {string} [orSubject] Partial match for the Subject: header line
     * @param {number} [minSize] Minimal message size in bytes
     * @param {number} [maxSize] Maximal message size in bytes
     * @param {boolean} [threadCounters] If true, then includes threadMessageCount in the response. Counters come with some overhead
     * @param {number} [limit] How many records to return
     * @param {Order} [order] Ordering of the records by insert date. If no order is supplied, results are sorted by heir mongoDB ObjectId.
     * @param {string} [includeHeaders] Comma separated list of header keys to include in the response
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    searchMessages(user: string, mailbox?: string, thread?: string, query?: string, datestart?: string, dateend?: string, from?: string, to?: string, subject?: string, attachments?: boolean, flagged?: boolean, unseen?: boolean, searchable?: boolean, orQuery?: string, orFrom?: string, orTo?: string, orSubject?: string, minSize?: number, maxSize?: number, threadCounters?: boolean, limit?: number, order?: Order, includeHeaders?: string, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<SearchMessagesResponse>;

    /**
     * This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
     * @summary Submit Draft for delivery
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message Message ID
     * @param {SubmitStoredMessageRequest} submitStoredMessageRequest This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    submitStoredMessage(user: string, mailbox: string, message: number, submitStoredMessageRequest: SubmitStoredMessageRequest, options?: any): AxiosPromise<SubmitStoredMessageResponse>;

    /**
     * This method updates message flags and also allows to move messages to a different mailbox
     * @summary Update Message information
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {UpdateMessageRequest} updateMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    updateMessage(user: string, mailbox: string, updateMessageRequest: UpdateMessageRequest, options?: any): AxiosPromise<UpdateMessageResponse>;

    /**
     * This method allows to upload either an RFC822 formatted message or a message structure to a mailbox. Raw message is stored unmodified, no headers are added or removed. If you want to generate the uploaded message from structured data fields, then do not use the raw property.
     * @summary Upload Message
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {UploadMessageRequest} uploadMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    uploadMessage(user: string, mailbox: string, uploadMessageRequest: UploadMessageRequest, options?: any): AxiosPromise<UploadMessageResponse>;

}

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI implements MessagesApiInterface {
    /**
     * 
     * @summary Delete a Message
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message Message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public deleteMessage(user: string, mailbox: string, message: number, options?: any) {
        return MessagesApiFp(this.configuration).deleteMessage(user, mailbox, message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all Messages from a Mailbox
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {boolean} [async] Schedule deletion task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public deleteMessagesInMailbox(user: string, mailbox: string, async?: boolean, options?: any) {
        return MessagesApiFp(this.configuration).deleteMessagesInMailbox(user, mailbox, async, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can delete outbound emails that are still in queue. Queue ID can be found from the `outbound` property of a stored email.
     * @summary Delete an Outbound Message
     * @param {string} user ID of the User
     * @param {string} queueId Outbound queue ID of the message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public deleteOutboundMessage(user: string, queueId: string, options?: any) {
        return MessagesApiFp(this.configuration).deleteOutboundMessage(user, queueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
     * @summary Forward stored Message
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message Message ID
     * @param {ForwardStoredMessageRequest} forwardStoredMessageRequest This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public forwardStoredMessage(user: string, mailbox: string, message: number, forwardStoredMessageRequest: ForwardStoredMessageRequest, options?: any) {
        return MessagesApiFp(this.configuration).forwardStoredMessage(user, mailbox, message, forwardStoredMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Message information
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message Message ID
     * @param {boolean} [markAsSeen] If true then marks message as seen
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessage(user: string, mailbox: string, message: number, markAsSeen?: boolean, options?: any) {
        return MessagesApiFp(this.configuration).getMessage(user, mailbox, message, markAsSeen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns attachment file contents in binary form
     * @summary Download Attachment
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message ID of the Message
     * @param {string} attachment ID of the Attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessageAttachment(user: string, mailbox: string, message: number, attachment: string, options?: any) {
        return MessagesApiFp(this.configuration).getMessageAttachment(user, mailbox, message, attachment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns the full RFC822 formatted source of the stored message
     * @summary Get Message source
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message ID of the Message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessageSource(user: string, mailbox: string, message: number, options?: any) {
        return MessagesApiFp(this.configuration).getMessageSource(user, mailbox, message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List messages in a Mailbox
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {boolean} [unseen] If true, then returns only unseen messages
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {boolean} [threadCounters] If true, then includes threadMessageCount in the response. Counters come with some overhead
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {Order} [order] Ordering of the records by insert date
     * @param {string} [includeHeaders] Comma separated list of header keys to include in the response
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessages(user: string, mailbox: string, unseen?: boolean, metaData?: boolean, threadCounters?: boolean, limit?: number, page?: number, order?: Order, includeHeaders?: string, next?: string, previous?: string, options?: any) {
        return MessagesApiFp(this.configuration).getMessages(user, mailbox, unseen, metaData, threadCounters, limit, page, order, includeHeaders, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method allows applying an action to all matching messages. This is an async method so that it will return immediately. Actual modifications are run in the background.
     * @summary Search and update messages
     * @param {string} user ID of the User
     * @param {InlineObject2} [inlineObject2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public searchApplyMessages(user: string, inlineObject2?: InlineObject2, options?: any) {
        return MessagesApiFp(this.configuration).searchApplyMessages(user, inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method allows searching for matching messages.
     * @summary Search for messages
     * @param {string} user ID of the User
     * @param {string} [mailbox] ID of the Mailbox
     * @param {string} [thread] Thread ID
     * @param {string} [query] Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
     * @param {string} [datestart] Datestring for the earliest message storing time
     * @param {string} [dateend] Datestring for the latest message storing time
     * @param {string} [from] Partial match for the From: header line
     * @param {string} [to] Partial match for the To: and Cc: header lines
     * @param {string} [subject] Partial match for the Subject: header line
     * @param {boolean} [attachments] If true, then matches only messages with attachments
     * @param {boolean} [flagged] If true, then matches only messages with \\Flagged flags
     * @param {boolean} [unseen] If true, then matches only messages without \\Seen flags
     * @param {boolean} [searchable] If true, then matches messages not in Junk or Trash
     * @param {string} [orQuery] Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
     * @param {string} [orFrom] Partial match for the From: header line
     * @param {string} [orTo] Partial match for the To: and Cc: header lines
     * @param {string} [orSubject] Partial match for the Subject: header line
     * @param {number} [minSize] Minimal message size in bytes
     * @param {number} [maxSize] Maximal message size in bytes
     * @param {boolean} [threadCounters] If true, then includes threadMessageCount in the response. Counters come with some overhead
     * @param {number} [limit] How many records to return
     * @param {Order} [order] Ordering of the records by insert date. If no order is supplied, results are sorted by heir mongoDB ObjectId.
     * @param {string} [includeHeaders] Comma separated list of header keys to include in the response
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public searchMessages(user: string, mailbox?: string, thread?: string, query?: string, datestart?: string, dateend?: string, from?: string, to?: string, subject?: string, attachments?: boolean, flagged?: boolean, unseen?: boolean, searchable?: boolean, orQuery?: string, orFrom?: string, orTo?: string, orSubject?: string, minSize?: number, maxSize?: number, threadCounters?: boolean, limit?: number, order?: Order, includeHeaders?: string, page?: number, next?: string, previous?: string, options?: any) {
        return MessagesApiFp(this.configuration).searchMessages(user, mailbox, thread, query, datestart, dateend, from, to, subject, attachments, flagged, unseen, searchable, orQuery, orFrom, orTo, orSubject, minSize, maxSize, threadCounters, limit, order, includeHeaders, page, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
     * @summary Submit Draft for delivery
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {number} message Message ID
     * @param {SubmitStoredMessageRequest} submitStoredMessageRequest This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public submitStoredMessage(user: string, mailbox: string, message: number, submitStoredMessageRequest: SubmitStoredMessageRequest, options?: any) {
        return MessagesApiFp(this.configuration).submitStoredMessage(user, mailbox, message, submitStoredMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method updates message flags and also allows to move messages to a different mailbox
     * @summary Update Message information
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {UpdateMessageRequest} updateMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public updateMessage(user: string, mailbox: string, updateMessageRequest: UpdateMessageRequest, options?: any) {
        return MessagesApiFp(this.configuration).updateMessage(user, mailbox, updateMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method allows to upload either an RFC822 formatted message or a message structure to a mailbox. Raw message is stored unmodified, no headers are added or removed. If you want to generate the uploaded message from structured data fields, then do not use the raw property.
     * @summary Upload Message
     * @param {string} user ID of the User
     * @param {string} mailbox ID of the Mailbox
     * @param {UploadMessageRequest} uploadMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public uploadMessage(user: string, mailbox: string, uploadMessageRequest: UploadMessageRequest, options?: any) {
        return MessagesApiFp(this.configuration).uploadMessage(user, mailbox, uploadMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new or update an existing setting
         * @summary Create or Update Setting
         * @param {string} setting Key of the Setting
         * @param {CreateSettingRequest} createSettingRequest Create or Update Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSetting: async (setting: string, createSettingRequest: CreateSettingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'setting' is not null or undefined
            assertParamExists('createSetting', 'setting', setting)
            // verify required parameter 'createSettingRequest' is not null or undefined
            assertParamExists('createSetting', 'createSettingRequest', createSettingRequest)
            const localVarPath = `/settings/{setting}`
                .replace(`{${"setting"}}`, encodeURIComponent(String(setting)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a setting
         * @param {string} setting Key of the Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSetting: async (setting: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'setting' is not null or undefined
            assertParamExists('deleteSetting', 'setting', setting)
            const localVarPath = `/settings/{setting}`
                .replace(`{${"setting"}}`, encodeURIComponent(String(setting)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Setting value
         * @param {string} setting Key of the Setting
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting: async (setting: string, sess?: string, ip?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'setting' is not null or undefined
            assertParamExists('getSetting', 'setting', setting)
            const localVarPath = `/settings/{setting}`
                .replace(`{${"setting"}}`, encodeURIComponent(String(setting)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (sess !== undefined) {
                localVarQueryParameter['sess'] = sess;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List registered Settings
         * @param {string} [filter] Optional partial match of the Setting key
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: async (filter?: string, sess?: string, ip?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sess !== undefined) {
                localVarQueryParameter['sess'] = sess;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new or update an existing setting
         * @summary Create or Update Setting
         * @param {string} setting Key of the Setting
         * @param {CreateSettingRequest} createSettingRequest Create or Update Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSetting(setting: string, createSettingRequest: CreateSettingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSetting(setting, createSettingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a setting
         * @param {string} setting Key of the Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSetting(setting: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSetting(setting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Setting value
         * @param {string} setting Key of the Setting
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetting(setting: string, sess?: string, ip?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetting(setting, sess, ip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List registered Settings
         * @param {string} [filter] Optional partial match of the Setting key
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettings(filter?: string, sess?: string, ip?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(filter, sess, ip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * Create a new or update an existing setting
         * @summary Create or Update Setting
         * @param {string} setting Key of the Setting
         * @param {CreateSettingRequest} createSettingRequest Create or Update Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSetting(setting: string, createSettingRequest: CreateSettingRequest, options?: any): AxiosPromise<CreateSettingResponse> {
            return localVarFp.createSetting(setting, createSettingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a setting
         * @param {string} setting Key of the Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSetting(setting: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteSetting(setting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Setting value
         * @param {string} setting Key of the Setting
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting(setting: string, sess?: string, ip?: string, options?: any): AxiosPromise<GetSettingResponse> {
            return localVarFp.getSetting(setting, sess, ip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List registered Settings
         * @param {string} [filter] Optional partial match of the Setting key
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(filter?: string, sess?: string, ip?: string, options?: any): AxiosPromise<GetSettingsResponse> {
            return localVarFp.getSettings(filter, sess, ip, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - interface
 * @export
 * @interface SettingsApi
 */
export interface SettingsApiInterface {
    /**
     * Create a new or update an existing setting
     * @summary Create or Update Setting
     * @param {string} setting Key of the Setting
     * @param {CreateSettingRequest} createSettingRequest Create or Update Setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    createSetting(setting: string, createSettingRequest: CreateSettingRequest, options?: any): AxiosPromise<CreateSettingResponse>;

    /**
     * 
     * @summary Delete a setting
     * @param {string} setting Key of the Setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    deleteSetting(setting: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Get Setting value
     * @param {string} setting Key of the Setting
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    getSetting(setting: string, sess?: string, ip?: string, options?: any): AxiosPromise<GetSettingResponse>;

    /**
     * 
     * @summary List registered Settings
     * @param {string} [filter] Optional partial match of the Setting key
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    getSettings(filter?: string, sess?: string, ip?: string, options?: any): AxiosPromise<GetSettingsResponse>;

}

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI implements SettingsApiInterface {
    /**
     * Create a new or update an existing setting
     * @summary Create or Update Setting
     * @param {string} setting Key of the Setting
     * @param {CreateSettingRequest} createSettingRequest Create or Update Setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public createSetting(setting: string, createSettingRequest: CreateSettingRequest, options?: any) {
        return SettingsApiFp(this.configuration).createSetting(setting, createSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a setting
     * @param {string} setting Key of the Setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public deleteSetting(setting: string, options?: any) {
        return SettingsApiFp(this.configuration).deleteSetting(setting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Setting value
     * @param {string} setting Key of the Setting
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSetting(setting: string, sess?: string, ip?: string, options?: any) {
        return SettingsApiFp(this.configuration).getSetting(setting, sess, ip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List registered Settings
     * @param {string} [filter] Optional partial match of the Setting key
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSettings(filter?: string, sess?: string, ip?: string, options?: any) {
        return SettingsApiFp(this.configuration).getSettings(filter, sess, ip, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageApi - axios parameter creator
 * @export
 */
export const StorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a File
         * @param {string} user ID of the User
         * @param {string} file ID of the File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (user: string, file: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('deleteFile', 'user', user)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('deleteFile', 'file', file)
            const localVarPath = `/users/{user}/storage/{file}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"file"}}`, encodeURIComponent(String(file)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method returns stored file contents in binary form
         * @summary Download File
         * @param {string} user ID of the User
         * @param {string} file ID of the File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (user: string, file: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getFile', 'user', user)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('getFile', 'file', file)
            const localVarPath = `/users/{user}/storage/{file}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"file"}}`, encodeURIComponent(String(file)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List stored files
         * @param {string} user ID of the User
         * @param {string} [query] Partial match of a filename
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles: async (user: string, query?: string, limit?: number, page?: number, next?: string, previous?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getFiles', 'user', user)
            const localVarPath = `/users/{user}/storage`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method allows to upload an attachment to be linked from a draft
         * @summary Upload File
         * @param {string} user ID of the User
         * @param {any} content 
         * @param {string} [filename] Name of the file
         * @param {string} [contentType] MIME type of the file. Is detected from the file name by default
         * @param {string} [encoding] Encoding of the file content. Useful if you want to upload the file in base64 encoded format. Valid options \\\&quot;base64\\\&quot;, \\\&quot;hex\\\&quot;, \\\&quot;utf8\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (user: string, content: any, filename?: string, contentType?: string, encoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('uploadFile', 'user', user)
            // verify required parameter 'content' is not null or undefined
            assertParamExists('uploadFile', 'content', content)
            const localVarPath = `/users/{user}/storage`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


            if (filename !== undefined) { 
                localVarFormParams.append('filename', filename as any);
            }
    
            if (contentType !== undefined) { 
                localVarFormParams.append('contentType', contentType as any);
            }
    
            if (encoding !== undefined) { 
                localVarFormParams.append('encoding', encoding as any);
            }
    
            if (content !== undefined) { 
                localVarFormParams.append('content', content as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageApi - functional programming interface
 * @export
 */
export const StorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a File
         * @param {string} user ID of the User
         * @param {string} file ID of the File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(user: string, file: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(user, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns stored file contents in binary form
         * @summary Download File
         * @param {string} user ID of the User
         * @param {string} file ID of the File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(user: string, file: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(user, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List stored files
         * @param {string} user ID of the User
         * @param {string} [query] Partial match of a filename
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFiles(user: string, query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFiles(user, query, limit, page, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method allows to upload an attachment to be linked from a draft
         * @summary Upload File
         * @param {string} user ID of the User
         * @param {any} content 
         * @param {string} [filename] Name of the file
         * @param {string} [contentType] MIME type of the file. Is detected from the file name by default
         * @param {string} [encoding] Encoding of the file content. Useful if you want to upload the file in base64 encoded format. Valid options \\\&quot;base64\\\&quot;, \\\&quot;hex\\\&quot;, \\\&quot;utf8\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(user: string, content: any, filename?: string, contentType?: string, encoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(user, content, filename, contentType, encoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageApi - factory interface
 * @export
 */
export const StorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a File
         * @param {string} user ID of the User
         * @param {string} file ID of the File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(user: string, file: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteFile(user, file, options).then((request) => request(axios, basePath));
        },
        /**
         * This method returns stored file contents in binary form
         * @summary Download File
         * @param {string} user ID of the User
         * @param {string} file ID of the File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(user: string, file: string, options?: any): AxiosPromise<any> {
            return localVarFp.getFile(user, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List stored files
         * @param {string} user ID of the User
         * @param {string} [query] Partial match of a filename
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(user: string, query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetFilesResponse> {
            return localVarFp.getFiles(user, query, limit, page, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * This method allows to upload an attachment to be linked from a draft
         * @summary Upload File
         * @param {string} user ID of the User
         * @param {any} content 
         * @param {string} [filename] Name of the file
         * @param {string} [contentType] MIME type of the file. Is detected from the file name by default
         * @param {string} [encoding] Encoding of the file content. Useful if you want to upload the file in base64 encoded format. Valid options \\\&quot;base64\\\&quot;, \\\&quot;hex\\\&quot;, \\\&quot;utf8\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(user: string, content: any, filename?: string, contentType?: string, encoding?: string, options?: any): AxiosPromise<UploadFileResponse> {
            return localVarFp.uploadFile(user, content, filename, contentType, encoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageApi - interface
 * @export
 * @interface StorageApi
 */
export interface StorageApiInterface {
    /**
     * 
     * @summary Delete a File
     * @param {string} user ID of the User
     * @param {string} file ID of the File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    deleteFile(user: string, file: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * This method returns stored file contents in binary form
     * @summary Download File
     * @param {string} user ID of the User
     * @param {string} file ID of the File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getFile(user: string, file: string, options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary List stored files
     * @param {string} user ID of the User
     * @param {string} [query] Partial match of a filename
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getFiles(user: string, query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetFilesResponse>;

    /**
     * This method allows to upload an attachment to be linked from a draft
     * @summary Upload File
     * @param {string} user ID of the User
     * @param {any} content 
     * @param {string} [filename] Name of the file
     * @param {string} [contentType] MIME type of the file. Is detected from the file name by default
     * @param {string} [encoding] Encoding of the file content. Useful if you want to upload the file in base64 encoded format. Valid options \\\&quot;base64\\\&quot;, \\\&quot;hex\\\&quot;, \\\&quot;utf8\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    uploadFile(user: string, content: any, filename?: string, contentType?: string, encoding?: string, options?: any): AxiosPromise<UploadFileResponse>;

}

/**
 * StorageApi - object-oriented interface
 * @export
 * @class StorageApi
 * @extends {BaseAPI}
 */
export class StorageApi extends BaseAPI implements StorageApiInterface {
    /**
     * 
     * @summary Delete a File
     * @param {string} user ID of the User
     * @param {string} file ID of the File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public deleteFile(user: string, file: string, options?: any) {
        return StorageApiFp(this.configuration).deleteFile(user, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns stored file contents in binary form
     * @summary Download File
     * @param {string} user ID of the User
     * @param {string} file ID of the File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public getFile(user: string, file: string, options?: any) {
        return StorageApiFp(this.configuration).getFile(user, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List stored files
     * @param {string} user ID of the User
     * @param {string} [query] Partial match of a filename
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public getFiles(user: string, query?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any) {
        return StorageApiFp(this.configuration).getFiles(user, query, limit, page, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method allows to upload an attachment to be linked from a draft
     * @summary Upload File
     * @param {string} user ID of the User
     * @param {any} content 
     * @param {string} [filename] Name of the file
     * @param {string} [contentType] MIME type of the file. Is detected from the file name by default
     * @param {string} [encoding] Encoding of the file content. Useful if you want to upload the file in base64 encoded format. Valid options \\\&quot;base64\\\&quot;, \\\&quot;hex\\\&quot;, \\\&quot;utf8\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public uploadFile(user: string, content: any, filename?: string, contentType?: string, encoding?: string, options?: any) {
        return StorageApiFp(this.configuration).uploadFile(user, content, filename, contentType, encoding, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubmissionApi - axios parameter creator
 * @export
 */
export const SubmissionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this method to send emails from a user account
         * @summary Submit a Message for Delivery
         * @param {string} user Users unique ID
         * @param {SubmitMessageRequest} submitMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMessage: async (user: string, submitMessageRequest: SubmitMessageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('submitMessage', 'user', user)
            // verify required parameter 'submitMessageRequest' is not null or undefined
            assertParamExists('submitMessage', 'submitMessageRequest', submitMessageRequest)
            const localVarPath = `/users/{user}/submit`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionApi - functional programming interface
 * @export
 */
export const SubmissionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubmissionApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this method to send emails from a user account
         * @summary Submit a Message for Delivery
         * @param {string} user Users unique ID
         * @param {SubmitMessageRequest} submitMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitMessage(user: string, submitMessageRequest: SubmitMessageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitMessage(user, submitMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubmissionApi - factory interface
 * @export
 */
export const SubmissionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubmissionApiFp(configuration)
    return {
        /**
         * Use this method to send emails from a user account
         * @summary Submit a Message for Delivery
         * @param {string} user Users unique ID
         * @param {SubmitMessageRequest} submitMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMessage(user: string, submitMessageRequest: SubmitMessageRequest, options?: any): AxiosPromise<SubmitMessageResponse> {
            return localVarFp.submitMessage(user, submitMessageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubmissionApi - interface
 * @export
 * @interface SubmissionApi
 */
export interface SubmissionApiInterface {
    /**
     * Use this method to send emails from a user account
     * @summary Submit a Message for Delivery
     * @param {string} user Users unique ID
     * @param {SubmitMessageRequest} submitMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApiInterface
     */
    submitMessage(user: string, submitMessageRequest: SubmitMessageRequest, options?: any): AxiosPromise<SubmitMessageResponse>;

}

/**
 * SubmissionApi - object-oriented interface
 * @export
 * @class SubmissionApi
 * @extends {BaseAPI}
 */
export class SubmissionApi extends BaseAPI implements SubmissionApiInterface {
    /**
     * Use this method to send emails from a user account
     * @summary Submit a Message for Delivery
     * @param {string} user Users unique ID
     * @param {SubmitMessageRequest} submitMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public submitMessage(user: string, submitMessageRequest: SubmitMessageRequest, options?: any) {
        return SubmissionApiFp(this.configuration).submitMessage(user, submitMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TwoFactorAuthApi - axios parameter creator
 * @export
 */
export const TwoFactorAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method checks if a TOTP token provided by a User is valid for authentication
         * @summary Validate TOTP Token
         * @param {string} user ID of the User
         * @param {CheckTotp2FARequest} checkTotp2FARequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTotp2FA: async (user: string, checkTotp2FARequest: CheckTotp2FARequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('checkTotp2FA', 'user', user)
            // verify required parameter 'checkTotp2FARequest' is not null or undefined
            assertParamExists('checkTotp2FA', 'checkTotp2FARequest', checkTotp2FARequest)
            const localVarPath = `/users/{user}/2fa/totp/check`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkTotp2FARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method disables all 2FA mechanisms a user might have set up
         * @summary Disable 2FA
         * @param {string} user ID of the User
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable2FA: async (user: string, sess?: string, ip?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('disable2FA', 'user', user)
            const localVarPath = `/users/{user}/2fa`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (sess !== undefined) {
                localVarQueryParameter['sess'] = sess;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method disables custom 2FA. If it was the only 2FA set up, then account password for IMAP/POP3/SMTP gets enabled again
         * @summary Disable custom 2FA for a user
         * @param {string} user ID of the User
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableCustom2FA: async (user: string, sess?: string, ip?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('disableCustom2FA', 'user', user)
            const localVarPath = `/users/{user}/2fa/custom`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (sess !== undefined) {
                localVarQueryParameter['sess'] = sess;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method disables TOTP for a user. Does not affect other 2FA mechanisms a user might have set up
         * @summary Disable TOTP auth
         * @param {string} user ID of the User
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTotp2FA: async (user: string, sess?: string, ip?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('disableTotp2FA', 'user', user)
            const localVarPath = `/users/{user}/2fa/totp`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (sess !== undefined) {
                localVarQueryParameter['sess'] = sess;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method disables account password for IMAP/POP3/SMTP
         * @summary Enable custom 2FA for a user
         * @param {string} user ID of the User
         * @param {EnableCustom2FARequest} [enableCustom2FARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableCustom2FA: async (user: string, enableCustom2FARequest?: EnableCustom2FARequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('enableCustom2FA', 'user', user)
            const localVarPath = `/users/{user}/2fa/custom`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(enableCustom2FARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method enables TOTP for a user by verifying the seed value generated from 2fa/totp/setup
         * @summary Enable TOTP seed
         * @param {string} user ID of the User
         * @param {EnableTotp2FARequest} enableTotp2FARequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTotp2FA: async (user: string, enableTotp2FARequest: EnableTotp2FARequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('enableTotp2FA', 'user', user)
            // verify required parameter 'enableTotp2FARequest' is not null or undefined
            assertParamExists('enableTotp2FA', 'enableTotp2FARequest', enableTotp2FARequest)
            const localVarPath = `/users/{user}/2fa/totp/enable`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(enableTotp2FARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint
         * @summary Generate TOTP seed
         * @param {string} user ID of the User
         * @param {SetupTotp2FARequest} setupTotp2FARequest This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupTotp2FA: async (user: string, setupTotp2FARequest: SetupTotp2FARequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('setupTotp2FA', 'user', user)
            // verify required parameter 'setupTotp2FARequest' is not null or undefined
            assertParamExists('setupTotp2FA', 'setupTotp2FARequest', setupTotp2FARequest)
            const localVarPath = `/users/{user}/2fa/totp/setup`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setupTotp2FARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TwoFactorAuthApi - functional programming interface
 * @export
 */
export const TwoFactorAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TwoFactorAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * This method checks if a TOTP token provided by a User is valid for authentication
         * @summary Validate TOTP Token
         * @param {string} user ID of the User
         * @param {CheckTotp2FARequest} checkTotp2FARequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkTotp2FA(user: string, checkTotp2FARequest: CheckTotp2FARequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkTotp2FA(user, checkTotp2FARequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method disables all 2FA mechanisms a user might have set up
         * @summary Disable 2FA
         * @param {string} user ID of the User
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disable2FA(user: string, sess?: string, ip?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disable2FA(user, sess, ip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method disables custom 2FA. If it was the only 2FA set up, then account password for IMAP/POP3/SMTP gets enabled again
         * @summary Disable custom 2FA for a user
         * @param {string} user ID of the User
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableCustom2FA(user: string, sess?: string, ip?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableCustom2FA(user, sess, ip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method disables TOTP for a user. Does not affect other 2FA mechanisms a user might have set up
         * @summary Disable TOTP auth
         * @param {string} user ID of the User
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableTotp2FA(user: string, sess?: string, ip?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableTotp2FA(user, sess, ip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method disables account password for IMAP/POP3/SMTP
         * @summary Enable custom 2FA for a user
         * @param {string} user ID of the User
         * @param {EnableCustom2FARequest} [enableCustom2FARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableCustom2FA(user: string, enableCustom2FARequest?: EnableCustom2FARequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableCustom2FA(user, enableCustom2FARequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method enables TOTP for a user by verifying the seed value generated from 2fa/totp/setup
         * @summary Enable TOTP seed
         * @param {string} user ID of the User
         * @param {EnableTotp2FARequest} enableTotp2FARequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableTotp2FA(user: string, enableTotp2FARequest: EnableTotp2FARequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableTotp2FA(user, enableTotp2FARequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint
         * @summary Generate TOTP seed
         * @param {string} user ID of the User
         * @param {SetupTotp2FARequest} setupTotp2FARequest This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupTotp2FA(user: string, setupTotp2FARequest: SetupTotp2FARequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetupTotp2FAResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupTotp2FA(user, setupTotp2FARequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TwoFactorAuthApi - factory interface
 * @export
 */
export const TwoFactorAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TwoFactorAuthApiFp(configuration)
    return {
        /**
         * This method checks if a TOTP token provided by a User is valid for authentication
         * @summary Validate TOTP Token
         * @param {string} user ID of the User
         * @param {CheckTotp2FARequest} checkTotp2FARequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTotp2FA(user: string, checkTotp2FARequest: CheckTotp2FARequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.checkTotp2FA(user, checkTotp2FARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This method disables all 2FA mechanisms a user might have set up
         * @summary Disable 2FA
         * @param {string} user ID of the User
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable2FA(user: string, sess?: string, ip?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.disable2FA(user, sess, ip, options).then((request) => request(axios, basePath));
        },
        /**
         * This method disables custom 2FA. If it was the only 2FA set up, then account password for IMAP/POP3/SMTP gets enabled again
         * @summary Disable custom 2FA for a user
         * @param {string} user ID of the User
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableCustom2FA(user: string, sess?: string, ip?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.disableCustom2FA(user, sess, ip, options).then((request) => request(axios, basePath));
        },
        /**
         * This method disables TOTP for a user. Does not affect other 2FA mechanisms a user might have set up
         * @summary Disable TOTP auth
         * @param {string} user ID of the User
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTotp2FA(user: string, sess?: string, ip?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.disableTotp2FA(user, sess, ip, options).then((request) => request(axios, basePath));
        },
        /**
         * This method disables account password for IMAP/POP3/SMTP
         * @summary Enable custom 2FA for a user
         * @param {string} user ID of the User
         * @param {EnableCustom2FARequest} [enableCustom2FARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableCustom2FA(user: string, enableCustom2FARequest?: EnableCustom2FARequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.enableCustom2FA(user, enableCustom2FARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This method enables TOTP for a user by verifying the seed value generated from 2fa/totp/setup
         * @summary Enable TOTP seed
         * @param {string} user ID of the User
         * @param {EnableTotp2FARequest} enableTotp2FARequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTotp2FA(user: string, enableTotp2FARequest: EnableTotp2FARequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.enableTotp2FA(user, enableTotp2FARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint
         * @summary Generate TOTP seed
         * @param {string} user ID of the User
         * @param {SetupTotp2FARequest} setupTotp2FARequest This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupTotp2FA(user: string, setupTotp2FARequest: SetupTotp2FARequest, options?: any): AxiosPromise<SetupTotp2FAResponse> {
            return localVarFp.setupTotp2FA(user, setupTotp2FARequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TwoFactorAuthApi - interface
 * @export
 * @interface TwoFactorAuthApi
 */
export interface TwoFactorAuthApiInterface {
    /**
     * This method checks if a TOTP token provided by a User is valid for authentication
     * @summary Validate TOTP Token
     * @param {string} user ID of the User
     * @param {CheckTotp2FARequest} checkTotp2FARequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApiInterface
     */
    checkTotp2FA(user: string, checkTotp2FARequest: CheckTotp2FARequest, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * This method disables all 2FA mechanisms a user might have set up
     * @summary Disable 2FA
     * @param {string} user ID of the User
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApiInterface
     */
    disable2FA(user: string, sess?: string, ip?: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * This method disables custom 2FA. If it was the only 2FA set up, then account password for IMAP/POP3/SMTP gets enabled again
     * @summary Disable custom 2FA for a user
     * @param {string} user ID of the User
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApiInterface
     */
    disableCustom2FA(user: string, sess?: string, ip?: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * This method disables TOTP for a user. Does not affect other 2FA mechanisms a user might have set up
     * @summary Disable TOTP auth
     * @param {string} user ID of the User
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApiInterface
     */
    disableTotp2FA(user: string, sess?: string, ip?: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * This method disables account password for IMAP/POP3/SMTP
     * @summary Enable custom 2FA for a user
     * @param {string} user ID of the User
     * @param {EnableCustom2FARequest} [enableCustom2FARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApiInterface
     */
    enableCustom2FA(user: string, enableCustom2FARequest?: EnableCustom2FARequest, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * This method enables TOTP for a user by verifying the seed value generated from 2fa/totp/setup
     * @summary Enable TOTP seed
     * @param {string} user ID of the User
     * @param {EnableTotp2FARequest} enableTotp2FARequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApiInterface
     */
    enableTotp2FA(user: string, enableTotp2FARequest: EnableTotp2FARequest, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint
     * @summary Generate TOTP seed
     * @param {string} user ID of the User
     * @param {SetupTotp2FARequest} setupTotp2FARequest This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApiInterface
     */
    setupTotp2FA(user: string, setupTotp2FARequest: SetupTotp2FARequest, options?: any): AxiosPromise<SetupTotp2FAResponse>;

}

/**
 * TwoFactorAuthApi - object-oriented interface
 * @export
 * @class TwoFactorAuthApi
 * @extends {BaseAPI}
 */
export class TwoFactorAuthApi extends BaseAPI implements TwoFactorAuthApiInterface {
    /**
     * This method checks if a TOTP token provided by a User is valid for authentication
     * @summary Validate TOTP Token
     * @param {string} user ID of the User
     * @param {CheckTotp2FARequest} checkTotp2FARequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApi
     */
    public checkTotp2FA(user: string, checkTotp2FARequest: CheckTotp2FARequest, options?: any) {
        return TwoFactorAuthApiFp(this.configuration).checkTotp2FA(user, checkTotp2FARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method disables all 2FA mechanisms a user might have set up
     * @summary Disable 2FA
     * @param {string} user ID of the User
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApi
     */
    public disable2FA(user: string, sess?: string, ip?: string, options?: any) {
        return TwoFactorAuthApiFp(this.configuration).disable2FA(user, sess, ip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method disables custom 2FA. If it was the only 2FA set up, then account password for IMAP/POP3/SMTP gets enabled again
     * @summary Disable custom 2FA for a user
     * @param {string} user ID of the User
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApi
     */
    public disableCustom2FA(user: string, sess?: string, ip?: string, options?: any) {
        return TwoFactorAuthApiFp(this.configuration).disableCustom2FA(user, sess, ip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method disables TOTP for a user. Does not affect other 2FA mechanisms a user might have set up
     * @summary Disable TOTP auth
     * @param {string} user ID of the User
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApi
     */
    public disableTotp2FA(user: string, sess?: string, ip?: string, options?: any) {
        return TwoFactorAuthApiFp(this.configuration).disableTotp2FA(user, sess, ip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method disables account password for IMAP/POP3/SMTP
     * @summary Enable custom 2FA for a user
     * @param {string} user ID of the User
     * @param {EnableCustom2FARequest} [enableCustom2FARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApi
     */
    public enableCustom2FA(user: string, enableCustom2FARequest?: EnableCustom2FARequest, options?: any) {
        return TwoFactorAuthApiFp(this.configuration).enableCustom2FA(user, enableCustom2FARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method enables TOTP for a user by verifying the seed value generated from 2fa/totp/setup
     * @summary Enable TOTP seed
     * @param {string} user ID of the User
     * @param {EnableTotp2FARequest} enableTotp2FARequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApi
     */
    public enableTotp2FA(user: string, enableTotp2FARequest: EnableTotp2FARequest, options?: any) {
        return TwoFactorAuthApiFp(this.configuration).enableTotp2FA(user, enableTotp2FARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint
     * @summary Generate TOTP seed
     * @param {string} user ID of the User
     * @param {SetupTotp2FARequest} setupTotp2FARequest This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFactorAuthApi
     */
    public setupTotp2FA(user: string, setupTotp2FARequest: SetupTotp2FARequest, options?: any) {
        return TwoFactorAuthApiFp(this.configuration).setupTotp2FA(user, setupTotp2FARequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method deletes user and address entries from DB and schedules a background task to delete messages. You can call this method several times even if the user has already been deleted, in case there are still some pending messages.
         * @summary Delete a User
         * @param {string} id Users unique ID.
         * @param {string} [deleteAfter] Delete user entry from registry but keep all user data until provided date. User account is fully recoverable up to that date.
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, deleteAfter?: string, sess?: string, ip?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (deleteAfter !== undefined) {
                localVarQueryParameter['deleteAfter'] = (deleteAfter as any instanceof Date) ?
                    (deleteAfter as any).toISOString() :
                    deleteAfter;
            }

            if (sess !== undefined) {
                localVarQueryParameter['sess'] = sess;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This api call returns an EventSource response. Listen on this stream to get notifications about changes in messages and mailboxes. Returned events are JSON encoded strings
         * @summary Open change stream
         * @param {string} id Users unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdates: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUpdates', 'id', id)
            const localVarPath = `/users/{id}/updates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request User information
         * @param {string} id Users unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List registered Users
         * @param {string} [query] Partial match of username or default email address
         * @param {string} [forward] Partial match of a forward email address or URL
         * @param {string} [tags] Comma separated list of tags. The User must have at least one to be set
         * @param {string} [requiredTags] Comma separated list of tags. The User must have all listed tags to be set
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (query?: string, forward?: string, tags?: string, requiredTags?: string, metaData?: boolean, internalData?: boolean, limit?: number, page?: number, next?: string, previous?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (forward !== undefined) {
                localVarQueryParameter['forward'] = forward;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (requiredTags !== undefined) {
                localVarQueryParameter['requiredTags'] = requiredTags;
            }

            if (metaData !== undefined) {
                localVarQueryParameter['metaData'] = metaData;
            }

            if (internalData !== undefined) {
                localVarQueryParameter['internalData'] = internalData;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method logs out all user sessions in IMAP
         * @summary Log out User
         * @param {string} id Users unique ID.
         * @param {LogoutUserRequest} logoutUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (id: string, logoutUserRequest: LogoutUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logoutUser', 'id', id)
            // verify required parameter 'logoutUserRequest' is not null or undefined
            assertParamExists('logoutUser', 'logoutUserRequest', logoutUserRequest)
            const localVarPath = `/users/{id}/logout`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logoutUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method recalculates quota usage for a User. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact.
         * @summary Recalculate User quota
         * @param {string} user Users unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recalculateQuota: async (user: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('recalculateQuota', 'user', user)
            const localVarPath = `/users/{user}/quota/reset`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method recalculates quota usage for all Users. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact.
         * @summary Recalculate Quota for all Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recalculateQuotaAllUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/quota/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method generates a new temporary password for a User. Additionally it removes all two-factor authentication settings
         * @summary Reset password for a User
         * @param {string} id Users unique ID.
         * @param {ResetUserPasswordRequest} [resetUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword: async (id: string, resetUserPasswordRequest?: ResetUserPasswordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resetUserPassword', 'id', id)
            const localVarPath = `/users/{id}/password/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resolve ID for a username
         * @param {string} username Username of the User. Alphanumeric value. Must start with a letter, dots are allowed but informational only (\&quot;user.name\&quot; is the same as \&quot;username\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveUser: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('resolveUser', 'username', username)
            const localVarPath = `/users/resolve/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to cancel a timed deletion task scheduled by `DELETE /user/{id}`. If user data is not yet deleted then the account is fully recovered, except any email addresses that might have been already recycled
         * @summary Cancel user deletion task
         * @param {string} id Users unique ID.
         * @param {UserRestoreRequest} userRestoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser: async (id: string, userRestoreRequest: UserRestoreRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('restoreUser', 'id', id)
            // verify required parameter 'userRestoreRequest' is not null or undefined
            assertParamExists('restoreUser', 'userRestoreRequest', userRestoreRequest)
            const localVarPath = `/users/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRestoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return recovery info for a deleted user
         * @param {string} id Users unique ID.
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUserInfo: async (id: string, sess?: string, ip?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('restoreUserInfo', 'id', id)
            const localVarPath = `/users/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (sess !== undefined) {
                localVarQueryParameter['sess'] = sess;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update User information
         * @param {string} id Users unique ID.
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, updateUserRequest: UpdateUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('updateUser', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method deletes user and address entries from DB and schedules a background task to delete messages. You can call this method several times even if the user has already been deleted, in case there are still some pending messages.
         * @summary Delete a User
         * @param {string} id Users unique ID.
         * @param {string} [deleteAfter] Delete user entry from registry but keep all user data until provided date. User account is fully recoverable up to that date.
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, deleteAfter?: string, sess?: string, ip?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, deleteAfter, sess, ip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This api call returns an EventSource response. Listen on this stream to get notifications about changes in messages and mailboxes. Returned events are JSON encoded strings
         * @summary Open change stream
         * @param {string} id Users unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpdates(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpdates(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request User information
         * @param {string} id Users unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List registered Users
         * @param {string} [query] Partial match of username or default email address
         * @param {string} [forward] Partial match of a forward email address or URL
         * @param {string} [tags] Comma separated list of tags. The User must have at least one to be set
         * @param {string} [requiredTags] Comma separated list of tags. The User must have all listed tags to be set
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(query?: string, forward?: string, tags?: string, requiredTags?: string, metaData?: boolean, internalData?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(query, forward, tags, requiredTags, metaData, internalData, limit, page, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method logs out all user sessions in IMAP
         * @summary Log out User
         * @param {string} id Users unique ID.
         * @param {LogoutUserRequest} logoutUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(id: string, logoutUserRequest: LogoutUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(id, logoutUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method recalculates quota usage for a User. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact.
         * @summary Recalculate User quota
         * @param {string} user Users unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recalculateQuota(user: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecalculateQuotaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recalculateQuota(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method recalculates quota usage for all Users. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact.
         * @summary Recalculate Quota for all Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recalculateQuotaAllUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recalculateQuotaAllUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method generates a new temporary password for a User. Additionally it removes all two-factor authentication settings
         * @summary Reset password for a User
         * @param {string} id Users unique ID.
         * @param {ResetUserPasswordRequest} [resetUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetUserPassword(id: string, resetUserPasswordRequest?: ResetUserPasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetUserPasswordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetUserPassword(id, resetUserPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resolve ID for a username
         * @param {string} username Username of the User. Alphanumeric value. Must start with a letter, dots are allowed but informational only (\&quot;user.name\&quot; is the same as \&quot;username\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveUser(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolveIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveUser(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to cancel a timed deletion task scheduled by `DELETE /user/{id}`. If user data is not yet deleted then the account is fully recovered, except any email addresses that might have been already recycled
         * @summary Cancel user deletion task
         * @param {string} id Users unique ID.
         * @param {UserRestoreRequest} userRestoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreUser(id: string, userRestoreRequest: UserRestoreRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreUser(id, userRestoreRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return recovery info for a deleted user
         * @param {string} id Users unique ID.
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreUserInfo(id: string, sess?: string, ip?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreUserInfo(id, sess, ip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update User information
         * @param {string} id Users unique ID.
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, updateUserRequest: UpdateUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, updateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: any): AxiosPromise<CreateUserResponse> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This method deletes user and address entries from DB and schedules a background task to delete messages. You can call this method several times even if the user has already been deleted, in case there are still some pending messages.
         * @summary Delete a User
         * @param {string} id Users unique ID.
         * @param {string} [deleteAfter] Delete user entry from registry but keep all user data until provided date. User account is fully recoverable up to that date.
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, deleteAfter?: string, sess?: string, ip?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteUser(id, deleteAfter, sess, ip, options).then((request) => request(axios, basePath));
        },
        /**
         * This api call returns an EventSource response. Listen on this stream to get notifications about changes in messages and mailboxes. Returned events are JSON encoded strings
         * @summary Open change stream
         * @param {string} id Users unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdates(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.getUpdates(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request User information
         * @param {string} id Users unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<GetUserResponse> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List registered Users
         * @param {string} [query] Partial match of username or default email address
         * @param {string} [forward] Partial match of a forward email address or URL
         * @param {string} [tags] Comma separated list of tags. The User must have at least one to be set
         * @param {string} [requiredTags] Comma separated list of tags. The User must have all listed tags to be set
         * @param {boolean} [metaData] If true, then includes metaData in the response
         * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(query?: string, forward?: string, tags?: string, requiredTags?: string, metaData?: boolean, internalData?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetUsersResponse> {
            return localVarFp.getUsers(query, forward, tags, requiredTags, metaData, internalData, limit, page, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * This method logs out all user sessions in IMAP
         * @summary Log out User
         * @param {string} id Users unique ID.
         * @param {LogoutUserRequest} logoutUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(id: string, logoutUserRequest: LogoutUserRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.logoutUser(id, logoutUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This method recalculates quota usage for a User. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact.
         * @summary Recalculate User quota
         * @param {string} user Users unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recalculateQuota(user: string, options?: any): AxiosPromise<RecalculateQuotaResponse> {
            return localVarFp.recalculateQuota(user, options).then((request) => request(axios, basePath));
        },
        /**
         * This method recalculates quota usage for all Users. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact.
         * @summary Recalculate Quota for all Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recalculateQuotaAllUsers(options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.recalculateQuotaAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * This method generates a new temporary password for a User. Additionally it removes all two-factor authentication settings
         * @summary Reset password for a User
         * @param {string} id Users unique ID.
         * @param {ResetUserPasswordRequest} [resetUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(id: string, resetUserPasswordRequest?: ResetUserPasswordRequest, options?: any): AxiosPromise<ResetUserPasswordResponse> {
            return localVarFp.resetUserPassword(id, resetUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resolve ID for a username
         * @param {string} username Username of the User. Alphanumeric value. Must start with a letter, dots are allowed but informational only (\&quot;user.name\&quot; is the same as \&quot;username\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveUser(username: string, options?: any): AxiosPromise<ResolveIdResponse> {
            return localVarFp.resolveUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to cancel a timed deletion task scheduled by `DELETE /user/{id}`. If user data is not yet deleted then the account is fully recovered, except any email addresses that might have been already recycled
         * @summary Cancel user deletion task
         * @param {string} id Users unique ID.
         * @param {UserRestoreRequest} userRestoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser(id: string, userRestoreRequest: UserRestoreRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.restoreUser(id, userRestoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return recovery info for a deleted user
         * @param {string} id Users unique ID.
         * @param {string} [sess] Session identifier for the logs
         * @param {string} [ip] IP address for the logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUserInfo(id: string, sess?: string, ip?: string, options?: any): AxiosPromise<RecoverInfoResponse> {
            return localVarFp.restoreUserInfo(id, sess, ip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update User information
         * @param {string} id Users unique ID.
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, updateUserRequest: UpdateUserRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateUser(id, updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * 
     * @summary Create new user
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    createUser(createUserRequest: CreateUserRequest, options?: any): AxiosPromise<CreateUserResponse>;

    /**
     * This method deletes user and address entries from DB and schedules a background task to delete messages. You can call this method several times even if the user has already been deleted, in case there are still some pending messages.
     * @summary Delete a User
     * @param {string} id Users unique ID.
     * @param {string} [deleteAfter] Delete user entry from registry but keep all user data until provided date. User account is fully recoverable up to that date.
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    deleteUser(id: string, deleteAfter?: string, sess?: string, ip?: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * This api call returns an EventSource response. Listen on this stream to get notifications about changes in messages and mailboxes. Returned events are JSON encoded strings
     * @summary Open change stream
     * @param {string} id Users unique ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUpdates(id: string, options?: any): AxiosPromise<string>;

    /**
     * 
     * @summary Request User information
     * @param {string} id Users unique ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUser(id: string, options?: any): AxiosPromise<GetUserResponse>;

    /**
     * 
     * @summary List registered Users
     * @param {string} [query] Partial match of username or default email address
     * @param {string} [forward] Partial match of a forward email address or URL
     * @param {string} [tags] Comma separated list of tags. The User must have at least one to be set
     * @param {string} [requiredTags] Comma separated list of tags. The User must have all listed tags to be set
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUsers(query?: string, forward?: string, tags?: string, requiredTags?: string, metaData?: boolean, internalData?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetUsersResponse>;

    /**
     * This method logs out all user sessions in IMAP
     * @summary Log out User
     * @param {string} id Users unique ID.
     * @param {LogoutUserRequest} logoutUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    logoutUser(id: string, logoutUserRequest: LogoutUserRequest, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * This method recalculates quota usage for a User. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact.
     * @summary Recalculate User quota
     * @param {string} user Users unique ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    recalculateQuota(user: string, options?: any): AxiosPromise<RecalculateQuotaResponse>;

    /**
     * This method recalculates quota usage for all Users. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact.
     * @summary Recalculate Quota for all Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    recalculateQuotaAllUsers(options?: any): AxiosPromise<SuccessResponse>;

    /**
     * This method generates a new temporary password for a User. Additionally it removes all two-factor authentication settings
     * @summary Reset password for a User
     * @param {string} id Users unique ID.
     * @param {ResetUserPasswordRequest} [resetUserPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    resetUserPassword(id: string, resetUserPasswordRequest?: ResetUserPasswordRequest, options?: any): AxiosPromise<ResetUserPasswordResponse>;

    /**
     * 
     * @summary Resolve ID for a username
     * @param {string} username Username of the User. Alphanumeric value. Must start with a letter, dots are allowed but informational only (\&quot;user.name\&quot; is the same as \&quot;username\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    resolveUser(username: string, options?: any): AxiosPromise<ResolveIdResponse>;

    /**
     * Use this endpoint to cancel a timed deletion task scheduled by `DELETE /user/{id}`. If user data is not yet deleted then the account is fully recovered, except any email addresses that might have been already recycled
     * @summary Cancel user deletion task
     * @param {string} id Users unique ID.
     * @param {UserRestoreRequest} userRestoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    restoreUser(id: string, userRestoreRequest: UserRestoreRequest, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary Return recovery info for a deleted user
     * @param {string} id Users unique ID.
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    restoreUserInfo(id: string, sess?: string, ip?: string, options?: any): AxiosPromise<RecoverInfoResponse>;

    /**
     * 
     * @summary Update User information
     * @param {string} id Users unique ID.
     * @param {UpdateUserRequest} updateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    updateUser(id: string, updateUserRequest: UpdateUserRequest, options?: any): AxiosPromise<SuccessResponse>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * 
     * @summary Create new user
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(createUserRequest: CreateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method deletes user and address entries from DB and schedules a background task to delete messages. You can call this method several times even if the user has already been deleted, in case there are still some pending messages.
     * @summary Delete a User
     * @param {string} id Users unique ID.
     * @param {string} [deleteAfter] Delete user entry from registry but keep all user data until provided date. User account is fully recoverable up to that date.
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: string, deleteAfter?: string, sess?: string, ip?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(id, deleteAfter, sess, ip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This api call returns an EventSource response. Listen on this stream to get notifications about changes in messages and mailboxes. Returned events are JSON encoded strings
     * @summary Open change stream
     * @param {string} id Users unique ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUpdates(id: string, options?: any) {
        return UsersApiFp(this.configuration).getUpdates(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request User information
     * @param {string} id Users unique ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: string, options?: any) {
        return UsersApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List registered Users
     * @param {string} [query] Partial match of username or default email address
     * @param {string} [forward] Partial match of a forward email address or URL
     * @param {string} [tags] Comma separated list of tags. The User must have at least one to be set
     * @param {string} [requiredTags] Comma separated list of tags. The User must have all listed tags to be set
     * @param {boolean} [metaData] If true, then includes metaData in the response
     * @param {boolean} [internalData] If true, then includes internalData in the response. Not shown for user-role tokens.
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(query?: string, forward?: string, tags?: string, requiredTags?: string, metaData?: boolean, internalData?: boolean, limit?: number, page?: number, next?: string, previous?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsers(query, forward, tags, requiredTags, metaData, internalData, limit, page, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method logs out all user sessions in IMAP
     * @summary Log out User
     * @param {string} id Users unique ID.
     * @param {LogoutUserRequest} logoutUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public logoutUser(id: string, logoutUserRequest: LogoutUserRequest, options?: any) {
        return UsersApiFp(this.configuration).logoutUser(id, logoutUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method recalculates quota usage for a User. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact.
     * @summary Recalculate User quota
     * @param {string} user Users unique ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public recalculateQuota(user: string, options?: any) {
        return UsersApiFp(this.configuration).recalculateQuota(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method recalculates quota usage for all Users. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact.
     * @summary Recalculate Quota for all Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public recalculateQuotaAllUsers(options?: any) {
        return UsersApiFp(this.configuration).recalculateQuotaAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method generates a new temporary password for a User. Additionally it removes all two-factor authentication settings
     * @summary Reset password for a User
     * @param {string} id Users unique ID.
     * @param {ResetUserPasswordRequest} [resetUserPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resetUserPassword(id: string, resetUserPasswordRequest?: ResetUserPasswordRequest, options?: any) {
        return UsersApiFp(this.configuration).resetUserPassword(id, resetUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resolve ID for a username
     * @param {string} username Username of the User. Alphanumeric value. Must start with a letter, dots are allowed but informational only (\&quot;user.name\&quot; is the same as \&quot;username\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resolveUser(username: string, options?: any) {
        return UsersApiFp(this.configuration).resolveUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to cancel a timed deletion task scheduled by `DELETE /user/{id}`. If user data is not yet deleted then the account is fully recovered, except any email addresses that might have been already recycled
     * @summary Cancel user deletion task
     * @param {string} id Users unique ID.
     * @param {UserRestoreRequest} userRestoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public restoreUser(id: string, userRestoreRequest: UserRestoreRequest, options?: any) {
        return UsersApiFp(this.configuration).restoreUser(id, userRestoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return recovery info for a deleted user
     * @param {string} id Users unique ID.
     * @param {string} [sess] Session identifier for the logs
     * @param {string} [ip] IP address for the logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public restoreUserInfo(id: string, sess?: string, ip?: string, options?: any) {
        return UsersApiFp(this.configuration).restoreUserInfo(id, sess, ip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update User information
     * @param {string} id Users unique ID.
     * @param {UpdateUserRequest} updateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: string, updateUserRequest: UpdateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).updateUser(id, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new webhook
         * @summary Create new Webhook
         * @param {CreateWebhookRequest} createWebhookRequest Create new webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (createWebhookRequest: CreateWebhookRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookRequest' is not null or undefined
            assertParamExists('createWebhook', 'createWebhookRequest', createWebhookRequest)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a webhook
         * @param {string} webhook ID of the Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhook: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhook' is not null or undefined
            assertParamExists('deleteWebhook', 'webhook', webhook)
            const localVarPath = `/webhooks/{webhook}`
                .replace(`{${"webhook"}}`, encodeURIComponent(String(webhook)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List registered Webhooks
         * @param {string} type Prefix or exact match. Prefix match must end with \&quot;.*\&quot;, eg \&quot;channel.*\&quot;. Use \&quot;*\&quot; for all types
         * @param {string} [user] User ID
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: async (type: string, user?: string, limit?: number, page?: number, next?: string, previous?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getWebhooks', 'type', type)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Access-Token", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new webhook
         * @summary Create new Webhook
         * @param {CreateWebhookRequest} createWebhookRequest Create new webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(createWebhookRequest: CreateWebhookRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a webhook
         * @param {string} webhook ID of the Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhook: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List registered Webhooks
         * @param {string} type Prefix or exact match. Prefix match must end with \&quot;.*\&quot;, eg \&quot;channel.*\&quot;. Use \&quot;*\&quot; for all types
         * @param {string} [user] User ID
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooks(type: string, user?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWebhooksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooks(type, user, limit, page, next, previous, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Create new webhook
         * @summary Create new Webhook
         * @param {CreateWebhookRequest} createWebhookRequest Create new webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookRequest: CreateWebhookRequest, options?: any): AxiosPromise<CreateWebhookResponse> {
            return localVarFp.createWebhook(createWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a webhook
         * @param {string} webhook ID of the Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhook: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteWebhook(webhook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List registered Webhooks
         * @param {string} type Prefix or exact match. Prefix match must end with \&quot;.*\&quot;, eg \&quot;channel.*\&quot;. Use \&quot;*\&quot; for all types
         * @param {string} [user] User ID
         * @param {number} [limit] How many records to return
         * @param {number} [page] Current page number. Informational only, page numbers start from 1
         * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
         * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(type: string, user?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetWebhooksResponse> {
            return localVarFp.getWebhooks(type, user, limit, page, next, previous, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - interface
 * @export
 * @interface WebhooksApi
 */
export interface WebhooksApiInterface {
    /**
     * Create new webhook
     * @summary Create new Webhook
     * @param {CreateWebhookRequest} createWebhookRequest Create new webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    createWebhook(createWebhookRequest: CreateWebhookRequest, options?: any): AxiosPromise<CreateWebhookResponse>;

    /**
     * 
     * @summary Delete a webhook
     * @param {string} webhook ID of the Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    deleteWebhook(webhook: string, options?: any): AxiosPromise<SuccessResponse>;

    /**
     * 
     * @summary List registered Webhooks
     * @param {string} type Prefix or exact match. Prefix match must end with \&quot;.*\&quot;, eg \&quot;channel.*\&quot;. Use \&quot;*\&quot; for all types
     * @param {string} [user] User ID
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    getWebhooks(type: string, user?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any): AxiosPromise<GetWebhooksResponse>;

}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI implements WebhooksApiInterface {
    /**
     * Create new webhook
     * @summary Create new Webhook
     * @param {CreateWebhookRequest} createWebhookRequest Create new webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public createWebhook(createWebhookRequest: CreateWebhookRequest, options?: any) {
        return WebhooksApiFp(this.configuration).createWebhook(createWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a webhook
     * @param {string} webhook ID of the Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(webhook: string, options?: any) {
        return WebhooksApiFp(this.configuration).deleteWebhook(webhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List registered Webhooks
     * @param {string} type Prefix or exact match. Prefix match must end with \&quot;.*\&quot;, eg \&quot;channel.*\&quot;. Use \&quot;*\&quot; for all types
     * @param {string} [user] User ID
     * @param {number} [limit] How many records to return
     * @param {number} [page] Current page number. Informational only, page numbers start from 1
     * @param {string} [next] Cursor value for next page, retrieved from nextCursor response value
     * @param {string} [previous] Cursor value for previous page, retrieved from previousCursor response value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooks(type: string, user?: string, limit?: number, page?: number, next?: string, previous?: string, options?: any) {
        return WebhooksApiFp(this.configuration).getWebhooks(type, user, limit, page, next, previous, options).then((request) => request(this.axios, this.basePath));
    }
}


